{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon.svg","path":"images/apple-touch-icon.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/blog-avatar.jpg","path":"images/blog-avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/default-avatar.gif","path":"images/default-avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-battery-three-quarters-solid.svg","path":"images/favicon-battery-three-quarters-solid.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/grin-beam-sweat-regular.svg","path":"images/grin-beam-sweat-regular.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-battery-three-quarters-solid.svg","path":"images/logo-battery-three-quarters-solid.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/_drafts/time-complexity.md","hash":"bd7a14baa9ecb9814b3b215ead85290a5298ea36","modified":1616143136046},{"_id":"source/_posts/2021-02-18-hello-world.md","hash":"375cabeccbb68577dd2bf0875e0e91cc0c240681","modified":1615277369854},{"_id":"source/_posts/2021-02-19-signed-number-representations.md","hash":"ec841ab335d62609b221e8cb463f9d3368de8d97","modified":1616765079315},{"_id":"source/_posts/2021-03-10-elementary-function.md","hash":"0d7f40a41b3f73cdd8fc2dfcdca11bff510ca44d","modified":1616765423792},{"_id":"source/_posts/2021-03-18-hello-world.md","hash":"43859b8a4425f3e136daf4da5baa6b6b557bab1b","modified":1616764061868},{"_id":"source/_posts/2021-03-24-android-display-refresh.md","hash":"6a6702fcc021171c38cd6db995ef95a2285c79a2","modified":1617010195302},{"_id":"source/_posts/2021-03-25-android-sync-barrier.md","hash":"d5da4815228e4962617af7ba4bacacd1ce5b144a","modified":1616764506555},{"_id":"source/categories/index.md","hash":"29e653793b807ae1c092a4e1e000e3143c18b34f","modified":1615277369854},{"_id":"source/tags/index.md","hash":"47f28e8150e19e9fca41b4ada4d07b10b5d3ccc8","modified":1615277369855},{"_id":"source/_posts/2021-03-10-elementary-function/constant-function-example-1.png","hash":"55c373adc656ab40de3d6254caa3889f83daf30d","modified":1615463242154},{"_id":"source/_posts/2021-03-10-elementary-function/exponential-function-example-1.png","hash":"5414817c47e8074111a09cfc262354c5e89c7ec3","modified":1615865031412},{"_id":"source/_posts/2021-03-10-elementary-function/exponential-function-example-2.png","hash":"e07d060308e0fe9565a2bc7159d6f71d116d61e3","modified":1615865491659},{"_id":"source/_posts/2021-03-10-elementary-function/logarithmic-function-example-1.png","hash":"aa4861ff8de3896b9a56191f4ffb362bc17c1862","modified":1615985075948},{"_id":"source/_posts/2021-03-10-elementary-function/logarithmic-function-example-2.png","hash":"d44781054882732d63cf4d091f55ad791aff6553","modified":1615985453826},{"_id":"source/_posts/2021-03-10-elementary-function/power-function-example-1.png","hash":"3f476e9bbe7f0660cdb591a8852d0cf4c4d26d9b","modified":1615462750860},{"_id":"source/_posts/2021-03-10-elementary-function/power-function-example-3.png","hash":"c6cf26bc00b680a675ea0fb67753ad28e182a2da","modified":1615532219227},{"_id":"source/_posts/2021-03-10-elementary-function/power-function-example-4.png","hash":"5c98bc47edb22e4f29362aea7fbe742cbddba10d","modified":1615532273687},{"_id":"source/.DS_Store","hash":"91cb1e82549470603862b9e72a2cf083413daf53","modified":1636529842205},{"_id":"source/_posts/.DS_Store","hash":"9c0d907de7a04fae1856acd79f6aae2806856125","modified":1636530043090},{"_id":"source/_posts/2021-03-10-elementary-function/.DS_Store","hash":"e7e1d82885f856c4df675eed58e30e3c2f73fe3a","modified":1616053765333},{"_id":"source/_posts/2021-03-10-elementary-function/power-function-example-7.png","hash":"9eeb028343bc4861d960fb0555885aa38eb56d6e","modified":1615795241661},{"_id":"source/_posts/2021-03-10-elementary-function/logarithmic-function-example-3.png","hash":"e96d95ece9a7c6c4cd9b9406046bbba6bb66420a","modified":1616053740900},{"_id":"source/_posts/2021-03-10-elementary-function/power-function-example-2.png","hash":"a165e01dfc0a34615eb0d16138e56194dae0996c","modified":1615464078663},{"_id":"source/_posts/2021-03-10-elementary-function/power-function-example-5.png","hash":"0d3924bb93913b1219297b81f530b3619ba601f0","modified":1615532750674},{"_id":"source/_posts/2021-03-10-elementary-function/power-function-example-6.png","hash":"668098f02428d80435c283f45d388902be161dec","modified":1615532929622},{"_id":"themes/next/_config.yml","hash":"62d4eab09d9a160fc6ab4a312f14e8e3c1c2bfd1","modified":1616747926042},{"_id":"themes/next/.DS_Store","hash":"7606faed203a263021bc6e703c7182abd99eede6","modified":1614254822809},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1615277369855},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1615277369887},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1615277369855},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1615277369856},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1615277369862},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1615277369856},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1615277369857},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1615277369858},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1615277369858},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1615277369862},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1615277369858},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1615277369862},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1615277369863},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1615277369863},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1615277369863},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1615277369864},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1615277369863},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1615277369863},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1615277369864},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1615277369864},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1615277369864},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1615277369864},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1615277369865},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1615277369865},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1615277369865},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1615277369866},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1615277369866},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1615277369865},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1615277369866},{"_id":"themes/next/languages/zh-CN.yml","hash":"ccfa3076422eb3176f6437d1726c8bdfb47d515d","modified":1628232825050},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1615277369867},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1615277369867},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1615277369867},{"_id":"themes/next/layout/archive.swig","hash":"654c8c3183141f1d33854abf932ce65276874567","modified":1615277369885},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1615277369858},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1615277369885},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1615277369886},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1615277369886},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1615277369887},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1615277369886},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1615277369894},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1615277369859},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1615277369859},{"_id":"themes/next/source/.DS_Store","hash":"4d0efe53164d971f7998dc349a83838666784a10","modified":1614254824883},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1615277369859},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1615277369859},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1615277369860},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1615277369860},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1615277369860},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1615277369860},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1615277369861},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1615277369861},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1615277369861},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1615277369861},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1615277369862},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1615277369868},{"_id":"themes/next/layout/_macro/post.swig","hash":"b16867f15b537012c91880d1629343242cd11fdf","modified":1628232783756},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1615277369868},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1615277369868},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1615277369869},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1615277369870},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1615277369871},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1615277369873},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1615277369873},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1615277369873},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1615277369874},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1615277369875},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1615277369875},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1615277369876},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1615277369879},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1615277369881},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1615277369881},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1615277369887},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1615277369891},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1615277369892},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1615277369892},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1615277369892},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1615277369892},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1615277369893},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1615277369893},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1615277369893},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1615277369894},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1615277369894},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1615277369894},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1615277369895},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1615277369895},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1615277369895},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1615277369895},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1615277369895},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1615277369896},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1615277369896},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1615277369896},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1615277369896},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1615277369911},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1615277369917},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1615277369918},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1615277369918},{"_id":"themes/next/source/images/apple-touch-icon.svg","hash":"8293fb6815dd0d4a0024233dea9e884a54692c60","modified":1615277369918},{"_id":"themes/next/source/images/.DS_Store","hash":"294a69515384b339cd3a962a16c9f903a5649162","modified":1614307452503},{"_id":"themes/next/source/images/avatar.jpg","hash":"69ade96200fc246b4380344045d4fe941e76e969","modified":1615277369918},{"_id":"themes/next/source/images/blog-avatar.jpg","hash":"5b33e00552a500b4524574c02fec40717cd16cc7","modified":1615277369919},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1615277369919},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1615277369919},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1615277369920},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1615277369920},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1615277369920},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1615277369920},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1615277369921},{"_id":"themes/next/source/images/default-avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1615277369921},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1615277369921},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1615277369921},{"_id":"themes/next/source/images/favicon-battery-three-quarters-solid.svg","hash":"8293fb6815dd0d4a0024233dea9e884a54692c60","modified":1615277369921},{"_id":"themes/next/source/images/grin-beam-sweat-regular.svg","hash":"a2bd6f9258b83d9a4f18d34930cbf1638b3385aa","modified":1615277369922},{"_id":"themes/next/source/images/logo-battery-three-quarters-solid.svg","hash":"8293fb6815dd0d4a0024233dea9e884a54692c60","modified":1615277369922},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1615277369922},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1615277369922},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1615277369922},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1615277369923},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1615277369923},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1615277369923},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1615277369924},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1615277369924},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1615277369869},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1615277369869},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1615277369869},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1615277369869},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1615277369870},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1615277369870},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1615277369870},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1615277369871},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1615277369870},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1615277369871},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1615277369871},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1615277369872},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1615277369871},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1615277369872},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1615277369872},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1615277369872},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1615277369872},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1615277369873},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1615277369874},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1615277369874},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1615277369874},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1615277369875},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1615277369875},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1615277369875},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1615277369876},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1615277369876},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1615277369876},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1615277369877},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1615277369876},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1615277369877},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1615277369878},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1615277369878},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1615277369878},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1615277369879},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1615277369879},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1615277369880},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1615277369880},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1615277369880},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1615277369881},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1615277369882},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1615277369882},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"06aa847371cc5a412dfb4751b354d65f6af7830c","modified":1615277369882},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1615277369883},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1615277369883},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1615277369883},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1615277369884},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1615277369884},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1615277369885},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1615277369888},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1615277369888},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1615277369888},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1615277369889},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1615277369889},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1615277369889},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1615277369890},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1615277369890},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1615277369890},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1615277369891},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"ad00812024767f227066722203a34b0875461cb1","modified":1615277369891},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1615277369917},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1615277369916},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1615277369917},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1615277369916},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1615277369923},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1615277369917},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1615277369924},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1615277369927},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1615277369926},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1615277369897},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1615277369897},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1615277369897},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1615277369905},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1615277369907},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1615277369902},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1615277369905},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1615277369907},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1615277369908},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1615277369909},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1615277369909},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1615277369909},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1615277369909},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1615277369911},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1615277369912},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1615277369912},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1615277369912},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1615277369912},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1615277369912},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1615277369913},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1615277369913},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1615277369913},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1615277369913},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1615277369914},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1615277369913},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1615277369914},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1615277369914},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1615277369914},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1615277369914},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1615277369915},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1615277369915},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1615277369915},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1615277369925},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1615277369925},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1615277369898},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1615277369898},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1615277369898},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1615277369898},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1615277369898},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1615277369899},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1615277369899},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1615277369900},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1615277369899},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1615277369900},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1615277369900},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1615277369901},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1615277369900},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1615277369901},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1615277369901},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1615277369901},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1615277369901},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1615277369901},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1615277369902},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1615277369903},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1615277369902},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1615277369903},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1615277369902},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1615277369903},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1615277369903},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1615277369904},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1615277369903},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1615277369904},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1615277369904},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1615277369904},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1615277369904},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1615277369905},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1615277369905},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1615277369906},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1615277369906},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1615277369906},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1615277369906},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1615277369906},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1615277369907},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1615277369907},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1615277369907},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1615277369908},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1615277369908},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1615277369908},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1615277369908},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1615277369910},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1615277369910},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1615277369910},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1615277369910},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1615277369911},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1615277369911},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1615277369911},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1615277369856},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1615277369857},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1615277369857},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1615277369925},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1615277369926},{"_id":"source/_posts/2021-03-29-android-graphics-basis.md","hash":"99e9052cedf5f329978fb526f577e49084a0b747","modified":1621342732143},{"_id":"source/_posts/2021-03-29-android-graphics-basis/6i6h11.jpg","hash":"6aeade75afe32f850d4cf8a1d437d85b64b7d940","modified":1617075522430},{"_id":"source/_drafts/.DS_Store","hash":"b540356ea528d09939a02a6e38949b964272eb15","modified":1636460942632},{"_id":"source/_drafts/android-app-process-creation.md","hash":"d3eac187190b3ecbd9ed5d594081a2c1689022dd","modified":1629189261662},{"_id":"source/_drafts/my-understand-of-Binder.md","hash":"aef63d42cfcca4121843f799747b2b7c68d58751","modified":1628232259503},{"_id":"source/_posts/2021-03-29-graphics-basis.md","hash":"fc49ddf634475b550cdc31cb9169c1522bf8ef82","modified":1621338553773},{"_id":"source/_drafts/tcp-connection-establishment-and-termination.md","hash":"9776d9040c9d8d6debb5dbd07ec4211ae2b33225","modified":1636460396518},{"_id":"source/_drafts/tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p4.jpg","hash":"a330a80eb334c290f81669de9a57ff36ee1f3852","modified":1628670702478},{"_id":"source/_drafts/tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p3.jpg","hash":"65a340bf42ebc21079817c4cd2897c0b78261493","modified":1628670696519},{"_id":"source/_drafts/tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p2.jpg","hash":"99098ee45ff1bb614ce7f5b66a0d901f288701a1","modified":1628670667818},{"_id":"source/_drafts/tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p1.jpg","hash":"5c3f635bebbd13c821f3404eb95e0b56bad0f2a9","modified":1628670632876},{"_id":"source/_posts/2021-08-11-img-test.md","hash":"d05cd6c0ebb98acd76cef6ad725813d4c2576c88","modified":1628670981261},{"_id":"source/_posts/2021-08-11-img-test/zhihu_xiaolincoding_ans_p1.jpg","hash":"5c3f635bebbd13c821f3404eb95e0b56bad0f2a9","modified":1628670632876},{"_id":"source/_posts/2021-08-11-img-test/IMG_0105.PNG","hash":"272ed0c65ad6cf2326149f217c8f1aafe3e21829","modified":1628668207023},{"_id":"source/_posts/tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p2.jpg","hash":"99098ee45ff1bb614ce7f5b66a0d901f288701a1","modified":1628670667818},{"_id":"source/_posts/tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p4.jpg","hash":"a330a80eb334c290f81669de9a57ff36ee1f3852","modified":1628670702478},{"_id":"source/_posts/tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p3.jpg","hash":"65a340bf42ebc21079817c4cd2897c0b78261493","modified":1628670696519},{"_id":"source/_posts/tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p1.jpg","hash":"5c3f635bebbd13c821f3404eb95e0b56bad0f2a9","modified":1628670632876},{"_id":"source/_posts/tcp-connection-establishment-and-termination.md","hash":"64b7ac7e0b047b6d5a48a83b6ae545b565fae274","modified":1628670869706},{"_id":"source/_posts/2020-01-01-tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p2.jpg","hash":"99098ee45ff1bb614ce7f5b66a0d901f288701a1","modified":1628670667818},{"_id":"source/_posts/2020-01-01-tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p3.jpg","hash":"65a340bf42ebc21079817c4cd2897c0b78261493","modified":1628670696519},{"_id":"source/_posts/2020-01-01-tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p4.jpg","hash":"a330a80eb334c290f81669de9a57ff36ee1f3852","modified":1628670702478},{"_id":"source/_posts/2020-01-01-tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p1.jpg","hash":"5c3f635bebbd13c821f3404eb95e0b56bad0f2a9","modified":1628670632876},{"_id":"source/_drafts/file-descriptor.md","hash":"24627a19d1692d8f9b08588b23930f00f63602e4","modified":1629116801879},{"_id":"source/_posts/2020-01-01-tcp-connection-establishment-and-termination.md","hash":"7f4b758efd75aeaba767ed6c9d558d141ce61770","modified":1628673143439},{"_id":"source/_drafts/Exploring-Android-Binder.md","hash":"aef63d42cfcca4121843f799747b2b7c68d58751","modified":1628232259503},{"_id":"source/_drafts/Exploring-Zygote-Startup-Process.md","hash":"245ab47151c5dccb57b2ff15c98f4369f9c468e2","modified":1629268432897},{"_id":"source/_drafts/Understand-File-Descriptor.md","hash":"24627a19d1692d8f9b08588b23930f00f63602e4","modified":1629116801879},{"_id":"source/_drafts/Exploring-Android-App-Process-Startup-Process.md","hash":"babf78ad6495ec12ec6af4c07481c1ba44e0458a","modified":1629194094844},{"_id":"source/_drafts/exploring-android-binder.md","hash":"f7acd357a025254d5720dbd1669f81461649d650","modified":1629269351269},{"_id":"source/_drafts/exploring-zygote-startup-process.md","hash":"33f4fab549ad150d451261667dc79730a2b5f6d2","modified":1629712652453},{"_id":"source/_drafts/understand-file-descriptor.md","hash":"24627a19d1692d8f9b08588b23930f00f63602e4","modified":1629116801879},{"_id":"source/_drafts/exploring-android-app-process-startup-process.md","hash":"540665e56419514c5cffa4690ff1ec436ca7de24","modified":1629342358376},{"_id":"source/_drafts/exploring-init-process-startup-process.md","hash":"1da6a3a5b7e44d9bfdeb95e6d278a4d9d6dcf2bc","modified":1636458974735},{"_id":"source/_drafts/android-display-refresh.md","hash":"3f883d2632a0d223d7c9bac0406534541968f189","modified":1636460857503},{"_id":"source/_drafts/android-graphics-basis.md","hash":"1c030984ca544a08592f5a1dd8bd6a21c3b4b2ea","modified":1636460744683},{"_id":"source/_drafts/graphics-basis.md","hash":"3fd8559b47acf3517f276523695d452bb9b4be81","modified":1636460890293},{"_id":"source/_posts/2021-07-10-exploring-init-process-startup-process.md","hash":"5ad89faf8c768eed321896e75b74d7db992b6aea","modified":1636529961588}],"Category":[{"name":"ComputerScience","_id":"ckmsyc4ra00055nprdp3d27gx"},{"name":"Mathematics","_id":"ckmsyc4re00095npr7a605gff"},{"name":"Algorithm","parent":"ckmsyc4ra00055nprdp3d27gx","_id":"ckmsyc4rh000f5npr8h940wmh"},{"name":"Android","_id":"ckmsyc4ri000i5nprffv13va1"},{"name":"Framework","parent":"ckmsyc4ri000i5nprffv13va1","_id":"ckmsyc4rk000m5npr6wjm0y3r"},{"name":"Graphics","parent":"ckmsyc4rk000m5npr6wjm0y3r","_id":"ckmsyc4rl000o5npr0v7gbch2"},{"name":"Handler","parent":"ckmsyc4rk000m5npr6wjm0y3r","_id":"ckmsyc4rl000p5npr5xe96pw7"},{"name":"Graphics","_id":"ckoifpt4j0006m1pr7zm18tlb"},{"name":"Process","parent":"ckmsyc4ri000i5nprffv13va1","_id":"ckrzsw1zy00036sprcyf3beh5"},{"name":"Binder","parent":"ckmsyc4rk000m5npr6wjm0y3r","_id":"ckrzsw20000076spr2i0g1ol0"},{"name":"Linux","_id":"cksftg56z0001hlpr9ry98ndj"}],"Data":[],"Page":[{"date":"2021-02-23T09:18:35.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ndate: 2021-02-23 17:18:35\ntype: categories\ncomments: false\n---\n","updated":"2021-03-09T08:09:29.854Z","path":"categories/index.html","title":"","layout":"page","_id":"ckmsyc4r100005npr28fl6ktw","content":"","site":{"data":{}},"excerpt":"","more":""},{"date":"2021-02-23T09:07:17.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ndate: 2021-02-23 17:07:17\ntype: tags\ncomments: false\n---\n","updated":"2021-03-09T08:09:29.855Z","path":"tags/index.html","title":"","layout":"page","_id":"ckmsyc4r700025npr2rum6aq2","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"算法的时间复杂度","date":"2021-03-19T07:19:50.000Z","mathjax":true,"_content":"\n在计算机科学中，算法的时间复杂度是一个与算法输入值大小相关函数，它定性描述该算法的运行时间。\n\n\n\n# 定义\n\n\n\n\n\n# 时间复杂度的表示方法\n\n为了计算时间复杂度，我们通常会估计算法的操作单元数量，每个单元运行的时间都是相同的。因此，总运行时间和算法的操作单元数量最多相差一个常量系数。\n\n时间复杂度常用**渐进符号** $O$ 表示，而且不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。\n\n\n\n","source":"_drafts/time-complexity.md","raw":"---\ntitle: 算法的时间复杂度\ndate: 2021-03-19 15:19:50\ncategories:\n- [ComputerScience, Algorithm]\nmathjax: true\n---\n\n在计算机科学中，算法的时间复杂度是一个与算法输入值大小相关函数，它定性描述该算法的运行时间。\n\n\n\n# 定义\n\n\n\n\n\n# 时间复杂度的表示方法\n\n为了计算时间复杂度，我们通常会估计算法的操作单元数量，每个单元运行的时间都是相同的。因此，总运行时间和算法的操作单元数量最多相差一个常量系数。\n\n时间复杂度常用**渐进符号** $O$ 表示，而且不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。\n\n\n\n","slug":"time-complexity","published":0,"updated":"2021-03-19T08:38:56.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmsyc4r400015nprahox2qqz","content":"<p>在计算机科学中，算法的时间复杂度是一个与算法输入值大小相关函数，它定性描述该算法的运行时间。</p>\n<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><h1 id=\"时间复杂度的表示方法\"><a href=\"#时间复杂度的表示方法\" class=\"headerlink\" title=\"时间复杂度的表示方法\"></a>时间复杂度的表示方法</h1><p>为了计算时间复杂度，我们通常会估计算法的操作单元数量，每个单元运行的时间都是相同的。因此，总运行时间和算法的操作单元数量最多相差一个常量系数。</p>\n<p>时间复杂度常用<strong>渐进符号</strong> $O$ 表示，而且不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在计算机科学中，算法的时间复杂度是一个与算法输入值大小相关函数，它定性描述该算法的运行时间。</p>\n<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><h1 id=\"时间复杂度的表示方法\"><a href=\"#时间复杂度的表示方法\" class=\"headerlink\" title=\"时间复杂度的表示方法\"></a>时间复杂度的表示方法</h1><p>为了计算时间复杂度，我们通常会估计算法的操作单元数量，每个单元运行的时间都是相同的。因此，总运行时间和算法的操作单元数量最多相差一个常量系数。</p>\n<p>时间复杂度常用<strong>渐进符号</strong> $O$ 表示，而且不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。</p>\n"},{"title":"Hello World","date":"2021-02-18T03:49:09.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/2021-02-18-hello-world.md","raw":"---\ntitle: Hello World\ndate: 2021-02-18 11:49:09\ntags: Test\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2021-03-09T08:09:29.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmsyc4r700035npr5dbfdrkh","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>"},{"title":"符号数在计算机中的表示方法","date":"2021-02-19T03:49:09.000Z","mathjax":true,"_content":"\n计算机中符号数常用的表示方法：\n\n- 原码\n- 反码\n- 补码\n\n这三种表示方法均有符号位和数值位两部分，符号位都是用 0 表示 \"+\"，用 1 表示 \"-\"。而数值位，三种表示方法各不相同。\n\n<!-- more -->\n\n## 1. 原码\n\n原码是指一个二进制数左边加上符号位后所得到的码，即最高位为符号位。\n\n- 当二进制数大于 0 时，符号位为 0\n\n- 当二进制数小于 0 时，符号位为 1\n\n- 当二进制数等于 +0 时，符号位为 0\n\n- 当二进制数等于 -0 时，符号位为 1\n\n\n\n例如，用 8 位二进制表示一个数：\n\n```\n+10D = 00001010B\n\n-10D = 10001010B\n\n+127D = 01111111B\n```\n\n\n\n一个 n 位的原码，可以表示 ${2}^n$ 个数（此时 +0 和 -0 分别为两个不同的数）。\n\n数值范围是 $\\[\\-\\(\\{2}^{n-1} - 1\\)\\,\\{2}^{n-1} - 1\\]$。\n\n\n## 2. 反码\n\n反码表示法规定，正数的反码等于其原码，而负数的反码是对原码的数值位按位取反，并保留其符号位。\n\n例如，对二进制原码 10001010 求反码：\n\n```\n10001010(原码) = 11110101(反码)\n```\n\n在多数计算机中不采用反码表示数值。\n\n\n\n## 3. 补码\n\n在了解补码之前，先来看下，如果使用原码直接参与加减法运算会得到什么结果：\n\n```\n00000010 + 00000010 = 00000100，即 2 + 2 = 4，结果正确\n00000010 + 10000010 = 10000100，即 2 + (-2) = -4，结果错误\n```\n\n可见原码的符号位不能直接参与运算，必须与其他位分开，这就增加了硬件的开销和复杂性。\n\n### 3.1 补码的定义\n\n正数和 0 的补码就是该数字本身，而负数的补码是对原码的数值位按位取反再加 1。\n\n\n\n### 3.2 补码的运算\n\n补码的符号位可以直接参与运算，例如：\n\n```\n  (0000) 0000 0010 (2D)\n+ (0000) 1111 1110 (-2D)\n------------------------\n  (0001) 0000 0000 (0D)\n\n结果正确\n```\n\n```\n  (0000) 0000 0010 (2D)\n+ (0000) 1111 1111 (-1D)\n------------------------\n  (0001) 0000 0001 (1D)\n\n结果正确\n```\n\n```\n  (0000) 0000 0010 (2D)\n+ (0000) 1111 1101 (-3D)\n------------------------\n  (0000) 1111 1111 (-1D)\n\n结果正确\n```\n\n\n\n### 3.3 补码的数值范围\n\n在原码系统中，0 有两种表示方式（以 32 位的整数类型为例）：\n\n```\n正零：0000 0000 0000 0000 0000 0000 0000 0000\n\n负零：1000 0000 0000 0000 0000 0000 0000 0000\n```\n\n按照负数补码的计算方法，对负零原码的数值位按位取反再加 1，可得：\n\n```\n(0001) 0000 0000 0000 0000 0000 0000 0000 0000\n```\n\n由于溢出，可知正零和负零的补码是相同的，没必要区分正零和负零。\n\n**所以，在补码系统中，0只有一种表示方式。**\n\n\n\n因此，在32位的整数类型中，多出了一个数：\n\n```\n1000 0000 0000 0000 0000 0000 0000 0000\n```\n\n同时，在补码系统中，我们知道符号位可以直接参与运算：\n\n```\n  (0000) 1000 0000 0000 0000 0000 0000 0000 0001 (-2147483647D)\n+ (0000) 1111 1111 1111 1111 1111 1111 1111 1111 (-1D)\n---------------------------------------------------------------\n  (0001) 1000 0000 0000 0000 0000 0000 0000 0000 (-2147483648D)\n```\n于是，在补码系统中，$1$$\\underbrace{ 00\\cdots00 }_{n-1}$ 就表示了 n 位整数类型的最小值。\n\n**一个 n 位的补码，可以表示 $2^n$ 个数，其数值范围是 $\\[\\{-2}^{n-1}\\,\\{2}^{n-1} - 1\\]$。**\n\n> 参考：\n>\n> https://en.wikipedia.org/wiki/Signed_number_representations\n>\n> https://zh.wikipedia.org/wiki/%E6%9C%89%E7%AC%A6%E8%99%9F%E6%95%B8%E8%99%95%E7%90%86\n","source":"_posts/2021-02-19-signed-number-representations.md","raw":"---\ntitle: 符号数在计算机中的表示方法\ndate: 2021-02-19 11:49:09\ntags:\n- ComputerScience\nmathjax: true\n---\n\n计算机中符号数常用的表示方法：\n\n- 原码\n- 反码\n- 补码\n\n这三种表示方法均有符号位和数值位两部分，符号位都是用 0 表示 \"+\"，用 1 表示 \"-\"。而数值位，三种表示方法各不相同。\n\n<!-- more -->\n\n## 1. 原码\n\n原码是指一个二进制数左边加上符号位后所得到的码，即最高位为符号位。\n\n- 当二进制数大于 0 时，符号位为 0\n\n- 当二进制数小于 0 时，符号位为 1\n\n- 当二进制数等于 +0 时，符号位为 0\n\n- 当二进制数等于 -0 时，符号位为 1\n\n\n\n例如，用 8 位二进制表示一个数：\n\n```\n+10D = 00001010B\n\n-10D = 10001010B\n\n+127D = 01111111B\n```\n\n\n\n一个 n 位的原码，可以表示 ${2}^n$ 个数（此时 +0 和 -0 分别为两个不同的数）。\n\n数值范围是 $\\[\\-\\(\\{2}^{n-1} - 1\\)\\,\\{2}^{n-1} - 1\\]$。\n\n\n## 2. 反码\n\n反码表示法规定，正数的反码等于其原码，而负数的反码是对原码的数值位按位取反，并保留其符号位。\n\n例如，对二进制原码 10001010 求反码：\n\n```\n10001010(原码) = 11110101(反码)\n```\n\n在多数计算机中不采用反码表示数值。\n\n\n\n## 3. 补码\n\n在了解补码之前，先来看下，如果使用原码直接参与加减法运算会得到什么结果：\n\n```\n00000010 + 00000010 = 00000100，即 2 + 2 = 4，结果正确\n00000010 + 10000010 = 10000100，即 2 + (-2) = -4，结果错误\n```\n\n可见原码的符号位不能直接参与运算，必须与其他位分开，这就增加了硬件的开销和复杂性。\n\n### 3.1 补码的定义\n\n正数和 0 的补码就是该数字本身，而负数的补码是对原码的数值位按位取反再加 1。\n\n\n\n### 3.2 补码的运算\n\n补码的符号位可以直接参与运算，例如：\n\n```\n  (0000) 0000 0010 (2D)\n+ (0000) 1111 1110 (-2D)\n------------------------\n  (0001) 0000 0000 (0D)\n\n结果正确\n```\n\n```\n  (0000) 0000 0010 (2D)\n+ (0000) 1111 1111 (-1D)\n------------------------\n  (0001) 0000 0001 (1D)\n\n结果正确\n```\n\n```\n  (0000) 0000 0010 (2D)\n+ (0000) 1111 1101 (-3D)\n------------------------\n  (0000) 1111 1111 (-1D)\n\n结果正确\n```\n\n\n\n### 3.3 补码的数值范围\n\n在原码系统中，0 有两种表示方式（以 32 位的整数类型为例）：\n\n```\n正零：0000 0000 0000 0000 0000 0000 0000 0000\n\n负零：1000 0000 0000 0000 0000 0000 0000 0000\n```\n\n按照负数补码的计算方法，对负零原码的数值位按位取反再加 1，可得：\n\n```\n(0001) 0000 0000 0000 0000 0000 0000 0000 0000\n```\n\n由于溢出，可知正零和负零的补码是相同的，没必要区分正零和负零。\n\n**所以，在补码系统中，0只有一种表示方式。**\n\n\n\n因此，在32位的整数类型中，多出了一个数：\n\n```\n1000 0000 0000 0000 0000 0000 0000 0000\n```\n\n同时，在补码系统中，我们知道符号位可以直接参与运算：\n\n```\n  (0000) 1000 0000 0000 0000 0000 0000 0000 0001 (-2147483647D)\n+ (0000) 1111 1111 1111 1111 1111 1111 1111 1111 (-1D)\n---------------------------------------------------------------\n  (0001) 1000 0000 0000 0000 0000 0000 0000 0000 (-2147483648D)\n```\n于是，在补码系统中，$1$$\\underbrace{ 00\\cdots00 }_{n-1}$ 就表示了 n 位整数类型的最小值。\n\n**一个 n 位的补码，可以表示 $2^n$ 个数，其数值范围是 $\\[\\{-2}^{n-1}\\,\\{2}^{n-1} - 1\\]$。**\n\n> 参考：\n>\n> https://en.wikipedia.org/wiki/Signed_number_representations\n>\n> https://zh.wikipedia.org/wiki/%E6%9C%89%E7%AC%A6%E8%99%9F%E6%95%B8%E8%99%95%E7%90%86\n","slug":"signed-number-representations","published":1,"updated":"2021-03-26T13:24:39.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmsyc4r900045nprbgj32va1","content":"<p>计算机中符号数常用的表示方法：</p>\n<ul>\n<li>原码</li>\n<li>反码</li>\n<li>补码</li>\n</ul>\n<p>这三种表示方法均有符号位和数值位两部分，符号位都是用 0 表示 “+”，用 1 表示 “-“。而数值位，三种表示方法各不相同。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"1-原码\"><a href=\"#1-原码\" class=\"headerlink\" title=\"1. 原码\"></a>1. 原码</h2><p>原码是指一个二进制数左边加上符号位后所得到的码，即最高位为符号位。</p>\n<ul>\n<li><p>当二进制数大于 0 时，符号位为 0</p>\n</li>\n<li><p>当二进制数小于 0 时，符号位为 1</p>\n</li>\n<li><p>当二进制数等于 +0 时，符号位为 0</p>\n</li>\n<li><p>当二进制数等于 -0 时，符号位为 1</p>\n</li>\n</ul>\n<p>例如，用 8 位二进制表示一个数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+10D &#x3D; 00001010B</span><br><span class=\"line\"></span><br><span class=\"line\">-10D &#x3D; 10001010B</span><br><span class=\"line\"></span><br><span class=\"line\">+127D &#x3D; 01111111B</span><br></pre></td></tr></table></figure>\n\n\n<p>一个 n 位的原码，可以表示 ${2}^n$ 个数（此时 +0 和 -0 分别为两个不同的数）。</p>\n<p>数值范围是 $[-({2}^{n-1} - 1),{2}^{n-1} - 1]$。</p>\n<h2 id=\"2-反码\"><a href=\"#2-反码\" class=\"headerlink\" title=\"2. 反码\"></a>2. 反码</h2><p>反码表示法规定，正数的反码等于其原码，而负数的反码是对原码的数值位按位取反，并保留其符号位。</p>\n<p>例如，对二进制原码 10001010 求反码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10001010(原码) &#x3D; 11110101(反码)</span><br></pre></td></tr></table></figure>\n<p>在多数计算机中不采用反码表示数值。</p>\n<h2 id=\"3-补码\"><a href=\"#3-补码\" class=\"headerlink\" title=\"3. 补码\"></a>3. 补码</h2><p>在了解补码之前，先来看下，如果使用原码直接参与加减法运算会得到什么结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000010 + 00000010 &#x3D; 00000100，即 2 + 2 &#x3D; 4，结果正确</span><br><span class=\"line\">00000010 + 10000010 &#x3D; 10000100，即 2 + (-2) &#x3D; -4，结果错误</span><br></pre></td></tr></table></figure>\n<p>可见原码的符号位不能直接参与运算，必须与其他位分开，这就增加了硬件的开销和复杂性。</p>\n<h3 id=\"3-1-补码的定义\"><a href=\"#3-1-补码的定义\" class=\"headerlink\" title=\"3.1 补码的定义\"></a>3.1 补码的定义</h3><p>正数和 0 的补码就是该数字本身，而负数的补码是对原码的数值位按位取反再加 1。</p>\n<h3 id=\"3-2-补码的运算\"><a href=\"#3-2-补码的运算\" class=\"headerlink\" title=\"3.2 补码的运算\"></a>3.2 补码的运算</h3><p>补码的符号位可以直接参与运算，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  (0000) 0000 0010 (2D)</span><br><span class=\"line\">+ (0000) 1111 1110 (-2D)</span><br><span class=\"line\">------------------------</span><br><span class=\"line\">  (0001) 0000 0000 (0D)</span><br><span class=\"line\"></span><br><span class=\"line\">结果正确</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  (0000) 0000 0010 (2D)</span><br><span class=\"line\">+ (0000) 1111 1111 (-1D)</span><br><span class=\"line\">------------------------</span><br><span class=\"line\">  (0001) 0000 0001 (1D)</span><br><span class=\"line\"></span><br><span class=\"line\">结果正确</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  (0000) 0000 0010 (2D)</span><br><span class=\"line\">+ (0000) 1111 1101 (-3D)</span><br><span class=\"line\">------------------------</span><br><span class=\"line\">  (0000) 1111 1111 (-1D)</span><br><span class=\"line\"></span><br><span class=\"line\">结果正确</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"3-3-补码的数值范围\"><a href=\"#3-3-补码的数值范围\" class=\"headerlink\" title=\"3.3 补码的数值范围\"></a>3.3 补码的数值范围</h3><p>在原码系统中，0 有两种表示方式（以 32 位的整数类型为例）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">正零：0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class=\"line\"></span><br><span class=\"line\">负零：1000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>\n<p>按照负数补码的计算方法，对负零原码的数值位按位取反再加 1，可得：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(0001) 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>\n<p>由于溢出，可知正零和负零的补码是相同的，没必要区分正零和负零。</p>\n<p><strong>所以，在补码系统中，0只有一种表示方式。</strong></p>\n<p>因此，在32位的整数类型中，多出了一个数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>\n<p>同时，在补码系统中，我们知道符号位可以直接参与运算：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  (0000) 1000 0000 0000 0000 0000 0000 0000 0001 (-2147483647D)</span><br><span class=\"line\">+ (0000) 1111 1111 1111 1111 1111 1111 1111 1111 (-1D)</span><br><span class=\"line\">---------------------------------------------------------------</span><br><span class=\"line\">  (0001) 1000 0000 0000 0000 0000 0000 0000 0000 (-2147483648D)</span><br></pre></td></tr></table></figure>\n<p>于是，在补码系统中，$1$$\\underbrace{ 00\\cdots00 }_{n-1}$ 就表示了 n 位整数类型的最小值。</p>\n<p><strong>一个 n 位的补码，可以表示 $2^n$ 个数，其数值范围是 $[{-2}^{n-1},{2}^{n-1} - 1]$。</strong></p>\n<blockquote>\n<p>参考：</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Signed_number_representations\">https://en.wikipedia.org/wiki/Signed_number_representations</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%89%E7%AC%A6%E8%99%9F%E6%95%B8%E8%99%95%E7%90%86\">https://zh.wikipedia.org/wiki/%E6%9C%89%E7%AC%A6%E8%99%9F%E6%95%B8%E8%99%95%E7%90%86</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>计算机中符号数常用的表示方法：</p>\n<ul>\n<li>原码</li>\n<li>反码</li>\n<li>补码</li>\n</ul>\n<p>这三种表示方法均有符号位和数值位两部分，符号位都是用 0 表示 “+”，用 1 表示 “-“。而数值位，三种表示方法各不相同。</p>","more":"<h2 id=\"1-原码\"><a href=\"#1-原码\" class=\"headerlink\" title=\"1. 原码\"></a>1. 原码</h2><p>原码是指一个二进制数左边加上符号位后所得到的码，即最高位为符号位。</p>\n<ul>\n<li><p>当二进制数大于 0 时，符号位为 0</p>\n</li>\n<li><p>当二进制数小于 0 时，符号位为 1</p>\n</li>\n<li><p>当二进制数等于 +0 时，符号位为 0</p>\n</li>\n<li><p>当二进制数等于 -0 时，符号位为 1</p>\n</li>\n</ul>\n<p>例如，用 8 位二进制表示一个数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+10D &#x3D; 00001010B</span><br><span class=\"line\"></span><br><span class=\"line\">-10D &#x3D; 10001010B</span><br><span class=\"line\"></span><br><span class=\"line\">+127D &#x3D; 01111111B</span><br></pre></td></tr></table></figure>\n\n\n<p>一个 n 位的原码，可以表示 ${2}^n$ 个数（此时 +0 和 -0 分别为两个不同的数）。</p>\n<p>数值范围是 $[-({2}^{n-1} - 1),{2}^{n-1} - 1]$。</p>\n<h2 id=\"2-反码\"><a href=\"#2-反码\" class=\"headerlink\" title=\"2. 反码\"></a>2. 反码</h2><p>反码表示法规定，正数的反码等于其原码，而负数的反码是对原码的数值位按位取反，并保留其符号位。</p>\n<p>例如，对二进制原码 10001010 求反码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10001010(原码) &#x3D; 11110101(反码)</span><br></pre></td></tr></table></figure>\n<p>在多数计算机中不采用反码表示数值。</p>\n<h2 id=\"3-补码\"><a href=\"#3-补码\" class=\"headerlink\" title=\"3. 补码\"></a>3. 补码</h2><p>在了解补码之前，先来看下，如果使用原码直接参与加减法运算会得到什么结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000010 + 00000010 &#x3D; 00000100，即 2 + 2 &#x3D; 4，结果正确</span><br><span class=\"line\">00000010 + 10000010 &#x3D; 10000100，即 2 + (-2) &#x3D; -4，结果错误</span><br></pre></td></tr></table></figure>\n<p>可见原码的符号位不能直接参与运算，必须与其他位分开，这就增加了硬件的开销和复杂性。</p>\n<h3 id=\"3-1-补码的定义\"><a href=\"#3-1-补码的定义\" class=\"headerlink\" title=\"3.1 补码的定义\"></a>3.1 补码的定义</h3><p>正数和 0 的补码就是该数字本身，而负数的补码是对原码的数值位按位取反再加 1。</p>\n<h3 id=\"3-2-补码的运算\"><a href=\"#3-2-补码的运算\" class=\"headerlink\" title=\"3.2 补码的运算\"></a>3.2 补码的运算</h3><p>补码的符号位可以直接参与运算，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  (0000) 0000 0010 (2D)</span><br><span class=\"line\">+ (0000) 1111 1110 (-2D)</span><br><span class=\"line\">------------------------</span><br><span class=\"line\">  (0001) 0000 0000 (0D)</span><br><span class=\"line\"></span><br><span class=\"line\">结果正确</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  (0000) 0000 0010 (2D)</span><br><span class=\"line\">+ (0000) 1111 1111 (-1D)</span><br><span class=\"line\">------------------------</span><br><span class=\"line\">  (0001) 0000 0001 (1D)</span><br><span class=\"line\"></span><br><span class=\"line\">结果正确</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  (0000) 0000 0010 (2D)</span><br><span class=\"line\">+ (0000) 1111 1101 (-3D)</span><br><span class=\"line\">------------------------</span><br><span class=\"line\">  (0000) 1111 1111 (-1D)</span><br><span class=\"line\"></span><br><span class=\"line\">结果正确</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"3-3-补码的数值范围\"><a href=\"#3-3-补码的数值范围\" class=\"headerlink\" title=\"3.3 补码的数值范围\"></a>3.3 补码的数值范围</h3><p>在原码系统中，0 有两种表示方式（以 32 位的整数类型为例）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">正零：0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class=\"line\"></span><br><span class=\"line\">负零：1000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>\n<p>按照负数补码的计算方法，对负零原码的数值位按位取反再加 1，可得：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(0001) 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>\n<p>由于溢出，可知正零和负零的补码是相同的，没必要区分正零和负零。</p>\n<p><strong>所以，在补码系统中，0只有一种表示方式。</strong></p>\n<p>因此，在32位的整数类型中，多出了一个数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>\n<p>同时，在补码系统中，我们知道符号位可以直接参与运算：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  (0000) 1000 0000 0000 0000 0000 0000 0000 0001 (-2147483647D)</span><br><span class=\"line\">+ (0000) 1111 1111 1111 1111 1111 1111 1111 1111 (-1D)</span><br><span class=\"line\">---------------------------------------------------------------</span><br><span class=\"line\">  (0001) 1000 0000 0000 0000 0000 0000 0000 0000 (-2147483648D)</span><br></pre></td></tr></table></figure>\n<p>于是，在补码系统中，$1$$\\underbrace{ 00\\cdots00 }_{n-1}$ 就表示了 n 位整数类型的最小值。</p>\n<p><strong>一个 n 位的补码，可以表示 $2^n$ 个数，其数值范围是 $[{-2}^{n-1},{2}^{n-1} - 1]$。</strong></p>\n<blockquote>\n<p>参考：</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Signed_number_representations\">https://en.wikipedia.org/wiki/Signed_number_representations</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%89%E7%AC%A6%E8%99%9F%E6%95%B8%E8%99%95%E7%90%86\">https://zh.wikipedia.org/wiki/%E6%9C%89%E7%AC%A6%E8%99%9F%E6%95%B8%E8%99%95%E7%90%86</a></p>\n</blockquote>"},{"title":"基本初等函数","date":"2021-03-10T07:54:36.000Z","mathjax":true,"_content":"\n**高等数学**将基本初等函数归为五类：幂函数、指数函数、对数函数、三角函数、反三角函数。\n**数学分析**将基本初等函数归为六类：常函数、幂函数、指数函数、对数函数、三角函数、反三角函数。\n接下来将按照**数学分析**的分类，逐一介绍这些函数。\n\n\n\n<!-- more -->\n\n# 1. 基本初等函数\n\n## 1.1 常函数\n\n常函数是指不管自变量值如何变化，函数值都不变的函数。\n\n形式为 $f(x)=C$，其中 $C$ 为常数，定义域为$(-\\infty,+\\infty)$。\n\n### 1.1.1 图像\n\n{% asset_img constant-function-example-1.png 300 300 %}\n\n$$f(x)=1$$\n\n\n\n## 1.2 幂函数\n\n幂函数是以底数为自变量，幂为因变量，指数为常数的函数。\n\n形式为 $f(x)=x^α$（$a$ 可以是任意实数或者复数）。\n\n### 1.2.1 有理数指数幂\n\n当指数 $a$ 是有理数时，幂函数可以写作如下形式：\n\n$f(x)=x^{k\\frac{m}{n}}(k\\in\\lbrace-1,1,0\\rbrace,m,n\\in{N}^{*})$\n\n|       |  定义域   |  值域   | 奇偶性 | 图像 |\n| :---: | :----: | :----: | :----: | ------ |\n| $k=1,m,n$ 均为奇数 | $R$ | $R$ | 奇函数 | {% asset_img power-function-example-1.png 300 300 %} $$red:f(x)=x^\\frac{1}{3}$$$$blue:f(x)=x^{3}$$ |\n| $k=-1,m,n$ 均为奇数 | $(-\\infty,0)\\cup(0,+\\infty)$ | $(-\\infty,0)\\cup(0,+\\infty)$ | 奇函数 | {% asset_img power-function-example-2.png 300 300 %} $$red:f(x)=x^{-\\frac{1}{3}}$$$$blue:f(x)=x^{-3}$$ |\n| $k=1,m$ 为奇数$,n$ 为偶数 | $[0,+\\infty)$ | $[0,+\\infty)$ | 非奇非偶函数 | {% asset_img power-function-example-3.png 300 300 %} $$red:f(x)=x^{\\frac{3}{2}}$$$$blue:f(x)=x^{\\frac{1}{2}}$$$$green:f(x)=x^{\\frac{5}{2}}$$ |\n| $k=-1,m$ 为奇数$,n$ 为偶数 | $(0,+\\infty)$ | $(0,+\\infty)$ | 非奇非偶函数 | {% asset_img power-function-example-4.png 300 300 %} $$red:f(x)=x^{-\\frac{3}{2}}$$$$blue:f(x)=x^{-\\frac{1}{2}}$$$$green:f(x)=x^{-\\frac{5}{2}}$$ |\n| $k=1,m$ 为偶数$,n$ 为奇数 | $R$ | $[0,+\\infty)$ | 偶函数 | {% asset_img power-function-example-5.png 300 300 %} $$red:f(x)=x^{\\frac{4}{3}}$$$$blue:f(x)=x^{\\frac{2}{3}}$$$$green:f(x)=x^{2}$$ |\n| $k=-1,m$ 为偶数$,n$ 为奇数 | $(-\\infty,0)\\cup(0,+\\infty)$ | $(0,+\\infty)$ | 偶函数 | {% asset_img power-function-example-6.png 300 300 %} $$red:f(x)=x^{-\\frac{4}{3}}$$$$blue:f(x)=x^{-\\frac{2}{3}}$$$$green:f(x)=x^{-2}$$ |\n| $k=0$ | $(-\\infty,0)\\cup(0,+\\infty)$ | $\\lbrace1\\rbrace$ | 偶函数 | {% asset_img power-function-example-7.png 300 300 %} $$red:f(x)=x^{0}$$注意，$f(x)=x^{0}$ 的图像并不是直线，而是直线 $y=1$ 去掉一点 $(0,1)$ |\n\n\n\n## 1.3 指数函数\n\n一般地，指数函数的形式为 $f(x)=b^x$（$b$ 为常数且 $b\\in(0,1)\\cup(1,+\\infty)$），函数的定义域为 $R$，值域为 $(0,+\\infty)$。\n\n注意，在指数函数的定义表达式中，在 $b^x$ 前的系数必须为 $1$，自变量 $x$ 必须在指数的位置上，且不能为 $x$ 的其他表达式，否则，就不是指数函数。\n\n### 1.3.1 图像\n|       |  值域   | 图像 |\n| :---: | :----: | ------ |\n| $0<b<1$ | $(0,+\\infty)$ | {% asset_img exponential-function-example-1.png 300 300 %} $$red:f(x)=\\frac{1}{2}^x$$$$blue:f(x)=\\frac{1}{4}^x$$ |\n| $b>1$ | $(0,+\\infty)$ | {% asset_img exponential-function-example-2.png 300 300 %} $$red:f(x)=2^x$$$$blue:f(x)=4^x$$ |\n\n### 1.3.2 性质\n\n#### 1.3.2.1 性质 1\n\n由指数函数的定义：\n\n​\t$e^x=\\lim_{n \\to \\infty}(1+\\frac{x}{n})^{n}$\n\n可以得出以下定律：\n\n​\t$e^0=1$\n\n​\t$e^1=e$\n\n​\t$e^{x+y}=e^xe^y$\n\n​\t$e^{xy}=(e^x)^y$\n\n​\t$\\frac{e^x}{e^y}=e^{x-y}$\n\n​\t$e^{-x}=e^{0-x}=\\frac{e^0}{e^x}=\\frac{1}{e^x}$\n\n其中 $x\\in{R},y\\in{R}$。\n\n\n\n#### 1.3.2.2 性质 2\n\n因为在指数函数的定义中 $x$ 是实数，可以使用自然对数 $e$，把更一般的指数函数，即正实数的实数幂函数定义为\n\n$b^x=(e^{\\ln{b}})^x=e^{x\\ln{b}}$\n\n\n\n#### 1.3.2.3 性质 3\n\n定义于所有的 $b>0$，和所有的实数 $x$。它叫做\"底数为 $b$ 的指数函数\"。从而拓展了通过乘方和方根运算定义的正实数的有理数幂函数：\n\n$b^{\\frac{m}{n}=\\sqrt[n]{b^m}}$\n\n而方根运算可通过自然对数和指数函数来表示：\n\n$\\sqrt[n]{b}=b^{\\frac{1}{n}}=(e^{\\ln{b}})^{\\frac{1}{n}}=e^{\\frac{\\ln{b}}{n}}$\n\n\n\n## 1.4 对数函数\n\n对数是幂运算的逆运算。\n\n如果 $b^x=N(b>0,且b\\neq1)$，那么 $x$ 叫做以 $b$ 为底 $N$ 的对数，记作 $x=\\log_{b}{N}$，读作以 $b$ 为底 $N$ 的对数，其中 $b$ 叫做对数的底，$N$ 叫做幂或者真数。\n\n一般地，对数函数的形式为 $f(x)=\\log_{b}{x}(b>0,且b\\neq1)$，函数的定义域为 $(0,+\\infty)$，值域为 $R$ 。\n\n对数函数实际上就是指数函数的反函数，可表示为 $x=b^y$。因此指数函数里对于常数 $b$ 的规定，同样适用于对数函数。\n\n### 1.4.1 图像\n|       |  值域   | 图像 |\n| :---: | :----: | ------ |\n| $0<b<1$ | $R$ | {% asset_img logarithmic-function-example-1.png 300 300 %} $$red:f(x)=\\log_{\\frac{1}{2}}{x}$$$$blue:f(x)=\\log_{\\frac{1}{4}}{x}$$ |\n| $b>1$ | $R$ | {% asset_img logarithmic-function-example-2.png 300 300 %} $$red:f(x)=\\log_{2}{x}$$$$blue:f(x)=\\log_{4}{x}$$ |\n\n### 1.4.2 性质\n\n- 对数函数的函数图像恒定过点$(1,0)$\n\n- 当 $0<b<1$ 时，函数在定义域 $(0,+\\infty)$ 上为单调减函数；$b>1$ 时，函数在定义域 $(0,+\\infty)$ 上为单调增函数\n\n- 对数函数 $f(x)=\\log_{b}{x}(b>0,b\\neq1,x>0)$\n\n  当 $0<b<1,0<x<1$ 时，$f(x)=\\log_{b}{x}>0$\n  \n  当 $b>1, x>1$ 时，$f(x)=\\log_{b}{x}>0$\n  \n  当 $0<b<1, x>1$ 时，$f(x)=\\log_{b}{x}<0$\n  \n  当 $b>1, 0<x<1$ 时，$f(x)=\\log_{b}{x}<0$\n  \n- 底数为 $b$ 的对数函数$f(x)=\\log_{b}{x}与$指数函数 $f(x)=b^x$ 互为反函数，两者的函数图像关于直线 $y = x$ 对称。\n\n{% asset_img logarithmic-function-example-3.png 300 300 %} $$red:f(x)=\\log_{2}{x}$$$$blue:f(x)=2^{x}$$$$green:f(x)=\\log_{\\frac{1}{2}}{x}$$$$blue:f(x)={\\frac{1}{2}}^{x}$$\n\n### 1.4.3 公式\n\n#### 1.4.3.1 换底公式\n\n$\\log_{b}{x}=\\frac{\\log_{k}{x}}{\\log_{k}{b}}$\n\n##### 1.4.3.1.1 证明\n\n由对数函数的定义，可得：\n\n$x=b^{\\log_{b}{x}}$\n\n等式两边同时以 $k$ 为底取对数，可得：\n\n$\\log_{k}{x}=\\log_{k}({b^{\\log_{b}{x}})}$\n\n$\\because b^x=N(b>0,且b\\neq1)$，有 $x=\\log_{b}{N}$。\n\n那么 $(b^x)^t=b^{xt}=N^t\\ (t\\in{R})$，可得：\n\n$xt=\\log_{b}{N^t}=t\\log_{b}{N}\\ (t\\in{R})$\n\n$\\therefore\\log_{k}{x}=\\log_{k}{b^{\\log_{b}{x}}}=\\log_{b}{x}\\log_{k}{b}$\n\n$\\log_{b}{x}=\\frac{\\log_{k}{x}}{\\log_{k}{b}}$ 得证。\n\n\n\n#### 1.4.3.2 和差\n\n$\\log_{b}{MN}=\\log_{b}{M}+\\log_{b}{N}$\n\n$\\log_{b}{\\frac{M}{N}}=\\log_{b}{M}-\\log_{b}{N}$\n\n##### 1.4.3.2.1 证明\n\n设 $M=\\beta^{m},N=\\beta^{n}$\n\n则 $\\log_{b}{MN}=\\log_{b}({\\beta^{m}\\beta^{n}})$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}({\\beta^{m+n}})$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =(m+n)\\log_{b}{\\beta}$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =m\\log_{b}{\\beta}+n\\log_{b}{\\beta}$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{\\beta^m}+\\log_{b}{\\beta^n}$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{M}+\\log_{b}{N}$\n\n$\\log_{b}{\\frac{M}{N}}=\\log_{b}{M}+\\log_{b}{\\frac{1}{N}}$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{M}+\\log_{b}{N^{-1}}$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{M}-\\log_{b}{N}$\n\n\n\n#### 1.4.3.3 次方公式\n\n$\\log_{b^N}({x^M})=\\frac{M}{N}\\log_{b}{x}$\n\n##### 1.4.3.3.1 证明\n\n由换底公式，可得：\n\n$\\log_{b^N}({x^M})=\\frac{\\ln{b^N}}{\\ln{x^M}}$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\frac{N\\ln{b}}{M\\ln{x}}$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\frac{M}{N}\\log_{b}{x}$\n\n##### \n\n#### 1.4.3.4 还原\n\n$b^{\\log_{b}{x}}=x$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{b^x}$\n\n\n\n#### 1.4.3.5 互换\n\n$M^{\\log_{b}{N}} = N^{\\log_{b}{M}}$\n\n##### 1.4.3.5.1 证明\n\n设 $\\alpha=\\log_{b}{N},\\  \\beta=\\log_{b}{M}$，则有 $b^\\alpha=N,\\ b^\\beta=M, \\ (b^\\beta)^\\alpha=(b^\\alpha)^\\beta$，\n\n$\\therefore M^{\\log_{b}{N}} = N^{\\log_{b}{M}}$\n\n\n\n#### 1.4.3.6 倒数\n\n$\\log_{b}{\\theta}=\\frac{\\ln \\theta}{\\ln b}=\\frac{1}{\\frac{\\ln b}{\\ln \\theta}}=\\frac{1}{\\log_{\\theta}{b}}$\n\n\n\n## 1.5 三角函数\n\n<!--TODO-->\n\n\n\n## 1.6 反三角函数\n\n<!--TODO-->\n\n\n\n# 2. 初等函数\n\n初等函数是由**基本初等函数**经过有限次的有理运算（加、减、乘、除、有理数次乘方、有理数次开方）及有限次函数复合所产生、并且在定义域上能用一个解析式表示的函数。\n\n基本初等函数和初等函数在其定义区间内均为**连续函数**。\n\n一般来说，分段函数不是初等函数，因为在这些分段函数的定义域上不能用一个解析式表示。\n\n\n\n\n> 参考：\n>\n> https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0\n>\n> https://zh.wikipedia.org/wiki/%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0\n\n\n<style>\n  table {\n    width: 1100px; /*表格宽度*/\n    max-width: 1100px; /*表格最大宽度，避免表格过宽*/\n    border: 1px solid #dedede; /*表格外边框设置*/\n    margin: 1px auto; /*外边距*/\n    border-collapse: collapse; /*使用单一线条的边框*/\n    empty-cells: show; /*单元格无内容依旧绘制边框*/\n  }\n  table th,\n  table td {\n    height: 35px; /*统一每一行的默认高度*/\n    border: 1px solid #dedede; /*内部边框样式*/\n    padding: 0 10px; /*内边距*/\n  }\n  table th {\n    font-weight: bold; /*加粗*/\n    text-align: center !important; /*内容居中，加上 !important 避免被 Markdown 样式覆盖*/\n    background: #F8F8F8; /*背景色*/\n  }\n  table tbody tr:nth-child(n) {\n    background: #FFFFFF; \n  }\n  table tr:hover {\n    background: #EFEFEF; \n}\n  table th {\n    white-space: nowrap; /*表头内容强制在一行显示*/\n  }\n  table td:nth-child(1) {\n    white-space: nowrap; /*表格第一列单元格内容不换行*/\n  }\n</style>\n","source":"_posts/2021-03-10-elementary-function.md","raw":"---\ntitle: 基本初等函数\ndate: 2021-03-10 15:54:36\ncategories:\n- Mathematics\nmathjax: true\n---\n\n**高等数学**将基本初等函数归为五类：幂函数、指数函数、对数函数、三角函数、反三角函数。\n**数学分析**将基本初等函数归为六类：常函数、幂函数、指数函数、对数函数、三角函数、反三角函数。\n接下来将按照**数学分析**的分类，逐一介绍这些函数。\n\n\n\n<!-- more -->\n\n# 1. 基本初等函数\n\n## 1.1 常函数\n\n常函数是指不管自变量值如何变化，函数值都不变的函数。\n\n形式为 $f(x)=C$，其中 $C$ 为常数，定义域为$(-\\infty,+\\infty)$。\n\n### 1.1.1 图像\n\n{% asset_img constant-function-example-1.png 300 300 %}\n\n$$f(x)=1$$\n\n\n\n## 1.2 幂函数\n\n幂函数是以底数为自变量，幂为因变量，指数为常数的函数。\n\n形式为 $f(x)=x^α$（$a$ 可以是任意实数或者复数）。\n\n### 1.2.1 有理数指数幂\n\n当指数 $a$ 是有理数时，幂函数可以写作如下形式：\n\n$f(x)=x^{k\\frac{m}{n}}(k\\in\\lbrace-1,1,0\\rbrace,m,n\\in{N}^{*})$\n\n|       |  定义域   |  值域   | 奇偶性 | 图像 |\n| :---: | :----: | :----: | :----: | ------ |\n| $k=1,m,n$ 均为奇数 | $R$ | $R$ | 奇函数 | {% asset_img power-function-example-1.png 300 300 %} $$red:f(x)=x^\\frac{1}{3}$$$$blue:f(x)=x^{3}$$ |\n| $k=-1,m,n$ 均为奇数 | $(-\\infty,0)\\cup(0,+\\infty)$ | $(-\\infty,0)\\cup(0,+\\infty)$ | 奇函数 | {% asset_img power-function-example-2.png 300 300 %} $$red:f(x)=x^{-\\frac{1}{3}}$$$$blue:f(x)=x^{-3}$$ |\n| $k=1,m$ 为奇数$,n$ 为偶数 | $[0,+\\infty)$ | $[0,+\\infty)$ | 非奇非偶函数 | {% asset_img power-function-example-3.png 300 300 %} $$red:f(x)=x^{\\frac{3}{2}}$$$$blue:f(x)=x^{\\frac{1}{2}}$$$$green:f(x)=x^{\\frac{5}{2}}$$ |\n| $k=-1,m$ 为奇数$,n$ 为偶数 | $(0,+\\infty)$ | $(0,+\\infty)$ | 非奇非偶函数 | {% asset_img power-function-example-4.png 300 300 %} $$red:f(x)=x^{-\\frac{3}{2}}$$$$blue:f(x)=x^{-\\frac{1}{2}}$$$$green:f(x)=x^{-\\frac{5}{2}}$$ |\n| $k=1,m$ 为偶数$,n$ 为奇数 | $R$ | $[0,+\\infty)$ | 偶函数 | {% asset_img power-function-example-5.png 300 300 %} $$red:f(x)=x^{\\frac{4}{3}}$$$$blue:f(x)=x^{\\frac{2}{3}}$$$$green:f(x)=x^{2}$$ |\n| $k=-1,m$ 为偶数$,n$ 为奇数 | $(-\\infty,0)\\cup(0,+\\infty)$ | $(0,+\\infty)$ | 偶函数 | {% asset_img power-function-example-6.png 300 300 %} $$red:f(x)=x^{-\\frac{4}{3}}$$$$blue:f(x)=x^{-\\frac{2}{3}}$$$$green:f(x)=x^{-2}$$ |\n| $k=0$ | $(-\\infty,0)\\cup(0,+\\infty)$ | $\\lbrace1\\rbrace$ | 偶函数 | {% asset_img power-function-example-7.png 300 300 %} $$red:f(x)=x^{0}$$注意，$f(x)=x^{0}$ 的图像并不是直线，而是直线 $y=1$ 去掉一点 $(0,1)$ |\n\n\n\n## 1.3 指数函数\n\n一般地，指数函数的形式为 $f(x)=b^x$（$b$ 为常数且 $b\\in(0,1)\\cup(1,+\\infty)$），函数的定义域为 $R$，值域为 $(0,+\\infty)$。\n\n注意，在指数函数的定义表达式中，在 $b^x$ 前的系数必须为 $1$，自变量 $x$ 必须在指数的位置上，且不能为 $x$ 的其他表达式，否则，就不是指数函数。\n\n### 1.3.1 图像\n|       |  值域   | 图像 |\n| :---: | :----: | ------ |\n| $0<b<1$ | $(0,+\\infty)$ | {% asset_img exponential-function-example-1.png 300 300 %} $$red:f(x)=\\frac{1}{2}^x$$$$blue:f(x)=\\frac{1}{4}^x$$ |\n| $b>1$ | $(0,+\\infty)$ | {% asset_img exponential-function-example-2.png 300 300 %} $$red:f(x)=2^x$$$$blue:f(x)=4^x$$ |\n\n### 1.3.2 性质\n\n#### 1.3.2.1 性质 1\n\n由指数函数的定义：\n\n​\t$e^x=\\lim_{n \\to \\infty}(1+\\frac{x}{n})^{n}$\n\n可以得出以下定律：\n\n​\t$e^0=1$\n\n​\t$e^1=e$\n\n​\t$e^{x+y}=e^xe^y$\n\n​\t$e^{xy}=(e^x)^y$\n\n​\t$\\frac{e^x}{e^y}=e^{x-y}$\n\n​\t$e^{-x}=e^{0-x}=\\frac{e^0}{e^x}=\\frac{1}{e^x}$\n\n其中 $x\\in{R},y\\in{R}$。\n\n\n\n#### 1.3.2.2 性质 2\n\n因为在指数函数的定义中 $x$ 是实数，可以使用自然对数 $e$，把更一般的指数函数，即正实数的实数幂函数定义为\n\n$b^x=(e^{\\ln{b}})^x=e^{x\\ln{b}}$\n\n\n\n#### 1.3.2.3 性质 3\n\n定义于所有的 $b>0$，和所有的实数 $x$。它叫做\"底数为 $b$ 的指数函数\"。从而拓展了通过乘方和方根运算定义的正实数的有理数幂函数：\n\n$b^{\\frac{m}{n}=\\sqrt[n]{b^m}}$\n\n而方根运算可通过自然对数和指数函数来表示：\n\n$\\sqrt[n]{b}=b^{\\frac{1}{n}}=(e^{\\ln{b}})^{\\frac{1}{n}}=e^{\\frac{\\ln{b}}{n}}$\n\n\n\n## 1.4 对数函数\n\n对数是幂运算的逆运算。\n\n如果 $b^x=N(b>0,且b\\neq1)$，那么 $x$ 叫做以 $b$ 为底 $N$ 的对数，记作 $x=\\log_{b}{N}$，读作以 $b$ 为底 $N$ 的对数，其中 $b$ 叫做对数的底，$N$ 叫做幂或者真数。\n\n一般地，对数函数的形式为 $f(x)=\\log_{b}{x}(b>0,且b\\neq1)$，函数的定义域为 $(0,+\\infty)$，值域为 $R$ 。\n\n对数函数实际上就是指数函数的反函数，可表示为 $x=b^y$。因此指数函数里对于常数 $b$ 的规定，同样适用于对数函数。\n\n### 1.4.1 图像\n|       |  值域   | 图像 |\n| :---: | :----: | ------ |\n| $0<b<1$ | $R$ | {% asset_img logarithmic-function-example-1.png 300 300 %} $$red:f(x)=\\log_{\\frac{1}{2}}{x}$$$$blue:f(x)=\\log_{\\frac{1}{4}}{x}$$ |\n| $b>1$ | $R$ | {% asset_img logarithmic-function-example-2.png 300 300 %} $$red:f(x)=\\log_{2}{x}$$$$blue:f(x)=\\log_{4}{x}$$ |\n\n### 1.4.2 性质\n\n- 对数函数的函数图像恒定过点$(1,0)$\n\n- 当 $0<b<1$ 时，函数在定义域 $(0,+\\infty)$ 上为单调减函数；$b>1$ 时，函数在定义域 $(0,+\\infty)$ 上为单调增函数\n\n- 对数函数 $f(x)=\\log_{b}{x}(b>0,b\\neq1,x>0)$\n\n  当 $0<b<1,0<x<1$ 时，$f(x)=\\log_{b}{x}>0$\n  \n  当 $b>1, x>1$ 时，$f(x)=\\log_{b}{x}>0$\n  \n  当 $0<b<1, x>1$ 时，$f(x)=\\log_{b}{x}<0$\n  \n  当 $b>1, 0<x<1$ 时，$f(x)=\\log_{b}{x}<0$\n  \n- 底数为 $b$ 的对数函数$f(x)=\\log_{b}{x}与$指数函数 $f(x)=b^x$ 互为反函数，两者的函数图像关于直线 $y = x$ 对称。\n\n{% asset_img logarithmic-function-example-3.png 300 300 %} $$red:f(x)=\\log_{2}{x}$$$$blue:f(x)=2^{x}$$$$green:f(x)=\\log_{\\frac{1}{2}}{x}$$$$blue:f(x)={\\frac{1}{2}}^{x}$$\n\n### 1.4.3 公式\n\n#### 1.4.3.1 换底公式\n\n$\\log_{b}{x}=\\frac{\\log_{k}{x}}{\\log_{k}{b}}$\n\n##### 1.4.3.1.1 证明\n\n由对数函数的定义，可得：\n\n$x=b^{\\log_{b}{x}}$\n\n等式两边同时以 $k$ 为底取对数，可得：\n\n$\\log_{k}{x}=\\log_{k}({b^{\\log_{b}{x}})}$\n\n$\\because b^x=N(b>0,且b\\neq1)$，有 $x=\\log_{b}{N}$。\n\n那么 $(b^x)^t=b^{xt}=N^t\\ (t\\in{R})$，可得：\n\n$xt=\\log_{b}{N^t}=t\\log_{b}{N}\\ (t\\in{R})$\n\n$\\therefore\\log_{k}{x}=\\log_{k}{b^{\\log_{b}{x}}}=\\log_{b}{x}\\log_{k}{b}$\n\n$\\log_{b}{x}=\\frac{\\log_{k}{x}}{\\log_{k}{b}}$ 得证。\n\n\n\n#### 1.4.3.2 和差\n\n$\\log_{b}{MN}=\\log_{b}{M}+\\log_{b}{N}$\n\n$\\log_{b}{\\frac{M}{N}}=\\log_{b}{M}-\\log_{b}{N}$\n\n##### 1.4.3.2.1 证明\n\n设 $M=\\beta^{m},N=\\beta^{n}$\n\n则 $\\log_{b}{MN}=\\log_{b}({\\beta^{m}\\beta^{n}})$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}({\\beta^{m+n}})$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =(m+n)\\log_{b}{\\beta}$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =m\\log_{b}{\\beta}+n\\log_{b}{\\beta}$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{\\beta^m}+\\log_{b}{\\beta^n}$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{M}+\\log_{b}{N}$\n\n$\\log_{b}{\\frac{M}{N}}=\\log_{b}{M}+\\log_{b}{\\frac{1}{N}}$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{M}+\\log_{b}{N^{-1}}$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{M}-\\log_{b}{N}$\n\n\n\n#### 1.4.3.3 次方公式\n\n$\\log_{b^N}({x^M})=\\frac{M}{N}\\log_{b}{x}$\n\n##### 1.4.3.3.1 证明\n\n由换底公式，可得：\n\n$\\log_{b^N}({x^M})=\\frac{\\ln{b^N}}{\\ln{x^M}}$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\frac{N\\ln{b}}{M\\ln{x}}$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\frac{M}{N}\\log_{b}{x}$\n\n##### \n\n#### 1.4.3.4 还原\n\n$b^{\\log_{b}{x}}=x$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{b^x}$\n\n\n\n#### 1.4.3.5 互换\n\n$M^{\\log_{b}{N}} = N^{\\log_{b}{M}}$\n\n##### 1.4.3.5.1 证明\n\n设 $\\alpha=\\log_{b}{N},\\  \\beta=\\log_{b}{M}$，则有 $b^\\alpha=N,\\ b^\\beta=M, \\ (b^\\beta)^\\alpha=(b^\\alpha)^\\beta$，\n\n$\\therefore M^{\\log_{b}{N}} = N^{\\log_{b}{M}}$\n\n\n\n#### 1.4.3.6 倒数\n\n$\\log_{b}{\\theta}=\\frac{\\ln \\theta}{\\ln b}=\\frac{1}{\\frac{\\ln b}{\\ln \\theta}}=\\frac{1}{\\log_{\\theta}{b}}$\n\n\n\n## 1.5 三角函数\n\n<!--TODO-->\n\n\n\n## 1.6 反三角函数\n\n<!--TODO-->\n\n\n\n# 2. 初等函数\n\n初等函数是由**基本初等函数**经过有限次的有理运算（加、减、乘、除、有理数次乘方、有理数次开方）及有限次函数复合所产生、并且在定义域上能用一个解析式表示的函数。\n\n基本初等函数和初等函数在其定义区间内均为**连续函数**。\n\n一般来说，分段函数不是初等函数，因为在这些分段函数的定义域上不能用一个解析式表示。\n\n\n\n\n> 参考：\n>\n> https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0\n>\n> https://zh.wikipedia.org/wiki/%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0\n\n\n<style>\n  table {\n    width: 1100px; /*表格宽度*/\n    max-width: 1100px; /*表格最大宽度，避免表格过宽*/\n    border: 1px solid #dedede; /*表格外边框设置*/\n    margin: 1px auto; /*外边距*/\n    border-collapse: collapse; /*使用单一线条的边框*/\n    empty-cells: show; /*单元格无内容依旧绘制边框*/\n  }\n  table th,\n  table td {\n    height: 35px; /*统一每一行的默认高度*/\n    border: 1px solid #dedede; /*内部边框样式*/\n    padding: 0 10px; /*内边距*/\n  }\n  table th {\n    font-weight: bold; /*加粗*/\n    text-align: center !important; /*内容居中，加上 !important 避免被 Markdown 样式覆盖*/\n    background: #F8F8F8; /*背景色*/\n  }\n  table tbody tr:nth-child(n) {\n    background: #FFFFFF; \n  }\n  table tr:hover {\n    background: #EFEFEF; \n}\n  table th {\n    white-space: nowrap; /*表头内容强制在一行显示*/\n  }\n  table td:nth-child(1) {\n    white-space: nowrap; /*表格第一列单元格内容不换行*/\n  }\n</style>\n","slug":"elementary-function","published":1,"updated":"2021-03-26T13:30:23.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmsyc4rc00075npr842r5mu3","content":"<p><strong>高等数学</strong>将基本初等函数归为五类：幂函数、指数函数、对数函数、三角函数、反三角函数。<br><strong>数学分析</strong>将基本初等函数归为六类：常函数、幂函数、指数函数、对数函数、三角函数、反三角函数。<br>接下来将按照<strong>数学分析</strong>的分类，逐一介绍这些函数。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"1-基本初等函数\"><a href=\"#1-基本初等函数\" class=\"headerlink\" title=\"1. 基本初等函数\"></a>1. 基本初等函数</h1><h2 id=\"1-1-常函数\"><a href=\"#1-1-常函数\" class=\"headerlink\" title=\"1.1 常函数\"></a>1.1 常函数</h2><p>常函数是指不管自变量值如何变化，函数值都不变的函数。</p>\n<p>形式为 $f(x)=C$，其中 $C$ 为常数，定义域为$(-\\infty,+\\infty)$。</p>\n<h3 id=\"1-1-1-图像\"><a href=\"#1-1-1-图像\" class=\"headerlink\" title=\"1.1.1 图像\"></a>1.1.1 图像</h3><img src=\"/2021/03/10/elementary-function/constant-function-example-1.png\" class=\"\" width=\"300\" height=\"300\">\n\n<p>$$f(x)=1$$</p>\n<h2 id=\"1-2-幂函数\"><a href=\"#1-2-幂函数\" class=\"headerlink\" title=\"1.2 幂函数\"></a>1.2 幂函数</h2><p>幂函数是以底数为自变量，幂为因变量，指数为常数的函数。</p>\n<p>形式为 $f(x)=x^α$（$a$ 可以是任意实数或者复数）。</p>\n<h3 id=\"1-2-1-有理数指数幂\"><a href=\"#1-2-1-有理数指数幂\" class=\"headerlink\" title=\"1.2.1 有理数指数幂\"></a>1.2.1 有理数指数幂</h3><p>当指数 $a$ 是有理数时，幂函数可以写作如下形式：</p>\n<p>$f(x)=x^{k\\frac{m}{n}}(k\\in\\lbrace-1,1,0\\rbrace,m,n\\in{N}^{*})$</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">定义域</th>\n<th align=\"center\">值域</th>\n<th align=\"center\">奇偶性</th>\n<th>图像</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$k=1,m,n$ 均为奇数</td>\n<td align=\"center\">$R$</td>\n<td align=\"center\">$R$</td>\n<td align=\"center\">奇函数</td>\n<td><img src=\"/2021/03/10/elementary-function/power-function-example-1.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=x^\\frac{1}{3}$$$$blue:f(x)=x^{3}$$</td>\n</tr>\n<tr>\n<td align=\"center\">$k=-1,m,n$ 均为奇数</td>\n<td align=\"center\">$(-\\infty,0)\\cup(0,+\\infty)$</td>\n<td align=\"center\">$(-\\infty,0)\\cup(0,+\\infty)$</td>\n<td align=\"center\">奇函数</td>\n<td><img src=\"/2021/03/10/elementary-function/power-function-example-2.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=x^{-\\frac{1}{3}}$$$$blue:f(x)=x^{-3}$$</td>\n</tr>\n<tr>\n<td align=\"center\">$k=1,m$ 为奇数$,n$ 为偶数</td>\n<td align=\"center\">$[0,+\\infty)$</td>\n<td align=\"center\">$[0,+\\infty)$</td>\n<td align=\"center\">非奇非偶函数</td>\n<td><img src=\"/2021/03/10/elementary-function/power-function-example-3.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=x^{\\frac{3}{2}}$$$$blue:f(x)=x^{\\frac{1}{2}}$$$$green:f(x)=x^{\\frac{5}{2}}$$</td>\n</tr>\n<tr>\n<td align=\"center\">$k=-1,m$ 为奇数$,n$ 为偶数</td>\n<td align=\"center\">$(0,+\\infty)$</td>\n<td align=\"center\">$(0,+\\infty)$</td>\n<td align=\"center\">非奇非偶函数</td>\n<td><img src=\"/2021/03/10/elementary-function/power-function-example-4.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=x^{-\\frac{3}{2}}$$$$blue:f(x)=x^{-\\frac{1}{2}}$$$$green:f(x)=x^{-\\frac{5}{2}}$$</td>\n</tr>\n<tr>\n<td align=\"center\">$k=1,m$ 为偶数$,n$ 为奇数</td>\n<td align=\"center\">$R$</td>\n<td align=\"center\">$[0,+\\infty)$</td>\n<td align=\"center\">偶函数</td>\n<td><img src=\"/2021/03/10/elementary-function/power-function-example-5.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=x^{\\frac{4}{3}}$$$$blue:f(x)=x^{\\frac{2}{3}}$$$$green:f(x)=x^{2}$$</td>\n</tr>\n<tr>\n<td align=\"center\">$k=-1,m$ 为偶数$,n$ 为奇数</td>\n<td align=\"center\">$(-\\infty,0)\\cup(0,+\\infty)$</td>\n<td align=\"center\">$(0,+\\infty)$</td>\n<td align=\"center\">偶函数</td>\n<td><img src=\"/2021/03/10/elementary-function/power-function-example-6.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=x^{-\\frac{4}{3}}$$$$blue:f(x)=x^{-\\frac{2}{3}}$$$$green:f(x)=x^{-2}$$</td>\n</tr>\n<tr>\n<td align=\"center\">$k=0$</td>\n<td align=\"center\">$(-\\infty,0)\\cup(0,+\\infty)$</td>\n<td align=\"center\">$\\lbrace1\\rbrace$</td>\n<td align=\"center\">偶函数</td>\n<td><img src=\"/2021/03/10/elementary-function/power-function-example-7.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=x^{0}$$注意，$f(x)=x^{0}$ 的图像并不是直线，而是直线 $y=1$ 去掉一点 $(0,1)$</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-3-指数函数\"><a href=\"#1-3-指数函数\" class=\"headerlink\" title=\"1.3 指数函数\"></a>1.3 指数函数</h2><p>一般地，指数函数的形式为 $f(x)=b^x$（$b$ 为常数且 $b\\in(0,1)\\cup(1,+\\infty)$），函数的定义域为 $R$，值域为 $(0,+\\infty)$。</p>\n<p>注意，在指数函数的定义表达式中，在 $b^x$ 前的系数必须为 $1$，自变量 $x$ 必须在指数的位置上，且不能为 $x$ 的其他表达式，否则，就不是指数函数。</p>\n<h3 id=\"1-3-1-图像\"><a href=\"#1-3-1-图像\" class=\"headerlink\" title=\"1.3.1 图像\"></a>1.3.1 图像</h3><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">值域</th>\n<th>图像</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$0&lt;b&lt;1$</td>\n<td align=\"center\">$(0,+\\infty)$</td>\n<td><img src=\"/2021/03/10/elementary-function/exponential-function-example-1.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=\\frac{1}{2}^x$$$$blue:f(x)=\\frac{1}{4}^x$$</td>\n</tr>\n<tr>\n<td align=\"center\">$b&gt;1$</td>\n<td align=\"center\">$(0,+\\infty)$</td>\n<td><img src=\"/2021/03/10/elementary-function/exponential-function-example-2.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=2^x$$$$blue:f(x)=4^x$$</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-3-2-性质\"><a href=\"#1-3-2-性质\" class=\"headerlink\" title=\"1.3.2 性质\"></a>1.3.2 性质</h3><h4 id=\"1-3-2-1-性质-1\"><a href=\"#1-3-2-1-性质-1\" class=\"headerlink\" title=\"1.3.2.1 性质 1\"></a>1.3.2.1 性质 1</h4><p>由指数函数的定义：</p>\n<p>​    $e^x=\\lim_{n \\to \\infty}(1+\\frac{x}{n})^{n}$</p>\n<p>可以得出以下定律：</p>\n<p>​    $e^0=1$</p>\n<p>​    $e^1=e$</p>\n<p>​    $e^{x+y}=e^xe^y$</p>\n<p>​    $e^{xy}=(e^x)^y$</p>\n<p>​    $\\frac{e^x}{e^y}=e^{x-y}$</p>\n<p>​    $e^{-x}=e^{0-x}=\\frac{e^0}{e^x}=\\frac{1}{e^x}$</p>\n<p>其中 $x\\in{R},y\\in{R}$。</p>\n<h4 id=\"1-3-2-2-性质-2\"><a href=\"#1-3-2-2-性质-2\" class=\"headerlink\" title=\"1.3.2.2 性质 2\"></a>1.3.2.2 性质 2</h4><p>因为在指数函数的定义中 $x$ 是实数，可以使用自然对数 $e$，把更一般的指数函数，即正实数的实数幂函数定义为</p>\n<p>$b^x=(e^{\\ln{b}})^x=e^{x\\ln{b}}$</p>\n<h4 id=\"1-3-2-3-性质-3\"><a href=\"#1-3-2-3-性质-3\" class=\"headerlink\" title=\"1.3.2.3 性质 3\"></a>1.3.2.3 性质 3</h4><p>定义于所有的 $b&gt;0$，和所有的实数 $x$。它叫做”底数为 $b$ 的指数函数”。从而拓展了通过乘方和方根运算定义的正实数的有理数幂函数：</p>\n<p>$b^{\\frac{m}{n}=\\sqrt[n]{b^m}}$</p>\n<p>而方根运算可通过自然对数和指数函数来表示：</p>\n<p>$\\sqrt[n]{b}=b^{\\frac{1}{n}}=(e^{\\ln{b}})^{\\frac{1}{n}}=e^{\\frac{\\ln{b}}{n}}$</p>\n<h2 id=\"1-4-对数函数\"><a href=\"#1-4-对数函数\" class=\"headerlink\" title=\"1.4 对数函数\"></a>1.4 对数函数</h2><p>对数是幂运算的逆运算。</p>\n<p>如果 $b^x=N(b&gt;0,且b\\neq1)$，那么 $x$ 叫做以 $b$ 为底 $N$ 的对数，记作 $x=\\log_{b}{N}$，读作以 $b$ 为底 $N$ 的对数，其中 $b$ 叫做对数的底，$N$ 叫做幂或者真数。</p>\n<p>一般地，对数函数的形式为 $f(x)=\\log_{b}{x}(b&gt;0,且b\\neq1)$，函数的定义域为 $(0,+\\infty)$，值域为 $R$ 。</p>\n<p>对数函数实际上就是指数函数的反函数，可表示为 $x=b^y$。因此指数函数里对于常数 $b$ 的规定，同样适用于对数函数。</p>\n<h3 id=\"1-4-1-图像\"><a href=\"#1-4-1-图像\" class=\"headerlink\" title=\"1.4.1 图像\"></a>1.4.1 图像</h3><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">值域</th>\n<th>图像</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$0&lt;b&lt;1$</td>\n<td align=\"center\">$R$</td>\n<td><img src=\"/2021/03/10/elementary-function/logarithmic-function-example-1.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=\\log_{\\frac{1}{2}}{x}$$$$blue:f(x)=\\log_{\\frac{1}{4}}{x}$$</td>\n</tr>\n<tr>\n<td align=\"center\">$b&gt;1$</td>\n<td align=\"center\">$R$</td>\n<td><img src=\"/2021/03/10/elementary-function/logarithmic-function-example-2.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=\\log_{2}{x}$$$$blue:f(x)=\\log_{4}{x}$$</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-4-2-性质\"><a href=\"#1-4-2-性质\" class=\"headerlink\" title=\"1.4.2 性质\"></a>1.4.2 性质</h3><ul>\n<li><p>对数函数的函数图像恒定过点$(1,0)$</p>\n</li>\n<li><p>当 $0&lt;b&lt;1$ 时，函数在定义域 $(0,+\\infty)$ 上为单调减函数；$b&gt;1$ 时，函数在定义域 $(0,+\\infty)$ 上为单调增函数</p>\n</li>\n<li><p>对数函数 $f(x)=\\log_{b}{x}(b&gt;0,b\\neq1,x&gt;0)$</p>\n<p>当 $0&lt;b&lt;1,0&lt;x&lt;1$ 时，$f(x)=\\log_{b}{x}&gt;0$</p>\n<p>当 $b&gt;1, x&gt;1$ 时，$f(x)=\\log_{b}{x}&gt;0$</p>\n<p>当 $0&lt;b&lt;1, x&gt;1$ 时，$f(x)=\\log_{b}{x}&lt;0$</p>\n<p>当 $b&gt;1, 0&lt;x&lt;1$ 时，$f(x)=\\log_{b}{x}&lt;0$</p>\n</li>\n<li><p>底数为 $b$ 的对数函数$f(x)=\\log_{b}{x}与$指数函数 $f(x)=b^x$ 互为反函数，两者的函数图像关于直线 $y = x$ 对称。</p>\n</li>\n</ul>\n<img src=\"/2021/03/10/elementary-function/logarithmic-function-example-3.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=\\log_{2}{x}$$$$blue:f(x)=2^{x}$$$$green:f(x)=\\log_{\\frac{1}{2}}{x}$$$$blue:f(x)={\\frac{1}{2}}^{x}$$\n\n<h3 id=\"1-4-3-公式\"><a href=\"#1-4-3-公式\" class=\"headerlink\" title=\"1.4.3 公式\"></a>1.4.3 公式</h3><h4 id=\"1-4-3-1-换底公式\"><a href=\"#1-4-3-1-换底公式\" class=\"headerlink\" title=\"1.4.3.1 换底公式\"></a>1.4.3.1 换底公式</h4><p>$\\log_{b}{x}=\\frac{\\log_{k}{x}}{\\log_{k}{b}}$</p>\n<h5 id=\"1-4-3-1-1-证明\"><a href=\"#1-4-3-1-1-证明\" class=\"headerlink\" title=\"1.4.3.1.1 证明\"></a>1.4.3.1.1 证明</h5><p>由对数函数的定义，可得：</p>\n<p>$x=b^{\\log_{b}{x}}$</p>\n<p>等式两边同时以 $k$ 为底取对数，可得：</p>\n<p>$\\log_{k}{x}=\\log_{k}({b^{\\log_{b}{x}})}$</p>\n<p>$\\because b^x=N(b&gt;0,且b\\neq1)$，有 $x=\\log_{b}{N}$。</p>\n<p>那么 $(b^x)^t=b^{xt}=N^t\\ (t\\in{R})$，可得：</p>\n<p>$xt=\\log_{b}{N^t}=t\\log_{b}{N}\\ (t\\in{R})$</p>\n<p>$\\therefore\\log_{k}{x}=\\log_{k}{b^{\\log_{b}{x}}}=\\log_{b}{x}\\log_{k}{b}$</p>\n<p>$\\log_{b}{x}=\\frac{\\log_{k}{x}}{\\log_{k}{b}}$ 得证。</p>\n<h4 id=\"1-4-3-2-和差\"><a href=\"#1-4-3-2-和差\" class=\"headerlink\" title=\"1.4.3.2 和差\"></a>1.4.3.2 和差</h4><p>$\\log_{b}{MN}=\\log_{b}{M}+\\log_{b}{N}$</p>\n<p>$\\log_{b}{\\frac{M}{N}}=\\log_{b}{M}-\\log_{b}{N}$</p>\n<h5 id=\"1-4-3-2-1-证明\"><a href=\"#1-4-3-2-1-证明\" class=\"headerlink\" title=\"1.4.3.2.1 证明\"></a>1.4.3.2.1 证明</h5><p>设 $M=\\beta^{m},N=\\beta^{n}$</p>\n<p>则 $\\log_{b}{MN}=\\log_{b}({\\beta^{m}\\beta^{n}})$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}({\\beta^{m+n}})$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =(m+n)\\log_{b}{\\beta}$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =m\\log_{b}{\\beta}+n\\log_{b}{\\beta}$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{\\beta^m}+\\log_{b}{\\beta^n}$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{M}+\\log_{b}{N}$</p>\n<p>$\\log_{b}{\\frac{M}{N}}=\\log_{b}{M}+\\log_{b}{\\frac{1}{N}}$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{M}+\\log_{b}{N^{-1}}$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{M}-\\log_{b}{N}$</p>\n<h4 id=\"1-4-3-3-次方公式\"><a href=\"#1-4-3-3-次方公式\" class=\"headerlink\" title=\"1.4.3.3 次方公式\"></a>1.4.3.3 次方公式</h4><p>$\\log_{b^N}({x^M})=\\frac{M}{N}\\log_{b}{x}$</p>\n<h5 id=\"1-4-3-3-1-证明\"><a href=\"#1-4-3-3-1-证明\" class=\"headerlink\" title=\"1.4.3.3.1 证明\"></a>1.4.3.3.1 证明</h5><p>由换底公式，可得：</p>\n<p>$\\log_{b^N}({x^M})=\\frac{\\ln{b^N}}{\\ln{x^M}}$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\frac{N\\ln{b}}{M\\ln{x}}$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\frac{M}{N}\\log_{b}{x}$</p>\n<h5 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h5><h4 id=\"1-4-3-4-还原\"><a href=\"#1-4-3-4-还原\" class=\"headerlink\" title=\"1.4.3.4 还原\"></a>1.4.3.4 还原</h4><p>$b^{\\log_{b}{x}}=x$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{b^x}$</p>\n<h4 id=\"1-4-3-5-互换\"><a href=\"#1-4-3-5-互换\" class=\"headerlink\" title=\"1.4.3.5 互换\"></a>1.4.3.5 互换</h4><p>$M^{\\log_{b}{N}} = N^{\\log_{b}{M}}$</p>\n<h5 id=\"1-4-3-5-1-证明\"><a href=\"#1-4-3-5-1-证明\" class=\"headerlink\" title=\"1.4.3.5.1 证明\"></a>1.4.3.5.1 证明</h5><p>设 $\\alpha=\\log_{b}{N},\\  \\beta=\\log_{b}{M}$，则有 $b^\\alpha=N,\\ b^\\beta=M, \\ (b^\\beta)^\\alpha=(b^\\alpha)^\\beta$，</p>\n<p>$\\therefore M^{\\log_{b}{N}} = N^{\\log_{b}{M}}$</p>\n<h4 id=\"1-4-3-6-倒数\"><a href=\"#1-4-3-6-倒数\" class=\"headerlink\" title=\"1.4.3.6 倒数\"></a>1.4.3.6 倒数</h4><p>$\\log_{b}{\\theta}=\\frac{\\ln \\theta}{\\ln b}=\\frac{1}{\\frac{\\ln b}{\\ln \\theta}}=\\frac{1}{\\log_{\\theta}{b}}$</p>\n<h2 id=\"1-5-三角函数\"><a href=\"#1-5-三角函数\" class=\"headerlink\" title=\"1.5 三角函数\"></a>1.5 三角函数</h2><!--TODO-->\n\n\n\n<h2 id=\"1-6-反三角函数\"><a href=\"#1-6-反三角函数\" class=\"headerlink\" title=\"1.6 反三角函数\"></a>1.6 反三角函数</h2><!--TODO-->\n\n\n\n<h1 id=\"2-初等函数\"><a href=\"#2-初等函数\" class=\"headerlink\" title=\"2. 初等函数\"></a>2. 初等函数</h1><p>初等函数是由<strong>基本初等函数</strong>经过有限次的有理运算（加、减、乘、除、有理数次乘方、有理数次开方）及有限次函数复合所产生、并且在定义域上能用一个解析式表示的函数。</p>\n<p>基本初等函数和初等函数在其定义区间内均为<strong>连续函数</strong>。</p>\n<p>一般来说，分段函数不是初等函数，因为在这些分段函数的定义域上不能用一个解析式表示。</p>\n<blockquote>\n<p>参考：</p>\n<p><a href=\"https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0\">https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0\">https://zh.wikipedia.org/wiki/%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0</a></p>\n</blockquote>\n<style>\n  table {\n    width: 1100px; /*表格宽度*/\n    max-width: 1100px; /*表格最大宽度，避免表格过宽*/\n    border: 1px solid #dedede; /*表格外边框设置*/\n    margin: 1px auto; /*外边距*/\n    border-collapse: collapse; /*使用单一线条的边框*/\n    empty-cells: show; /*单元格无内容依旧绘制边框*/\n  }\n  table th,\n  table td {\n    height: 35px; /*统一每一行的默认高度*/\n    border: 1px solid #dedede; /*内部边框样式*/\n    padding: 0 10px; /*内边距*/\n  }\n  table th {\n    font-weight: bold; /*加粗*/\n    text-align: center !important; /*内容居中，加上 !important 避免被 Markdown 样式覆盖*/\n    background: #F8F8F8; /*背景色*/\n  }\n  table tbody tr:nth-child(n) {\n    background: #FFFFFF; \n  }\n  table tr:hover {\n    background: #EFEFEF; \n}\n  table th {\n    white-space: nowrap; /*表头内容强制在一行显示*/\n  }\n  table td:nth-child(1) {\n    white-space: nowrap; /*表格第一列单元格内容不换行*/\n  }\n</style>\n","site":{"data":{}},"excerpt":"<p><strong>高等数学</strong>将基本初等函数归为五类：幂函数、指数函数、对数函数、三角函数、反三角函数。<br><strong>数学分析</strong>将基本初等函数归为六类：常函数、幂函数、指数函数、对数函数、三角函数、反三角函数。<br>接下来将按照<strong>数学分析</strong>的分类，逐一介绍这些函数。</p>","more":"<h1 id=\"1-基本初等函数\"><a href=\"#1-基本初等函数\" class=\"headerlink\" title=\"1. 基本初等函数\"></a>1. 基本初等函数</h1><h2 id=\"1-1-常函数\"><a href=\"#1-1-常函数\" class=\"headerlink\" title=\"1.1 常函数\"></a>1.1 常函数</h2><p>常函数是指不管自变量值如何变化，函数值都不变的函数。</p>\n<p>形式为 $f(x)=C$，其中 $C$ 为常数，定义域为$(-\\infty,+\\infty)$。</p>\n<h3 id=\"1-1-1-图像\"><a href=\"#1-1-1-图像\" class=\"headerlink\" title=\"1.1.1 图像\"></a>1.1.1 图像</h3><img src=\"/2021/03/10/elementary-function/constant-function-example-1.png\" class=\"\" width=\"300\" height=\"300\">\n\n<p>$$f(x)=1$$</p>\n<h2 id=\"1-2-幂函数\"><a href=\"#1-2-幂函数\" class=\"headerlink\" title=\"1.2 幂函数\"></a>1.2 幂函数</h2><p>幂函数是以底数为自变量，幂为因变量，指数为常数的函数。</p>\n<p>形式为 $f(x)=x^α$（$a$ 可以是任意实数或者复数）。</p>\n<h3 id=\"1-2-1-有理数指数幂\"><a href=\"#1-2-1-有理数指数幂\" class=\"headerlink\" title=\"1.2.1 有理数指数幂\"></a>1.2.1 有理数指数幂</h3><p>当指数 $a$ 是有理数时，幂函数可以写作如下形式：</p>\n<p>$f(x)=x^{k\\frac{m}{n}}(k\\in\\lbrace-1,1,0\\rbrace,m,n\\in{N}^{*})$</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">定义域</th>\n<th align=\"center\">值域</th>\n<th align=\"center\">奇偶性</th>\n<th>图像</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$k=1,m,n$ 均为奇数</td>\n<td align=\"center\">$R$</td>\n<td align=\"center\">$R$</td>\n<td align=\"center\">奇函数</td>\n<td><img src=\"/2021/03/10/elementary-function/power-function-example-1.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=x^\\frac{1}{3}$$$$blue:f(x)=x^{3}$$</td>\n</tr>\n<tr>\n<td align=\"center\">$k=-1,m,n$ 均为奇数</td>\n<td align=\"center\">$(-\\infty,0)\\cup(0,+\\infty)$</td>\n<td align=\"center\">$(-\\infty,0)\\cup(0,+\\infty)$</td>\n<td align=\"center\">奇函数</td>\n<td><img src=\"/2021/03/10/elementary-function/power-function-example-2.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=x^{-\\frac{1}{3}}$$$$blue:f(x)=x^{-3}$$</td>\n</tr>\n<tr>\n<td align=\"center\">$k=1,m$ 为奇数$,n$ 为偶数</td>\n<td align=\"center\">$[0,+\\infty)$</td>\n<td align=\"center\">$[0,+\\infty)$</td>\n<td align=\"center\">非奇非偶函数</td>\n<td><img src=\"/2021/03/10/elementary-function/power-function-example-3.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=x^{\\frac{3}{2}}$$$$blue:f(x)=x^{\\frac{1}{2}}$$$$green:f(x)=x^{\\frac{5}{2}}$$</td>\n</tr>\n<tr>\n<td align=\"center\">$k=-1,m$ 为奇数$,n$ 为偶数</td>\n<td align=\"center\">$(0,+\\infty)$</td>\n<td align=\"center\">$(0,+\\infty)$</td>\n<td align=\"center\">非奇非偶函数</td>\n<td><img src=\"/2021/03/10/elementary-function/power-function-example-4.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=x^{-\\frac{3}{2}}$$$$blue:f(x)=x^{-\\frac{1}{2}}$$$$green:f(x)=x^{-\\frac{5}{2}}$$</td>\n</tr>\n<tr>\n<td align=\"center\">$k=1,m$ 为偶数$,n$ 为奇数</td>\n<td align=\"center\">$R$</td>\n<td align=\"center\">$[0,+\\infty)$</td>\n<td align=\"center\">偶函数</td>\n<td><img src=\"/2021/03/10/elementary-function/power-function-example-5.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=x^{\\frac{4}{3}}$$$$blue:f(x)=x^{\\frac{2}{3}}$$$$green:f(x)=x^{2}$$</td>\n</tr>\n<tr>\n<td align=\"center\">$k=-1,m$ 为偶数$,n$ 为奇数</td>\n<td align=\"center\">$(-\\infty,0)\\cup(0,+\\infty)$</td>\n<td align=\"center\">$(0,+\\infty)$</td>\n<td align=\"center\">偶函数</td>\n<td><img src=\"/2021/03/10/elementary-function/power-function-example-6.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=x^{-\\frac{4}{3}}$$$$blue:f(x)=x^{-\\frac{2}{3}}$$$$green:f(x)=x^{-2}$$</td>\n</tr>\n<tr>\n<td align=\"center\">$k=0$</td>\n<td align=\"center\">$(-\\infty,0)\\cup(0,+\\infty)$</td>\n<td align=\"center\">$\\lbrace1\\rbrace$</td>\n<td align=\"center\">偶函数</td>\n<td><img src=\"/2021/03/10/elementary-function/power-function-example-7.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=x^{0}$$注意，$f(x)=x^{0}$ 的图像并不是直线，而是直线 $y=1$ 去掉一点 $(0,1)$</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-3-指数函数\"><a href=\"#1-3-指数函数\" class=\"headerlink\" title=\"1.3 指数函数\"></a>1.3 指数函数</h2><p>一般地，指数函数的形式为 $f(x)=b^x$（$b$ 为常数且 $b\\in(0,1)\\cup(1,+\\infty)$），函数的定义域为 $R$，值域为 $(0,+\\infty)$。</p>\n<p>注意，在指数函数的定义表达式中，在 $b^x$ 前的系数必须为 $1$，自变量 $x$ 必须在指数的位置上，且不能为 $x$ 的其他表达式，否则，就不是指数函数。</p>\n<h3 id=\"1-3-1-图像\"><a href=\"#1-3-1-图像\" class=\"headerlink\" title=\"1.3.1 图像\"></a>1.3.1 图像</h3><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">值域</th>\n<th>图像</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$0&lt;b&lt;1$</td>\n<td align=\"center\">$(0,+\\infty)$</td>\n<td><img src=\"/2021/03/10/elementary-function/exponential-function-example-1.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=\\frac{1}{2}^x$$$$blue:f(x)=\\frac{1}{4}^x$$</td>\n</tr>\n<tr>\n<td align=\"center\">$b&gt;1$</td>\n<td align=\"center\">$(0,+\\infty)$</td>\n<td><img src=\"/2021/03/10/elementary-function/exponential-function-example-2.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=2^x$$$$blue:f(x)=4^x$$</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-3-2-性质\"><a href=\"#1-3-2-性质\" class=\"headerlink\" title=\"1.3.2 性质\"></a>1.3.2 性质</h3><h4 id=\"1-3-2-1-性质-1\"><a href=\"#1-3-2-1-性质-1\" class=\"headerlink\" title=\"1.3.2.1 性质 1\"></a>1.3.2.1 性质 1</h4><p>由指数函数的定义：</p>\n<p>​    $e^x=\\lim_{n \\to \\infty}(1+\\frac{x}{n})^{n}$</p>\n<p>可以得出以下定律：</p>\n<p>​    $e^0=1$</p>\n<p>​    $e^1=e$</p>\n<p>​    $e^{x+y}=e^xe^y$</p>\n<p>​    $e^{xy}=(e^x)^y$</p>\n<p>​    $\\frac{e^x}{e^y}=e^{x-y}$</p>\n<p>​    $e^{-x}=e^{0-x}=\\frac{e^0}{e^x}=\\frac{1}{e^x}$</p>\n<p>其中 $x\\in{R},y\\in{R}$。</p>\n<h4 id=\"1-3-2-2-性质-2\"><a href=\"#1-3-2-2-性质-2\" class=\"headerlink\" title=\"1.3.2.2 性质 2\"></a>1.3.2.2 性质 2</h4><p>因为在指数函数的定义中 $x$ 是实数，可以使用自然对数 $e$，把更一般的指数函数，即正实数的实数幂函数定义为</p>\n<p>$b^x=(e^{\\ln{b}})^x=e^{x\\ln{b}}$</p>\n<h4 id=\"1-3-2-3-性质-3\"><a href=\"#1-3-2-3-性质-3\" class=\"headerlink\" title=\"1.3.2.3 性质 3\"></a>1.3.2.3 性质 3</h4><p>定义于所有的 $b&gt;0$，和所有的实数 $x$。它叫做”底数为 $b$ 的指数函数”。从而拓展了通过乘方和方根运算定义的正实数的有理数幂函数：</p>\n<p>$b^{\\frac{m}{n}=\\sqrt[n]{b^m}}$</p>\n<p>而方根运算可通过自然对数和指数函数来表示：</p>\n<p>$\\sqrt[n]{b}=b^{\\frac{1}{n}}=(e^{\\ln{b}})^{\\frac{1}{n}}=e^{\\frac{\\ln{b}}{n}}$</p>\n<h2 id=\"1-4-对数函数\"><a href=\"#1-4-对数函数\" class=\"headerlink\" title=\"1.4 对数函数\"></a>1.4 对数函数</h2><p>对数是幂运算的逆运算。</p>\n<p>如果 $b^x=N(b&gt;0,且b\\neq1)$，那么 $x$ 叫做以 $b$ 为底 $N$ 的对数，记作 $x=\\log_{b}{N}$，读作以 $b$ 为底 $N$ 的对数，其中 $b$ 叫做对数的底，$N$ 叫做幂或者真数。</p>\n<p>一般地，对数函数的形式为 $f(x)=\\log_{b}{x}(b&gt;0,且b\\neq1)$，函数的定义域为 $(0,+\\infty)$，值域为 $R$ 。</p>\n<p>对数函数实际上就是指数函数的反函数，可表示为 $x=b^y$。因此指数函数里对于常数 $b$ 的规定，同样适用于对数函数。</p>\n<h3 id=\"1-4-1-图像\"><a href=\"#1-4-1-图像\" class=\"headerlink\" title=\"1.4.1 图像\"></a>1.4.1 图像</h3><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">值域</th>\n<th>图像</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$0&lt;b&lt;1$</td>\n<td align=\"center\">$R$</td>\n<td><img src=\"/2021/03/10/elementary-function/logarithmic-function-example-1.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=\\log_{\\frac{1}{2}}{x}$$$$blue:f(x)=\\log_{\\frac{1}{4}}{x}$$</td>\n</tr>\n<tr>\n<td align=\"center\">$b&gt;1$</td>\n<td align=\"center\">$R$</td>\n<td><img src=\"/2021/03/10/elementary-function/logarithmic-function-example-2.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=\\log_{2}{x}$$$$blue:f(x)=\\log_{4}{x}$$</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-4-2-性质\"><a href=\"#1-4-2-性质\" class=\"headerlink\" title=\"1.4.2 性质\"></a>1.4.2 性质</h3><ul>\n<li><p>对数函数的函数图像恒定过点$(1,0)$</p>\n</li>\n<li><p>当 $0&lt;b&lt;1$ 时，函数在定义域 $(0,+\\infty)$ 上为单调减函数；$b&gt;1$ 时，函数在定义域 $(0,+\\infty)$ 上为单调增函数</p>\n</li>\n<li><p>对数函数 $f(x)=\\log_{b}{x}(b&gt;0,b\\neq1,x&gt;0)$</p>\n<p>当 $0&lt;b&lt;1,0&lt;x&lt;1$ 时，$f(x)=\\log_{b}{x}&gt;0$</p>\n<p>当 $b&gt;1, x&gt;1$ 时，$f(x)=\\log_{b}{x}&gt;0$</p>\n<p>当 $0&lt;b&lt;1, x&gt;1$ 时，$f(x)=\\log_{b}{x}&lt;0$</p>\n<p>当 $b&gt;1, 0&lt;x&lt;1$ 时，$f(x)=\\log_{b}{x}&lt;0$</p>\n</li>\n<li><p>底数为 $b$ 的对数函数$f(x)=\\log_{b}{x}与$指数函数 $f(x)=b^x$ 互为反函数，两者的函数图像关于直线 $y = x$ 对称。</p>\n</li>\n</ul>\n<img src=\"/2021/03/10/elementary-function/logarithmic-function-example-3.png\" class=\"\" width=\"300\" height=\"300\"> $$red:f(x)=\\log_{2}{x}$$$$blue:f(x)=2^{x}$$$$green:f(x)=\\log_{\\frac{1}{2}}{x}$$$$blue:f(x)={\\frac{1}{2}}^{x}$$\n\n<h3 id=\"1-4-3-公式\"><a href=\"#1-4-3-公式\" class=\"headerlink\" title=\"1.4.3 公式\"></a>1.4.3 公式</h3><h4 id=\"1-4-3-1-换底公式\"><a href=\"#1-4-3-1-换底公式\" class=\"headerlink\" title=\"1.4.3.1 换底公式\"></a>1.4.3.1 换底公式</h4><p>$\\log_{b}{x}=\\frac{\\log_{k}{x}}{\\log_{k}{b}}$</p>\n<h5 id=\"1-4-3-1-1-证明\"><a href=\"#1-4-3-1-1-证明\" class=\"headerlink\" title=\"1.4.3.1.1 证明\"></a>1.4.3.1.1 证明</h5><p>由对数函数的定义，可得：</p>\n<p>$x=b^{\\log_{b}{x}}$</p>\n<p>等式两边同时以 $k$ 为底取对数，可得：</p>\n<p>$\\log_{k}{x}=\\log_{k}({b^{\\log_{b}{x}})}$</p>\n<p>$\\because b^x=N(b&gt;0,且b\\neq1)$，有 $x=\\log_{b}{N}$。</p>\n<p>那么 $(b^x)^t=b^{xt}=N^t\\ (t\\in{R})$，可得：</p>\n<p>$xt=\\log_{b}{N^t}=t\\log_{b}{N}\\ (t\\in{R})$</p>\n<p>$\\therefore\\log_{k}{x}=\\log_{k}{b^{\\log_{b}{x}}}=\\log_{b}{x}\\log_{k}{b}$</p>\n<p>$\\log_{b}{x}=\\frac{\\log_{k}{x}}{\\log_{k}{b}}$ 得证。</p>\n<h4 id=\"1-4-3-2-和差\"><a href=\"#1-4-3-2-和差\" class=\"headerlink\" title=\"1.4.3.2 和差\"></a>1.4.3.2 和差</h4><p>$\\log_{b}{MN}=\\log_{b}{M}+\\log_{b}{N}$</p>\n<p>$\\log_{b}{\\frac{M}{N}}=\\log_{b}{M}-\\log_{b}{N}$</p>\n<h5 id=\"1-4-3-2-1-证明\"><a href=\"#1-4-3-2-1-证明\" class=\"headerlink\" title=\"1.4.3.2.1 证明\"></a>1.4.3.2.1 证明</h5><p>设 $M=\\beta^{m},N=\\beta^{n}$</p>\n<p>则 $\\log_{b}{MN}=\\log_{b}({\\beta^{m}\\beta^{n}})$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}({\\beta^{m+n}})$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =(m+n)\\log_{b}{\\beta}$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =m\\log_{b}{\\beta}+n\\log_{b}{\\beta}$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{\\beta^m}+\\log_{b}{\\beta^n}$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{M}+\\log_{b}{N}$</p>\n<p>$\\log_{b}{\\frac{M}{N}}=\\log_{b}{M}+\\log_{b}{\\frac{1}{N}}$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{M}+\\log_{b}{N^{-1}}$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{M}-\\log_{b}{N}$</p>\n<h4 id=\"1-4-3-3-次方公式\"><a href=\"#1-4-3-3-次方公式\" class=\"headerlink\" title=\"1.4.3.3 次方公式\"></a>1.4.3.3 次方公式</h4><p>$\\log_{b^N}({x^M})=\\frac{M}{N}\\log_{b}{x}$</p>\n<h5 id=\"1-4-3-3-1-证明\"><a href=\"#1-4-3-3-1-证明\" class=\"headerlink\" title=\"1.4.3.3.1 证明\"></a>1.4.3.3.1 证明</h5><p>由换底公式，可得：</p>\n<p>$\\log_{b^N}({x^M})=\\frac{\\ln{b^N}}{\\ln{x^M}}$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\frac{N\\ln{b}}{M\\ln{x}}$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\frac{M}{N}\\log_{b}{x}$</p>\n<h5 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h5><h4 id=\"1-4-3-4-还原\"><a href=\"#1-4-3-4-还原\" class=\"headerlink\" title=\"1.4.3.4 还原\"></a>1.4.3.4 还原</h4><p>$b^{\\log_{b}{x}}=x$</p>\n<p>$\\ \\ \\ \\ \\ \\ \\ \\ =\\log_{b}{b^x}$</p>\n<h4 id=\"1-4-3-5-互换\"><a href=\"#1-4-3-5-互换\" class=\"headerlink\" title=\"1.4.3.5 互换\"></a>1.4.3.5 互换</h4><p>$M^{\\log_{b}{N}} = N^{\\log_{b}{M}}$</p>\n<h5 id=\"1-4-3-5-1-证明\"><a href=\"#1-4-3-5-1-证明\" class=\"headerlink\" title=\"1.4.3.5.1 证明\"></a>1.4.3.5.1 证明</h5><p>设 $\\alpha=\\log_{b}{N},\\  \\beta=\\log_{b}{M}$，则有 $b^\\alpha=N,\\ b^\\beta=M, \\ (b^\\beta)^\\alpha=(b^\\alpha)^\\beta$，</p>\n<p>$\\therefore M^{\\log_{b}{N}} = N^{\\log_{b}{M}}$</p>\n<h4 id=\"1-4-3-6-倒数\"><a href=\"#1-4-3-6-倒数\" class=\"headerlink\" title=\"1.4.3.6 倒数\"></a>1.4.3.6 倒数</h4><p>$\\log_{b}{\\theta}=\\frac{\\ln \\theta}{\\ln b}=\\frac{1}{\\frac{\\ln b}{\\ln \\theta}}=\\frac{1}{\\log_{\\theta}{b}}$</p>\n<h2 id=\"1-5-三角函数\"><a href=\"#1-5-三角函数\" class=\"headerlink\" title=\"1.5 三角函数\"></a>1.5 三角函数</h2><!--TODO-->\n\n\n\n<h2 id=\"1-6-反三角函数\"><a href=\"#1-6-反三角函数\" class=\"headerlink\" title=\"1.6 反三角函数\"></a>1.6 反三角函数</h2><!--TODO-->\n\n\n\n<h1 id=\"2-初等函数\"><a href=\"#2-初等函数\" class=\"headerlink\" title=\"2. 初等函数\"></a>2. 初等函数</h1><p>初等函数是由<strong>基本初等函数</strong>经过有限次的有理运算（加、减、乘、除、有理数次乘方、有理数次开方）及有限次函数复合所产生、并且在定义域上能用一个解析式表示的函数。</p>\n<p>基本初等函数和初等函数在其定义区间内均为<strong>连续函数</strong>。</p>\n<p>一般来说，分段函数不是初等函数，因为在这些分段函数的定义域上不能用一个解析式表示。</p>\n<blockquote>\n<p>参考：</p>\n<p><a href=\"https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0\">https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0\">https://zh.wikipedia.org/wiki/%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0</a></p>\n</blockquote>\n<style>\n  table {\n    width: 1100px; /*表格宽度*/\n    max-width: 1100px; /*表格最大宽度，避免表格过宽*/\n    border: 1px solid #dedede; /*表格外边框设置*/\n    margin: 1px auto; /*外边距*/\n    border-collapse: collapse; /*使用单一线条的边框*/\n    empty-cells: show; /*单元格无内容依旧绘制边框*/\n  }\n  table th,\n  table td {\n    height: 35px; /*统一每一行的默认高度*/\n    border: 1px solid #dedede; /*内部边框样式*/\n    padding: 0 10px; /*内边距*/\n  }\n  table th {\n    font-weight: bold; /*加粗*/\n    text-align: center !important; /*内容居中，加上 !important 避免被 Markdown 样式覆盖*/\n    background: #F8F8F8; /*背景色*/\n  }\n  table tbody tr:nth-child(n) {\n    background: #FFFFFF; \n  }\n  table tr:hover {\n    background: #EFEFEF; \n}\n  table th {\n    white-space: nowrap; /*表头内容强制在一行显示*/\n  }\n  table td:nth-child(1) {\n    white-space: nowrap; /*表格第一列单元格内容不换行*/\n  }\n</style>"},{"title":"Hello World","date":"2021-03-18T03:49:09.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/2021-03-18-hello-world.md","raw":"---\ntitle: Hello World\ndate: 2021-03-18 11:49:09\ntags: Test\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2021-03-26T13:07:41.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmsyc4rd00085npr5cpiccvy","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>"},{"title":"Android 同步屏障","date":"2021-03-25T07:34:53.000Z","_content":"\n在 Android 系统源码中，多处使用了同步屏障。例如：\n\n```java\n// ViewRootImpl.java\n\nvoid scheduleTraversals() {\n    if (!mTraversalScheduled) {\n        mTraversalScheduled = true;\n\n        // 发起同步屏障\n        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n\n        // 监听下一帧的信号\n        mChoreographer.postCallback(\n                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n\n        // 省略...\n    }\n}\n```\n\n这是 Android 屏幕刷新过程中的一个操作，在调用 postCallback(int, Runnable, Object) 方法监听下一帧信号之前，首先向当前线程的消息队列发起了同步屏障。\n\n接下来我们通过对源码的解读，分析出同步屏障的作用到底是什么。\n\n\n\n<!-- more -->\n\n# 1. Message 的种类\n\nMessage 中有一个 flag 变量，用于标记 Message 的类型。\n\n## 1.1 Message::setAsynchronous(boolean)\n\n```java\npublic void setAsynchronous(boolean async) {\n    if (async) {\n        // 异步消息, 通过或运算添加 FLAG_ASYNCHRONOUS 标记\n        flags |= FLAG_ASYNCHRONOUS;\n    } else {\n        // 同步消息, 通过与运算移除 FLAG_ASYNCHRONOUS 标记\n        flags &= ~FLAG_ASYNCHRONOUS;\n    }\n}\n```\n\n调用 setAsynchronous(boolean) 方法，可以将 Message 设置为**同步消息**或者**异步消息**。\n\n## 1.2 Message::isAsynchronous()\n\n```java\npublic boolean isAsynchronous() {\n    // 通过与运算判断 flags 是否带有 FLAG_ASYNCHRONOUS 标记\n    return (flags & FLAG_ASYNCHRONOUS) != 0;\n}\n```\n\n通过 isAsynchronous() 方法，可以判断 Message 是**同步消息**还是**异步消息**。\n\n由此可知，Message 可以分为两类：\n\n- 同步消息\n- 异步消息\n\n\n\n# 2. 发起同步屏障\n\n在屏幕刷新的例子中，同步屏障是通过调用 MessageQueue::postSyncBarrier() 方法发起的，实际上是间接调用了 MessageQueue::postSyncBarrier(long) 方法。\n\n```java\npublic int postSyncBarrier() {\n    return postSyncBarrier(SystemClock.uptimeMillis());\n}\n```\n\n这里传入的 SystemClock.uptimeMillis() 参数，表示了从系统启动到当前时刻经过的时间。\n\n```java\nprivate int postSyncBarrier(long when) {\n    // 注意到这里需要加锁进行操作, 因为 postSyncBarrier() 方法是有可能在多线程环境下调用\n    synchronized (this) {\n\n        // mNextBarrierToken 是 int 类型, token 实际上是通过发起同步屏障次数来表示的\n        final int token = mNextBarrierToken++;\n\n        // 注意到 Message 实例是通过 Message.obtain() 方法获取的, 分析见小节2.1\n        final Message msg = Message.obtain();\n        msg.markInUse();\n        msg.when = when;\n        msg.arg1 = token;\n\n        // 这里所做的就是按照消息执行时刻 when 排序, 将新建的 Message 实例插入到消息队列中对应的位置\n        // 注意到, 对于所以已在消息队列中的消息 p, 如果满足 p.when <= when, 则消息 p 排在新建的 Message 之前, 优先处理消息 p\n        Message prev = null;\n        Message p = mMessages;\n        if (when != 0) {\n            while (p != null && p.when <= when) {\n                prev = p;\n                p = p.next;\n            }\n        }\n        if (prev != null) { // invariant: p == prev.next\n            msg.next = p;\n            prev.next = msg;\n        } else {\n            msg.next = p;\n            mMessages = msg;\n        }\n\n        // 返回特定的 token, 用于取消同步屏障, 分析见[小节4]\n        return token;\n    }\n}\n```\n\n## 2.1 获取 Message 实例\n\n```java\nfinal Message msg = Message.obtain();\nmsg.markInUse();\nmsg.when = when;\nmsg.arg1 = token;\n```\n\nMessage 实例是通过 Message.obtain() 方法获取的，来看看这个方法：\n\n```java\npublic static Message obtain() {\n    synchronized (sPoolSync) {\n        if (sPool != null) {\n            Message m = sPool;\n            sPool = m.next;\n            m.next = null;\n            m.flags = 0; // clear in-use flag\n            sPoolSize--;\n            return m;\n        }\n    }\n    return new Message();\n}\n```\n\n从这个方法可以看出来，Message 实例是从缓存池中获取的，当缓存池没有可用的 Message 时，则新建一个 Message 对象。\n\n在获取到 Message 实例以后，将其标记为使用中，并设置 Message 的 when 和 arg1 属性。\n\n我们知道，Message 中有一个重要的属性 target，其类型为 Handler。当消息被消费时，用于处理该消息的 Handler 就是 message.target 指向的 Handler。\n\n但是，这里创建出的 Message 实例没有设置 target，也就是 message.target = null。\n\n\n\n## 2.2 小结\n\n通过上面的分析，我们知道发起同步屏障其实就是将一个**不带有 target 属性的 Message (接下来我将称之为同步屏障消息)** 按照执行时间的先后顺序插入到消息队列中。\n\n现在消息队列中已经存在这样一个独特的消息，接着就需要分析 Android 是如何处理这种消息的。\n\n\n\n# 3. 处理同步屏障消息\n\n在 Android Handler 机制中，Looper 负责将 Message 分发给目标 Handler，依靠的是 Looper::loop() 方法中不断执行的 for 循环 ，首先来分析这个方法是如何获取 Message。\n\n## 3.1 Looper::loop()\n\n```java\npublic static void loop() {\n    final Looper me = myLooper();\n\n    // 省略...\n\n    final MessageQueue queue = me.mQueue;\n\n    // 省略...\n\n    for (;;) {\n        Message msg = queue.next();\n\n        // 省略消息的处理过程\n    }\n}\n```\n\n从代码可以看出，Looper 其实是从 MessageQueue 不断取出 Message，然后再对 Message 进行处理的。\n\n接着来分析 MessageQueue::next() 方法，了解 Message 是怎么获取的。\n\n\n\n## 3.2 MessageQueue::next()\n\n为了分析处理同步屏障消息这种场景，现在假设所有的按时间顺序排在同步屏障消息之前的 Message 都已经被消费，换句话说，现在**位于消息队列头部**的 Message 就是同步屏障消息。\n\n```java\nMessage next() {\n    // 省略...\n\n    for (;;) {\n        // 省略...\n\n        synchronized (this) {\n            final long now = SystemClock.uptimeMillis();\n\n            Message prevMsg = null;\n\n            // mMessages 其实就是队列头部的 Message\n            Message msg = mMessages;\n\n            // 根据假设, 现在我们知道 msg 就是同步屏障消息, msg.target = null 成立, 会进入以下代码分支\n            if (msg != null && msg.target == null) {\n                // isAsynchronous() 方法可以判断一个 Message 是同步消息还是异步消息\n                // 这个循环目的是找出一个异步消息, 将其赋值给 msg\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n\n            if (msg != null) {\n                // 如果找到目标 Message, 则进入以下代码分支\n                if (now < msg.when) {\n                    // 当目标 Message 触发时间大于当前时间, 则设置下一次轮询的超时时长\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // 目标 Message 可以立即消费\n                    mBlocked = false;\n\n                    // 这里对消息队列的操作, 目的是将目标 Message 从消息队列中移除\n                    if (prevMsg != null) {\n                        // 注意到, 在处理同步屏障消息的场景下, prevMsg 不可能是 null, 同步屏障消息不会被消费\n                        // 在这里场景下, 被消费的总是异步消息\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n\n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    msg.markInUse();\n\n                    // 返回异步消息\n                    return msg;\n                }\n            } else {\n                // 队列中没有可以消费的异步消息\n                nextPollTimeoutMillis = -1;\n            }\n\n            // 省略...\n        }\n\n        // 省略...\n    }\n}\n```\n\n\n\n## 3.3 小结\n\n通过上面的分析，可以得出一些结论：\n\n- 同步屏障的目的是：阻塞消息队列中同步消息的消费，**只处理异步消息**。\n- 在发起同步屏障之后，由于在消息队列中的**同步屏障消息不会被自动消费**，必须手动移除同步屏障。\n- 在没有同步屏障的场景下，同步消息和异步消息在**从消息队列获取消息的过程**中没有区别。\n\n\n\n# 4. 移除同步屏障\n\n经过上面的分析，现在我们知道，在发起同步屏障之后，由于在消息队列中的**同步屏障消息不会被自动消费**，Android 提供了 MessageQueue::removeSyncBarrier(int) 方法让我们手动移除同步屏障，来看看这个方法做了什么。\n\n## 4.1 MessageQueue::removeSyncBarrier(int)\n\n```java\npublic void removeSyncBarrier(int token) {\n    // 注意到这里需要加锁进行操作, 因为 removeSyncBarrier(int) 方法是有可能在多线程环境下调用\n    synchronized (this) {\n        Message prev = null;\n\n      \t// mMessages 是位于队列头部的 Message\n        Message p = mMessages;\n\n      \t// 在发起同步屏障时, 新建 Message 实例的 arg1 属性存储的就是 token\n      \t// 所以这个循环的目的是: 找到 token 相等的同步屏障消息, 将其赋值给 p\n        while (p != null && (p.target != null || p.arg1 != token)) {\n            prev = p;\n            p = p.next;\n        }\n\n        if (p == null) {\n            // 在找不到目标同步屏障消息时, 会抛出异常\n            throw new IllegalStateException(\"The specified message queue synchronization \"\n                    + \" barrier token has not been posted or has already been removed.\");\n        }\n\n        final boolean needWake;\n\n      \t// 将目标同步屏障消息从消息队列中移除\n        if (prev != null) {\n            prev.next = p.next;\n            needWake = false;\n        } else {\n            mMessages = p.next;\n            needWake = mMessages == null || mMessages.target != null;\n        }\n        p.recycleUnchecked();\n\n        // 省略...\n    }\n}\n```\n\n\n\n## 4.2 小结\n\n从代码中可以看出，想要移除同步屏障，需要保存发起同步屏障 postSyncBarrier() 方法的返回值 token，根据 token 对应地移除同步屏障。\n\n\n","source":"_posts/2021-03-25-android-sync-barrier.md","raw":"---\ntitle: Android 同步屏障\ndate: 2021-03-25 15:34:53\ntags:\ncategories:\n- [Android, Framework, Handler]\n---\n\n在 Android 系统源码中，多处使用了同步屏障。例如：\n\n```java\n// ViewRootImpl.java\n\nvoid scheduleTraversals() {\n    if (!mTraversalScheduled) {\n        mTraversalScheduled = true;\n\n        // 发起同步屏障\n        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n\n        // 监听下一帧的信号\n        mChoreographer.postCallback(\n                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n\n        // 省略...\n    }\n}\n```\n\n这是 Android 屏幕刷新过程中的一个操作，在调用 postCallback(int, Runnable, Object) 方法监听下一帧信号之前，首先向当前线程的消息队列发起了同步屏障。\n\n接下来我们通过对源码的解读，分析出同步屏障的作用到底是什么。\n\n\n\n<!-- more -->\n\n# 1. Message 的种类\n\nMessage 中有一个 flag 变量，用于标记 Message 的类型。\n\n## 1.1 Message::setAsynchronous(boolean)\n\n```java\npublic void setAsynchronous(boolean async) {\n    if (async) {\n        // 异步消息, 通过或运算添加 FLAG_ASYNCHRONOUS 标记\n        flags |= FLAG_ASYNCHRONOUS;\n    } else {\n        // 同步消息, 通过与运算移除 FLAG_ASYNCHRONOUS 标记\n        flags &= ~FLAG_ASYNCHRONOUS;\n    }\n}\n```\n\n调用 setAsynchronous(boolean) 方法，可以将 Message 设置为**同步消息**或者**异步消息**。\n\n## 1.2 Message::isAsynchronous()\n\n```java\npublic boolean isAsynchronous() {\n    // 通过与运算判断 flags 是否带有 FLAG_ASYNCHRONOUS 标记\n    return (flags & FLAG_ASYNCHRONOUS) != 0;\n}\n```\n\n通过 isAsynchronous() 方法，可以判断 Message 是**同步消息**还是**异步消息**。\n\n由此可知，Message 可以分为两类：\n\n- 同步消息\n- 异步消息\n\n\n\n# 2. 发起同步屏障\n\n在屏幕刷新的例子中，同步屏障是通过调用 MessageQueue::postSyncBarrier() 方法发起的，实际上是间接调用了 MessageQueue::postSyncBarrier(long) 方法。\n\n```java\npublic int postSyncBarrier() {\n    return postSyncBarrier(SystemClock.uptimeMillis());\n}\n```\n\n这里传入的 SystemClock.uptimeMillis() 参数，表示了从系统启动到当前时刻经过的时间。\n\n```java\nprivate int postSyncBarrier(long when) {\n    // 注意到这里需要加锁进行操作, 因为 postSyncBarrier() 方法是有可能在多线程环境下调用\n    synchronized (this) {\n\n        // mNextBarrierToken 是 int 类型, token 实际上是通过发起同步屏障次数来表示的\n        final int token = mNextBarrierToken++;\n\n        // 注意到 Message 实例是通过 Message.obtain() 方法获取的, 分析见小节2.1\n        final Message msg = Message.obtain();\n        msg.markInUse();\n        msg.when = when;\n        msg.arg1 = token;\n\n        // 这里所做的就是按照消息执行时刻 when 排序, 将新建的 Message 实例插入到消息队列中对应的位置\n        // 注意到, 对于所以已在消息队列中的消息 p, 如果满足 p.when <= when, 则消息 p 排在新建的 Message 之前, 优先处理消息 p\n        Message prev = null;\n        Message p = mMessages;\n        if (when != 0) {\n            while (p != null && p.when <= when) {\n                prev = p;\n                p = p.next;\n            }\n        }\n        if (prev != null) { // invariant: p == prev.next\n            msg.next = p;\n            prev.next = msg;\n        } else {\n            msg.next = p;\n            mMessages = msg;\n        }\n\n        // 返回特定的 token, 用于取消同步屏障, 分析见[小节4]\n        return token;\n    }\n}\n```\n\n## 2.1 获取 Message 实例\n\n```java\nfinal Message msg = Message.obtain();\nmsg.markInUse();\nmsg.when = when;\nmsg.arg1 = token;\n```\n\nMessage 实例是通过 Message.obtain() 方法获取的，来看看这个方法：\n\n```java\npublic static Message obtain() {\n    synchronized (sPoolSync) {\n        if (sPool != null) {\n            Message m = sPool;\n            sPool = m.next;\n            m.next = null;\n            m.flags = 0; // clear in-use flag\n            sPoolSize--;\n            return m;\n        }\n    }\n    return new Message();\n}\n```\n\n从这个方法可以看出来，Message 实例是从缓存池中获取的，当缓存池没有可用的 Message 时，则新建一个 Message 对象。\n\n在获取到 Message 实例以后，将其标记为使用中，并设置 Message 的 when 和 arg1 属性。\n\n我们知道，Message 中有一个重要的属性 target，其类型为 Handler。当消息被消费时，用于处理该消息的 Handler 就是 message.target 指向的 Handler。\n\n但是，这里创建出的 Message 实例没有设置 target，也就是 message.target = null。\n\n\n\n## 2.2 小结\n\n通过上面的分析，我们知道发起同步屏障其实就是将一个**不带有 target 属性的 Message (接下来我将称之为同步屏障消息)** 按照执行时间的先后顺序插入到消息队列中。\n\n现在消息队列中已经存在这样一个独特的消息，接着就需要分析 Android 是如何处理这种消息的。\n\n\n\n# 3. 处理同步屏障消息\n\n在 Android Handler 机制中，Looper 负责将 Message 分发给目标 Handler，依靠的是 Looper::loop() 方法中不断执行的 for 循环 ，首先来分析这个方法是如何获取 Message。\n\n## 3.1 Looper::loop()\n\n```java\npublic static void loop() {\n    final Looper me = myLooper();\n\n    // 省略...\n\n    final MessageQueue queue = me.mQueue;\n\n    // 省略...\n\n    for (;;) {\n        Message msg = queue.next();\n\n        // 省略消息的处理过程\n    }\n}\n```\n\n从代码可以看出，Looper 其实是从 MessageQueue 不断取出 Message，然后再对 Message 进行处理的。\n\n接着来分析 MessageQueue::next() 方法，了解 Message 是怎么获取的。\n\n\n\n## 3.2 MessageQueue::next()\n\n为了分析处理同步屏障消息这种场景，现在假设所有的按时间顺序排在同步屏障消息之前的 Message 都已经被消费，换句话说，现在**位于消息队列头部**的 Message 就是同步屏障消息。\n\n```java\nMessage next() {\n    // 省略...\n\n    for (;;) {\n        // 省略...\n\n        synchronized (this) {\n            final long now = SystemClock.uptimeMillis();\n\n            Message prevMsg = null;\n\n            // mMessages 其实就是队列头部的 Message\n            Message msg = mMessages;\n\n            // 根据假设, 现在我们知道 msg 就是同步屏障消息, msg.target = null 成立, 会进入以下代码分支\n            if (msg != null && msg.target == null) {\n                // isAsynchronous() 方法可以判断一个 Message 是同步消息还是异步消息\n                // 这个循环目的是找出一个异步消息, 将其赋值给 msg\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n\n            if (msg != null) {\n                // 如果找到目标 Message, 则进入以下代码分支\n                if (now < msg.when) {\n                    // 当目标 Message 触发时间大于当前时间, 则设置下一次轮询的超时时长\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // 目标 Message 可以立即消费\n                    mBlocked = false;\n\n                    // 这里对消息队列的操作, 目的是将目标 Message 从消息队列中移除\n                    if (prevMsg != null) {\n                        // 注意到, 在处理同步屏障消息的场景下, prevMsg 不可能是 null, 同步屏障消息不会被消费\n                        // 在这里场景下, 被消费的总是异步消息\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n\n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    msg.markInUse();\n\n                    // 返回异步消息\n                    return msg;\n                }\n            } else {\n                // 队列中没有可以消费的异步消息\n                nextPollTimeoutMillis = -1;\n            }\n\n            // 省略...\n        }\n\n        // 省略...\n    }\n}\n```\n\n\n\n## 3.3 小结\n\n通过上面的分析，可以得出一些结论：\n\n- 同步屏障的目的是：阻塞消息队列中同步消息的消费，**只处理异步消息**。\n- 在发起同步屏障之后，由于在消息队列中的**同步屏障消息不会被自动消费**，必须手动移除同步屏障。\n- 在没有同步屏障的场景下，同步消息和异步消息在**从消息队列获取消息的过程**中没有区别。\n\n\n\n# 4. 移除同步屏障\n\n经过上面的分析，现在我们知道，在发起同步屏障之后，由于在消息队列中的**同步屏障消息不会被自动消费**，Android 提供了 MessageQueue::removeSyncBarrier(int) 方法让我们手动移除同步屏障，来看看这个方法做了什么。\n\n## 4.1 MessageQueue::removeSyncBarrier(int)\n\n```java\npublic void removeSyncBarrier(int token) {\n    // 注意到这里需要加锁进行操作, 因为 removeSyncBarrier(int) 方法是有可能在多线程环境下调用\n    synchronized (this) {\n        Message prev = null;\n\n      \t// mMessages 是位于队列头部的 Message\n        Message p = mMessages;\n\n      \t// 在发起同步屏障时, 新建 Message 实例的 arg1 属性存储的就是 token\n      \t// 所以这个循环的目的是: 找到 token 相等的同步屏障消息, 将其赋值给 p\n        while (p != null && (p.target != null || p.arg1 != token)) {\n            prev = p;\n            p = p.next;\n        }\n\n        if (p == null) {\n            // 在找不到目标同步屏障消息时, 会抛出异常\n            throw new IllegalStateException(\"The specified message queue synchronization \"\n                    + \" barrier token has not been posted or has already been removed.\");\n        }\n\n        final boolean needWake;\n\n      \t// 将目标同步屏障消息从消息队列中移除\n        if (prev != null) {\n            prev.next = p.next;\n            needWake = false;\n        } else {\n            mMessages = p.next;\n            needWake = mMessages == null || mMessages.target != null;\n        }\n        p.recycleUnchecked();\n\n        // 省略...\n    }\n}\n```\n\n\n\n## 4.2 小结\n\n从代码中可以看出，想要移除同步屏障，需要保存发起同步屏障 postSyncBarrier() 方法的返回值 token，根据 token 对应地移除同步屏障。\n\n\n","slug":"android-sync-barrier","published":1,"updated":"2021-03-26T13:15:06.555Z","_id":"ckmsyc4rg000d5nprei90h7bk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在 Android 系统源码中，多处使用了同步屏障。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ViewRootImpl.java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTraversals</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mTraversalScheduled) &#123;</span><br><span class=\"line\">        mTraversalScheduled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发起同步屏障</span></span><br><span class=\"line\">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 监听下一帧的信号</span></span><br><span class=\"line\">        mChoreographer.postCallback(</span><br><span class=\"line\">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 省略...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是 Android 屏幕刷新过程中的一个操作，在调用 postCallback(int, Runnable, Object) 方法监听下一帧信号之前，首先向当前线程的消息队列发起了同步屏障。</p>\n<p>接下来我们通过对源码的解读，分析出同步屏障的作用到底是什么。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"1-Message-的种类\"><a href=\"#1-Message-的种类\" class=\"headerlink\" title=\"1. Message 的种类\"></a>1. Message 的种类</h1><p>Message 中有一个 flag 变量，用于标记 Message 的类型。</p>\n<h2 id=\"1-1-Message-setAsynchronous-boolean\"><a href=\"#1-1-Message-setAsynchronous-boolean\" class=\"headerlink\" title=\"1.1 Message::setAsynchronous(boolean)\"></a>1.1 Message::setAsynchronous(boolean)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAsynchronous</span><span class=\"params\">(<span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (async) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 异步消息, 通过或运算添加 FLAG_ASYNCHRONOUS 标记</span></span><br><span class=\"line\">        flags |= FLAG_ASYNCHRONOUS;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 同步消息, 通过与运算移除 FLAG_ASYNCHRONOUS 标记</span></span><br><span class=\"line\">        flags &amp;= ~FLAG_ASYNCHRONOUS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用 setAsynchronous(boolean) 方法，可以将 Message 设置为<strong>同步消息</strong>或者<strong>异步消息</strong>。</p>\n<h2 id=\"1-2-Message-isAsynchronous\"><a href=\"#1-2-Message-isAsynchronous\" class=\"headerlink\" title=\"1.2 Message::isAsynchronous()\"></a>1.2 Message::isAsynchronous()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAsynchronous</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过与运算判断 flags 是否带有 FLAG_ASYNCHRONOUS 标记</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (flags &amp; FLAG_ASYNCHRONOUS) != <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 isAsynchronous() 方法，可以判断 Message 是<strong>同步消息</strong>还是<strong>异步消息</strong>。</p>\n<p>由此可知，Message 可以分为两类：</p>\n<ul>\n<li>同步消息</li>\n<li>异步消息</li>\n</ul>\n<h1 id=\"2-发起同步屏障\"><a href=\"#2-发起同步屏障\" class=\"headerlink\" title=\"2. 发起同步屏障\"></a>2. 发起同步屏障</h1><p>在屏幕刷新的例子中，同步屏障是通过调用 MessageQueue::postSyncBarrier() 方法发起的，实际上是间接调用了 MessageQueue::postSyncBarrier(long) 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里传入的 SystemClock.uptimeMillis() 参数，表示了从系统启动到当前时刻经过的时间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意到这里需要加锁进行操作, 因为 postSyncBarrier() 方法是有可能在多线程环境下调用</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// mNextBarrierToken 是 int 类型, token 实际上是通过发起同步屏障次数来表示的</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> token = mNextBarrierToken++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 注意到 Message 实例是通过 Message.obtain() 方法获取的, 分析见小节2.1</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Message msg = Message.obtain();</span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        msg.arg1 = token;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这里所做的就是按照消息执行时刻 when 排序, 将新建的 Message 实例插入到消息队列中对应的位置</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意到, 对于所以已在消息队列中的消息 p, 如果满足 p.when &lt;= when, 则消息 p 排在新建的 Message 之前, 优先处理消息 p</span></span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (when != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 返回特定的 token, 用于取消同步屏障, 分析见[小节4]</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-1-获取-Message-实例\"><a href=\"#2-1-获取-Message-实例\" class=\"headerlink\" title=\"2.1 获取 Message 实例\"></a>2.1 获取 Message 实例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Message msg = Message.obtain();</span><br><span class=\"line\">msg.markInUse();</span><br><span class=\"line\">msg.when = when;</span><br><span class=\"line\">msg.arg1 = token;</span><br></pre></td></tr></table></figure>\n<p>Message 实例是通过 Message.obtain() 方法获取的，来看看这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Message <span class=\"title\">obtain</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPool != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Message m = sPool;</span><br><span class=\"line\">            sPool = m.next;</span><br><span class=\"line\">            m.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            m.flags = <span class=\"number\">0</span>; <span class=\"comment\">// clear in-use flag</span></span><br><span class=\"line\">            sPoolSize--;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Message();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这个方法可以看出来，Message 实例是从缓存池中获取的，当缓存池没有可用的 Message 时，则新建一个 Message 对象。</p>\n<p>在获取到 Message 实例以后，将其标记为使用中，并设置 Message 的 when 和 arg1 属性。</p>\n<p>我们知道，Message 中有一个重要的属性 target，其类型为 Handler。当消息被消费时，用于处理该消息的 Handler 就是 message.target 指向的 Handler。</p>\n<p>但是，这里创建出的 Message 实例没有设置 target，也就是 message.target = null。</p>\n<h2 id=\"2-2-小结\"><a href=\"#2-2-小结\" class=\"headerlink\" title=\"2.2 小结\"></a>2.2 小结</h2><p>通过上面的分析，我们知道发起同步屏障其实就是将一个<strong>不带有 target 属性的 Message (接下来我将称之为同步屏障消息)</strong> 按照执行时间的先后顺序插入到消息队列中。</p>\n<p>现在消息队列中已经存在这样一个独特的消息，接着就需要分析 Android 是如何处理这种消息的。</p>\n<h1 id=\"3-处理同步屏障消息\"><a href=\"#3-处理同步屏障消息\" class=\"headerlink\" title=\"3. 处理同步屏障消息\"></a>3. 处理同步屏障消息</h1><p>在 Android Handler 机制中，Looper 负责将 Message 分发给目标 Handler，依靠的是 Looper::loop() 方法中不断执行的 for 循环 ，首先来分析这个方法是如何获取 Message。</p>\n<h2 id=\"3-1-Looper-loop\"><a href=\"#3-1-Looper-loop\" class=\"headerlink\" title=\"3.1 Looper::loop()\"></a>3.1 Looper::loop()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 省略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 省略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Message msg = queue.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 省略消息的处理过程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码可以看出，Looper 其实是从 MessageQueue 不断取出 Message，然后再对 Message 进行处理的。</p>\n<p>接着来分析 MessageQueue::next() 方法，了解 Message 是怎么获取的。</p>\n<h2 id=\"3-2-MessageQueue-next\"><a href=\"#3-2-MessageQueue-next\" class=\"headerlink\" title=\"3.2 MessageQueue::next()\"></a>3.2 MessageQueue::next()</h2><p>为了分析处理同步屏障消息这种场景，现在假设所有的按时间顺序排在同步屏障消息之前的 Message 都已经被消费，换句话说，现在<strong>位于消息队列头部</strong>的 Message 就是同步屏障消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 省略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// mMessages 其实就是队列头部的 Message</span></span><br><span class=\"line\">            Message msg = mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 根据假设, 现在我们知道 msg 就是同步屏障消息, msg.target = null 成立, 会进入以下代码分支</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// isAsynchronous() 方法可以判断一个 Message 是同步消息还是异步消息</span></span><br><span class=\"line\">                <span class=\"comment\">// 这个循环目的是找出一个异步消息, 将其赋值给 msg</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    prevMsg = msg;</span><br><span class=\"line\">                    msg = msg.next;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果找到目标 Message, 则进入以下代码分支</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 当目标 Message 触发时间大于当前时间, 则设置下一次轮询的超时时长</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 目标 Message 可以立即消费</span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 这里对消息队列的操作, 目的是将目标 Message 从消息队列中移除</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 注意到, 在处理同步屏障消息的场景下, prevMsg 不可能是 null, 同步屏障消息不会被消费</span></span><br><span class=\"line\">                        <span class=\"comment\">// 在这里场景下, 被消费的总是异步消息</span></span><br><span class=\"line\">                        prevMsg.next = msg.next;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        mMessages = msg.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;Returning message: &quot;</span> + msg);</span><br><span class=\"line\">                    msg.markInUse();</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 返回异步消息</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列中没有可以消费的异步消息</span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 省略...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 省略...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"3-3-小结\"><a href=\"#3-3-小结\" class=\"headerlink\" title=\"3.3 小结\"></a>3.3 小结</h2><p>通过上面的分析，可以得出一些结论：</p>\n<ul>\n<li>同步屏障的目的是：阻塞消息队列中同步消息的消费，<strong>只处理异步消息</strong>。</li>\n<li>在发起同步屏障之后，由于在消息队列中的<strong>同步屏障消息不会被自动消费</strong>，必须手动移除同步屏障。</li>\n<li>在没有同步屏障的场景下，同步消息和异步消息在<strong>从消息队列获取消息的过程</strong>中没有区别。</li>\n</ul>\n<h1 id=\"4-移除同步屏障\"><a href=\"#4-移除同步屏障\" class=\"headerlink\" title=\"4. 移除同步屏障\"></a>4. 移除同步屏障</h1><p>经过上面的分析，现在我们知道，在发起同步屏障之后，由于在消息队列中的<strong>同步屏障消息不会被自动消费</strong>，Android 提供了 MessageQueue::removeSyncBarrier(int) 方法让我们手动移除同步屏障，来看看这个方法做了什么。</p>\n<h2 id=\"4-1-MessageQueue-removeSyncBarrier-int\"><a href=\"#4-1-MessageQueue-removeSyncBarrier-int\" class=\"headerlink\" title=\"4.1 MessageQueue::removeSyncBarrier(int)\"></a>4.1 MessageQueue::removeSyncBarrier(int)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">int</span> token)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意到这里需要加锁进行操作, 因为 removeSyncBarrier(int) 方法是有可能在多线程环境下调用</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// mMessages 是位于队列头部的 Message</span></span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 在发起同步屏障时, 新建 Message 实例的 arg1 属性存储的就是 token</span></span><br><span class=\"line\">      \t<span class=\"comment\">// 所以这个循环的目的是: 找到 token 相等的同步屏障消息, 将其赋值给 p</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (p.target != <span class=\"keyword\">null</span> || p.arg1 != token)) &#123;</span><br><span class=\"line\">            prev = p;</span><br><span class=\"line\">            p = p.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在找不到目标同步屏障消息时, 会抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;The specified message queue synchronization &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 将目标同步屏障消息从消息队列中移除</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            prev.next = p.next;</span><br><span class=\"line\">            needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mMessages = p.next;</span><br><span class=\"line\">            needWake = mMessages == <span class=\"keyword\">null</span> || mMessages.target != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p.recycleUnchecked();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 省略...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"4-2-小结\"><a href=\"#4-2-小结\" class=\"headerlink\" title=\"4.2 小结\"></a>4.2 小结</h2><p>从代码中可以看出，想要移除同步屏障，需要保存发起同步屏障 postSyncBarrier() 方法的返回值 token，根据 token 对应地移除同步屏障。</p>\n","site":{"data":{}},"excerpt":"<p>在 Android 系统源码中，多处使用了同步屏障。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ViewRootImpl.java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTraversals</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mTraversalScheduled) &#123;</span><br><span class=\"line\">        mTraversalScheduled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发起同步屏障</span></span><br><span class=\"line\">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 监听下一帧的信号</span></span><br><span class=\"line\">        mChoreographer.postCallback(</span><br><span class=\"line\">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 省略...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是 Android 屏幕刷新过程中的一个操作，在调用 postCallback(int, Runnable, Object) 方法监听下一帧信号之前，首先向当前线程的消息队列发起了同步屏障。</p>\n<p>接下来我们通过对源码的解读，分析出同步屏障的作用到底是什么。</p>","more":"<h1 id=\"1-Message-的种类\"><a href=\"#1-Message-的种类\" class=\"headerlink\" title=\"1. Message 的种类\"></a>1. Message 的种类</h1><p>Message 中有一个 flag 变量，用于标记 Message 的类型。</p>\n<h2 id=\"1-1-Message-setAsynchronous-boolean\"><a href=\"#1-1-Message-setAsynchronous-boolean\" class=\"headerlink\" title=\"1.1 Message::setAsynchronous(boolean)\"></a>1.1 Message::setAsynchronous(boolean)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAsynchronous</span><span class=\"params\">(<span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (async) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 异步消息, 通过或运算添加 FLAG_ASYNCHRONOUS 标记</span></span><br><span class=\"line\">        flags |= FLAG_ASYNCHRONOUS;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 同步消息, 通过与运算移除 FLAG_ASYNCHRONOUS 标记</span></span><br><span class=\"line\">        flags &amp;= ~FLAG_ASYNCHRONOUS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用 setAsynchronous(boolean) 方法，可以将 Message 设置为<strong>同步消息</strong>或者<strong>异步消息</strong>。</p>\n<h2 id=\"1-2-Message-isAsynchronous\"><a href=\"#1-2-Message-isAsynchronous\" class=\"headerlink\" title=\"1.2 Message::isAsynchronous()\"></a>1.2 Message::isAsynchronous()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAsynchronous</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过与运算判断 flags 是否带有 FLAG_ASYNCHRONOUS 标记</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (flags &amp; FLAG_ASYNCHRONOUS) != <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 isAsynchronous() 方法，可以判断 Message 是<strong>同步消息</strong>还是<strong>异步消息</strong>。</p>\n<p>由此可知，Message 可以分为两类：</p>\n<ul>\n<li>同步消息</li>\n<li>异步消息</li>\n</ul>\n<h1 id=\"2-发起同步屏障\"><a href=\"#2-发起同步屏障\" class=\"headerlink\" title=\"2. 发起同步屏障\"></a>2. 发起同步屏障</h1><p>在屏幕刷新的例子中，同步屏障是通过调用 MessageQueue::postSyncBarrier() 方法发起的，实际上是间接调用了 MessageQueue::postSyncBarrier(long) 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里传入的 SystemClock.uptimeMillis() 参数，表示了从系统启动到当前时刻经过的时间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意到这里需要加锁进行操作, 因为 postSyncBarrier() 方法是有可能在多线程环境下调用</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// mNextBarrierToken 是 int 类型, token 实际上是通过发起同步屏障次数来表示的</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> token = mNextBarrierToken++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 注意到 Message 实例是通过 Message.obtain() 方法获取的, 分析见小节2.1</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Message msg = Message.obtain();</span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        msg.arg1 = token;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这里所做的就是按照消息执行时刻 when 排序, 将新建的 Message 实例插入到消息队列中对应的位置</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意到, 对于所以已在消息队列中的消息 p, 如果满足 p.when &lt;= when, 则消息 p 排在新建的 Message 之前, 优先处理消息 p</span></span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (when != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 返回特定的 token, 用于取消同步屏障, 分析见[小节4]</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-1-获取-Message-实例\"><a href=\"#2-1-获取-Message-实例\" class=\"headerlink\" title=\"2.1 获取 Message 实例\"></a>2.1 获取 Message 实例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Message msg = Message.obtain();</span><br><span class=\"line\">msg.markInUse();</span><br><span class=\"line\">msg.when = when;</span><br><span class=\"line\">msg.arg1 = token;</span><br></pre></td></tr></table></figure>\n<p>Message 实例是通过 Message.obtain() 方法获取的，来看看这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Message <span class=\"title\">obtain</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sPool != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Message m = sPool;</span><br><span class=\"line\">            sPool = m.next;</span><br><span class=\"line\">            m.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            m.flags = <span class=\"number\">0</span>; <span class=\"comment\">// clear in-use flag</span></span><br><span class=\"line\">            sPoolSize--;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Message();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这个方法可以看出来，Message 实例是从缓存池中获取的，当缓存池没有可用的 Message 时，则新建一个 Message 对象。</p>\n<p>在获取到 Message 实例以后，将其标记为使用中，并设置 Message 的 when 和 arg1 属性。</p>\n<p>我们知道，Message 中有一个重要的属性 target，其类型为 Handler。当消息被消费时，用于处理该消息的 Handler 就是 message.target 指向的 Handler。</p>\n<p>但是，这里创建出的 Message 实例没有设置 target，也就是 message.target = null。</p>\n<h2 id=\"2-2-小结\"><a href=\"#2-2-小结\" class=\"headerlink\" title=\"2.2 小结\"></a>2.2 小结</h2><p>通过上面的分析，我们知道发起同步屏障其实就是将一个<strong>不带有 target 属性的 Message (接下来我将称之为同步屏障消息)</strong> 按照执行时间的先后顺序插入到消息队列中。</p>\n<p>现在消息队列中已经存在这样一个独特的消息，接着就需要分析 Android 是如何处理这种消息的。</p>\n<h1 id=\"3-处理同步屏障消息\"><a href=\"#3-处理同步屏障消息\" class=\"headerlink\" title=\"3. 处理同步屏障消息\"></a>3. 处理同步屏障消息</h1><p>在 Android Handler 机制中，Looper 负责将 Message 分发给目标 Handler，依靠的是 Looper::loop() 方法中不断执行的 for 循环 ，首先来分析这个方法是如何获取 Message。</p>\n<h2 id=\"3-1-Looper-loop\"><a href=\"#3-1-Looper-loop\" class=\"headerlink\" title=\"3.1 Looper::loop()\"></a>3.1 Looper::loop()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 省略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 省略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Message msg = queue.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 省略消息的处理过程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码可以看出，Looper 其实是从 MessageQueue 不断取出 Message，然后再对 Message 进行处理的。</p>\n<p>接着来分析 MessageQueue::next() 方法，了解 Message 是怎么获取的。</p>\n<h2 id=\"3-2-MessageQueue-next\"><a href=\"#3-2-MessageQueue-next\" class=\"headerlink\" title=\"3.2 MessageQueue::next()\"></a>3.2 MessageQueue::next()</h2><p>为了分析处理同步屏障消息这种场景，现在假设所有的按时间顺序排在同步屏障消息之前的 Message 都已经被消费，换句话说，现在<strong>位于消息队列头部</strong>的 Message 就是同步屏障消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 省略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// mMessages 其实就是队列头部的 Message</span></span><br><span class=\"line\">            Message msg = mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 根据假设, 现在我们知道 msg 就是同步屏障消息, msg.target = null 成立, 会进入以下代码分支</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// isAsynchronous() 方法可以判断一个 Message 是同步消息还是异步消息</span></span><br><span class=\"line\">                <span class=\"comment\">// 这个循环目的是找出一个异步消息, 将其赋值给 msg</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    prevMsg = msg;</span><br><span class=\"line\">                    msg = msg.next;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果找到目标 Message, 则进入以下代码分支</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 当目标 Message 触发时间大于当前时间, 则设置下一次轮询的超时时长</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 目标 Message 可以立即消费</span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 这里对消息队列的操作, 目的是将目标 Message 从消息队列中移除</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 注意到, 在处理同步屏障消息的场景下, prevMsg 不可能是 null, 同步屏障消息不会被消费</span></span><br><span class=\"line\">                        <span class=\"comment\">// 在这里场景下, 被消费的总是异步消息</span></span><br><span class=\"line\">                        prevMsg.next = msg.next;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        mMessages = msg.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;Returning message: &quot;</span> + msg);</span><br><span class=\"line\">                    msg.markInUse();</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 返回异步消息</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列中没有可以消费的异步消息</span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 省略...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 省略...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"3-3-小结\"><a href=\"#3-3-小结\" class=\"headerlink\" title=\"3.3 小结\"></a>3.3 小结</h2><p>通过上面的分析，可以得出一些结论：</p>\n<ul>\n<li>同步屏障的目的是：阻塞消息队列中同步消息的消费，<strong>只处理异步消息</strong>。</li>\n<li>在发起同步屏障之后，由于在消息队列中的<strong>同步屏障消息不会被自动消费</strong>，必须手动移除同步屏障。</li>\n<li>在没有同步屏障的场景下，同步消息和异步消息在<strong>从消息队列获取消息的过程</strong>中没有区别。</li>\n</ul>\n<h1 id=\"4-移除同步屏障\"><a href=\"#4-移除同步屏障\" class=\"headerlink\" title=\"4. 移除同步屏障\"></a>4. 移除同步屏障</h1><p>经过上面的分析，现在我们知道，在发起同步屏障之后，由于在消息队列中的<strong>同步屏障消息不会被自动消费</strong>，Android 提供了 MessageQueue::removeSyncBarrier(int) 方法让我们手动移除同步屏障，来看看这个方法做了什么。</p>\n<h2 id=\"4-1-MessageQueue-removeSyncBarrier-int\"><a href=\"#4-1-MessageQueue-removeSyncBarrier-int\" class=\"headerlink\" title=\"4.1 MessageQueue::removeSyncBarrier(int)\"></a>4.1 MessageQueue::removeSyncBarrier(int)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">int</span> token)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意到这里需要加锁进行操作, 因为 removeSyncBarrier(int) 方法是有可能在多线程环境下调用</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// mMessages 是位于队列头部的 Message</span></span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 在发起同步屏障时, 新建 Message 实例的 arg1 属性存储的就是 token</span></span><br><span class=\"line\">      \t<span class=\"comment\">// 所以这个循环的目的是: 找到 token 相等的同步屏障消息, 将其赋值给 p</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (p.target != <span class=\"keyword\">null</span> || p.arg1 != token)) &#123;</span><br><span class=\"line\">            prev = p;</span><br><span class=\"line\">            p = p.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在找不到目标同步屏障消息时, 会抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;The specified message queue synchronization &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 将目标同步屏障消息从消息队列中移除</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            prev.next = p.next;</span><br><span class=\"line\">            needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mMessages = p.next;</span><br><span class=\"line\">            needWake = mMessages == <span class=\"keyword\">null</span> || mMessages.target != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p.recycleUnchecked();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 省略...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"4-2-小结\"><a href=\"#4-2-小结\" class=\"headerlink\" title=\"4.2 小结\"></a>4.2 小结</h2><p>从代码中可以看出，想要移除同步屏障，需要保存发起同步屏障 postSyncBarrier() 方法的返回值 token，根据 token 对应地移除同步屏障。</p>"},{"title":"TCP 建立连接和终止连接的过程","_content":"\n\n\n![zhihu_xiaolincoding_ans_p1](tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p1.jpg)\n\n![zhihu_xiaolincoding_ans_p2](tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p2.jpg)\n\n![zhihu_xiaolincoding_ans_p3](tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p3.jpg)\n\n![zhihu_xiaolincoding_ans_p4](tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p4.jpg)\n\n\n## 为什么结束过程需要四次挥手\nhttps://www.zhihu.com/question/63264012/answer/298264454\n\n因为TCP是全双工通信的\n（1）第一次挥手     因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。    （2）第二次挥手     被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。   \n（3）第三次挥手    被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。   \n（4）第四挥手    如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。\n\nack是为了让对方闭嘴。结束，1)A不停的说,我想结束，不再发了。2)B收到后，但是还有数据没处理完，就发ack让A闭嘴。等我处理完再说。3)B终于处理完了，不停对A说，满足你结束吧。4)A知道B要结束了，给B说，可以闭嘴了，我结束。B收到结束，不再发送确认，进入关闭态\n\n请问下如果第四次挥手没有会怎么样，反正此时双方已经发送完数据了，直接结束连接不就行了，为什么还需要再次确认呢？\n进行第四次挥手，是要确保被动方的第三次挥手一定是被主动方接收到了（个人理解）\n如果没有第四次挥手，被动方不知道主动方有没有收到被动方发送的fin=1，也就一直不能断开\n被动方还会一直发送我这边处理完数据了，已经要关闭了\ntcp中是一定要回复的，这是可靠传输的保证，没收到就会一直重发。[大笑]\n\n\n# 参考\n\n[Transmission_Control_Protocol](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_establishment)\n\n[socket编程到底是什么 ](https://www.zhihu.com/question/29637351/answer/1934423848)\n\n","source":"_drafts/tcp-connection-establishment-and-termination.md","raw":"---\ntitle: TCP 建立连接和终止连接的过程\ntags:\n---\n\n\n\n![zhihu_xiaolincoding_ans_p1](tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p1.jpg)\n\n![zhihu_xiaolincoding_ans_p2](tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p2.jpg)\n\n![zhihu_xiaolincoding_ans_p3](tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p3.jpg)\n\n![zhihu_xiaolincoding_ans_p4](tcp-connection-establishment-and-termination/zhihu_xiaolincoding_ans_p4.jpg)\n\n\n## 为什么结束过程需要四次挥手\nhttps://www.zhihu.com/question/63264012/answer/298264454\n\n因为TCP是全双工通信的\n（1）第一次挥手     因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。    （2）第二次挥手     被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。   \n（3）第三次挥手    被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。   \n（4）第四挥手    如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。\n\nack是为了让对方闭嘴。结束，1)A不停的说,我想结束，不再发了。2)B收到后，但是还有数据没处理完，就发ack让A闭嘴。等我处理完再说。3)B终于处理完了，不停对A说，满足你结束吧。4)A知道B要结束了，给B说，可以闭嘴了，我结束。B收到结束，不再发送确认，进入关闭态\n\n请问下如果第四次挥手没有会怎么样，反正此时双方已经发送完数据了，直接结束连接不就行了，为什么还需要再次确认呢？\n进行第四次挥手，是要确保被动方的第三次挥手一定是被主动方接收到了（个人理解）\n如果没有第四次挥手，被动方不知道主动方有没有收到被动方发送的fin=1，也就一直不能断开\n被动方还会一直发送我这边处理完数据了，已经要关闭了\ntcp中是一定要回复的，这是可靠传输的保证，没收到就会一直重发。[大笑]\n\n\n# 参考\n\n[Transmission_Control_Protocol](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_establishment)\n\n[socket编程到底是什么 ](https://www.zhihu.com/question/29637351/answer/1934423848)\n\n","slug":"tcp-connection-establishment-and-termination","published":0,"date":"2021-08-11T08:19:13.862Z","updated":"2021-11-09T12:19:56.518Z","_id":"cks78k24o0000i4prf8971erh","comments":1,"layout":"post","photos":[],"link":"","content":"\n\n\n\n\n\n\n\n\n<h2 id=\"为什么结束过程需要四次挥手\"><a href=\"#为什么结束过程需要四次挥手\" class=\"headerlink\" title=\"为什么结束过程需要四次挥手\"></a>为什么结束过程需要四次挥手</h2><p><a href=\"https://www.zhihu.com/question/63264012/answer/298264454\">https://www.zhihu.com/question/63264012/answer/298264454</a></p>\n<p>因为TCP是全双工通信的<br>（1）第一次挥手     因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。    （2）第二次挥手     被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。<br>（3）第三次挥手    被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。<br>（4）第四挥手    如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。</p>\n<p>ack是为了让对方闭嘴。结束，1)A不停的说,我想结束，不再发了。2)B收到后，但是还有数据没处理完，就发ack让A闭嘴。等我处理完再说。3)B终于处理完了，不停对A说，满足你结束吧。4)A知道B要结束了，给B说，可以闭嘴了，我结束。B收到结束，不再发送确认，进入关闭态</p>\n<p>请问下如果第四次挥手没有会怎么样，反正此时双方已经发送完数据了，直接结束连接不就行了，为什么还需要再次确认呢？<br>进行第四次挥手，是要确保被动方的第三次挥手一定是被主动方接收到了（个人理解）<br>如果没有第四次挥手，被动方不知道主动方有没有收到被动方发送的fin=1，也就一直不能断开<br>被动方还会一直发送我这边处理完数据了，已经要关闭了<br>tcp中是一定要回复的，这是可靠传输的保证，没收到就会一直重发。[大笑]</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_establishment\">Transmission_Control_Protocol</a></p>\n<p><a href=\"https://www.zhihu.com/question/29637351/answer/1934423848\">socket编程到底是什么 </a></p>\n","site":{"data":{}},"excerpt":"","more":"\n\n\n\n\n\n\n\n\n<h2 id=\"为什么结束过程需要四次挥手\"><a href=\"#为什么结束过程需要四次挥手\" class=\"headerlink\" title=\"为什么结束过程需要四次挥手\"></a>为什么结束过程需要四次挥手</h2><p><a href=\"https://www.zhihu.com/question/63264012/answer/298264454\">https://www.zhihu.com/question/63264012/answer/298264454</a></p>\n<p>因为TCP是全双工通信的<br>（1）第一次挥手     因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。    （2）第二次挥手     被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。<br>（3）第三次挥手    被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。<br>（4）第四挥手    如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。</p>\n<p>ack是为了让对方闭嘴。结束，1)A不停的说,我想结束，不再发了。2)B收到后，但是还有数据没处理完，就发ack让A闭嘴。等我处理完再说。3)B终于处理完了，不停对A说，满足你结束吧。4)A知道B要结束了，给B说，可以闭嘴了，我结束。B收到结束，不再发送确认，进入关闭态</p>\n<p>请问下如果第四次挥手没有会怎么样，反正此时双方已经发送完数据了，直接结束连接不就行了，为什么还需要再次确认呢？<br>进行第四次挥手，是要确保被动方的第三次挥手一定是被主动方接收到了（个人理解）<br>如果没有第四次挥手，被动方不知道主动方有没有收到被动方发送的fin=1，也就一直不能断开<br>被动方还会一直发送我这边处理完数据了，已经要关闭了<br>tcp中是一定要回复的，这是可靠传输的保证，没收到就会一直重发。[大笑]</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_establishment\">Transmission_Control_Protocol</a></p>\n<p><a href=\"https://www.zhihu.com/question/29637351/answer/1934423848\">socket编程到底是什么 </a></p>\n"},{"title":"文件描述符","date":"2021-08-16T09:45:00.000Z","_content":"\n\n\n# 概述\n\n在 Unix 和类 Unix 的操作系统上，文件描述符 (file descriptor) 用来指向文件或者输入输出的资源。\n\n文件描述符通常有一个非负的整数数值，负值则用来表示空态或者错误状态。\n\n在 Linux 系统中，一切都看做是文件，文件又可分为: 普通文件、目录文件、链接文件和设备文件。\n\n当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行 I/O 操作的系统调用都会通过文件描述符。\n\n\n\n### 系统为维护文件描述符，建立了三个表\n\n- 进程级的文件描述符表\n- 系统级的文件描述符表\n- 文件系统的 i-node 表\n\n\n\n### inode\n\n#### inode是什么？\n\n理解inode，要从文件储存说起。\n\n文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。\n\n操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。\n\n文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。\n\n每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。\n\n#### inode的内容\n\ninode包含文件的元信息，具体来说有以下内容：\n\n- 文件的字节数\n- 文件拥有者的User ID\n- 文件的Group ID\n- 文件的读、写、执行权限\n- 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。\n- 链接数，即有多少文件名指向这个inode\n- 文件数据block的位置\n\n可以用 `stat` 命令，查看某个文件的inode信息。\n\n总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。\n\n#### inode的大小\n\ninode 也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。\n\n每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。\n\n查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。\n\n```shell\ndf -i\n```\n\n\n\n查看每个inode节点的大小，可以用如下命令：\n\n```\nsudo dumpe2fs -h /dev/hda | grep \"Inode size\"\n```\n\n由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。\n\n#### inode号码\n\n每个inode都有一个号码，操作系统用inode号码来识别不同的文件。\n\n这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。\n\n表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。\n\n使用 `ls -i` 命令，可以看到文件名对应的inode号码。\n\n#### 目录文件\n\nUnix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。\n\n目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。\n\nls命令只列出目录文件中的所有文件名：\n\n```\nls /etc\n```\n\nls -i命令列出整个目录文件，即文件名和inode号码：\n\n```\nls -i /etc\n```\n\n如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。\n\n```\nls -l /etc\n```\n\n理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。\n\n\n\n### 硬链接\n\n一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。\n\n这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。\n\nln命令可以创建硬链接：\n\n```\nln 源文件 目标文件\n```\n\n运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。\n\n反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。\n\n这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）。\n\n\n\n### 软链接\n\n除了硬链接以外，还有一种特殊情况。\n\n文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。\n\n这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。\n\n**ln -s命令可以创建软链接**。\n\n```\nln -s 源文文件或目录 目标文件或目录\n```\n\n\n\n### inode的特殊作用\n\n由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。\n\n- 有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。\n- 移动文件或重命名文件，只是改变文件名，不影响inode号码。\n- 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。\n\n第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。\n\n\n\n# 参考\n\n[理解Linux的文件描述符FD与Inode](https://zhuanlan.zhihu.com/p/143430585)\n\n[文件描述符（File Descriptor）简介](https://segmentfault.com/a/1190000009724931)\n\n[每天进步一点点——Linux中的文件描述符与打开文件之间的关系](http://blog.csdn.net/cywosp/article/details/38965239)\n\n[File descriptor](https://en.wikipedia.org/wiki/File_descriptor)\n\n","source":"_drafts/understand-file-descriptor.md","raw":"---\ntitle: 文件描述符\ndate: 2021-08-16 17:45:00\ncategories:\n- [Linux]\n---\n\n\n\n# 概述\n\n在 Unix 和类 Unix 的操作系统上，文件描述符 (file descriptor) 用来指向文件或者输入输出的资源。\n\n文件描述符通常有一个非负的整数数值，负值则用来表示空态或者错误状态。\n\n在 Linux 系统中，一切都看做是文件，文件又可分为: 普通文件、目录文件、链接文件和设备文件。\n\n当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行 I/O 操作的系统调用都会通过文件描述符。\n\n\n\n### 系统为维护文件描述符，建立了三个表\n\n- 进程级的文件描述符表\n- 系统级的文件描述符表\n- 文件系统的 i-node 表\n\n\n\n### inode\n\n#### inode是什么？\n\n理解inode，要从文件储存说起。\n\n文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。\n\n操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。\n\n文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。\n\n每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。\n\n#### inode的内容\n\ninode包含文件的元信息，具体来说有以下内容：\n\n- 文件的字节数\n- 文件拥有者的User ID\n- 文件的Group ID\n- 文件的读、写、执行权限\n- 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。\n- 链接数，即有多少文件名指向这个inode\n- 文件数据block的位置\n\n可以用 `stat` 命令，查看某个文件的inode信息。\n\n总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。\n\n#### inode的大小\n\ninode 也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。\n\n每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。\n\n查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。\n\n```shell\ndf -i\n```\n\n\n\n查看每个inode节点的大小，可以用如下命令：\n\n```\nsudo dumpe2fs -h /dev/hda | grep \"Inode size\"\n```\n\n由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。\n\n#### inode号码\n\n每个inode都有一个号码，操作系统用inode号码来识别不同的文件。\n\n这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。\n\n表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。\n\n使用 `ls -i` 命令，可以看到文件名对应的inode号码。\n\n#### 目录文件\n\nUnix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。\n\n目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。\n\nls命令只列出目录文件中的所有文件名：\n\n```\nls /etc\n```\n\nls -i命令列出整个目录文件，即文件名和inode号码：\n\n```\nls -i /etc\n```\n\n如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。\n\n```\nls -l /etc\n```\n\n理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。\n\n\n\n### 硬链接\n\n一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。\n\n这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。\n\nln命令可以创建硬链接：\n\n```\nln 源文件 目标文件\n```\n\n运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。\n\n反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。\n\n这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）。\n\n\n\n### 软链接\n\n除了硬链接以外，还有一种特殊情况。\n\n文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。\n\n这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。\n\n**ln -s命令可以创建软链接**。\n\n```\nln -s 源文文件或目录 目标文件或目录\n```\n\n\n\n### inode的特殊作用\n\n由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。\n\n- 有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。\n- 移动文件或重命名文件，只是改变文件名，不影响inode号码。\n- 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。\n\n第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。\n\n\n\n# 参考\n\n[理解Linux的文件描述符FD与Inode](https://zhuanlan.zhihu.com/p/143430585)\n\n[文件描述符（File Descriptor）简介](https://segmentfault.com/a/1190000009724931)\n\n[每天进步一点点——Linux中的文件描述符与打开文件之间的关系](http://blog.csdn.net/cywosp/article/details/38965239)\n\n[File descriptor](https://en.wikipedia.org/wiki/File_descriptor)\n\n","slug":"understand-file-descriptor","published":0,"updated":"2021-08-16T12:26:41.879Z","_id":"cksh4umd7000cqkprfer8avcg","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>在 Unix 和类 Unix 的操作系统上，文件描述符 (file descriptor) 用来指向文件或者输入输出的资源。</p>\n<p>文件描述符通常有一个非负的整数数值，负值则用来表示空态或者错误状态。</p>\n<p>在 Linux 系统中，一切都看做是文件，文件又可分为: 普通文件、目录文件、链接文件和设备文件。</p>\n<p>当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行 I/O 操作的系统调用都会通过文件描述符。</p>\n<h3 id=\"系统为维护文件描述符，建立了三个表\"><a href=\"#系统为维护文件描述符，建立了三个表\" class=\"headerlink\" title=\"系统为维护文件描述符，建立了三个表\"></a>系统为维护文件描述符，建立了三个表</h3><ul>\n<li>进程级的文件描述符表</li>\n<li>系统级的文件描述符表</li>\n<li>文件系统的 i-node 表</li>\n</ul>\n<h3 id=\"inode\"><a href=\"#inode\" class=\"headerlink\" title=\"inode\"></a>inode</h3><h4 id=\"inode是什么？\"><a href=\"#inode是什么？\" class=\"headerlink\" title=\"inode是什么？\"></a>inode是什么？</h4><p>理解inode，要从文件储存说起。</p>\n<p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p>\n<p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p>\n<p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p>\n<p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p>\n<h4 id=\"inode的内容\"><a href=\"#inode的内容\" class=\"headerlink\" title=\"inode的内容\"></a>inode的内容</h4><p>inode包含文件的元信息，具体来说有以下内容：</p>\n<ul>\n<li>文件的字节数</li>\n<li>文件拥有者的User ID</li>\n<li>文件的Group ID</li>\n<li>文件的读、写、执行权限</li>\n<li>文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</li>\n<li>链接数，即有多少文件名指向这个inode</li>\n<li>文件数据block的位置</li>\n</ul>\n<p>可以用 <code>stat</code> 命令，查看某个文件的inode信息。</p>\n<p>总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。</p>\n<h4 id=\"inode的大小\"><a href=\"#inode的大小\" class=\"headerlink\" title=\"inode的大小\"></a>inode的大小</h4><p>inode 也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p>\n<p>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p>\n<p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -i</span><br></pre></td></tr></table></figure>\n\n\n<p>查看每个inode节点的大小，可以用如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo dumpe2fs -h &#x2F;dev&#x2F;hda | grep &quot;Inode size&quot;</span><br></pre></td></tr></table></figure>\n<p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p>\n<h4 id=\"inode号码\"><a href=\"#inode号码\" class=\"headerlink\" title=\"inode号码\"></a>inode号码</h4><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p>\n<p>这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p>\n<p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p>\n<p>使用 <code>ls -i</code> 命令，可以看到文件名对应的inode号码。</p>\n<h4 id=\"目录文件\"><a href=\"#目录文件\" class=\"headerlink\" title=\"目录文件\"></a>目录文件</h4><p>Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</p>\n<p>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。</p>\n<p>ls命令只列出目录文件中的所有文件名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls &#x2F;etc</span><br></pre></td></tr></table></figure>\n<p>ls -i命令列出整个目录文件，即文件名和inode号码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -i &#x2F;etc</span><br></pre></td></tr></table></figure>\n<p>如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l &#x2F;etc</span><br></pre></td></tr></table></figure>\n<p>理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。</p>\n<h3 id=\"硬链接\"><a href=\"#硬链接\" class=\"headerlink\" title=\"硬链接\"></a>硬链接</h3><p>一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。</p>\n<p>这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。</p>\n<p>ln命令可以创建硬链接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln 源文件 目标文件</span><br></pre></td></tr></table></figure>\n<p>运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。</p>\n<p>反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。</p>\n<p>这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）。</p>\n<h3 id=\"软链接\"><a href=\"#软链接\" class=\"headerlink\" title=\"软链接\"></a>软链接</h3><p>除了硬链接以外，还有一种特殊情况。</p>\n<p>文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。</p>\n<p>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。</p>\n<p><strong>ln -s命令可以创建软链接</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s 源文文件或目录 目标文件或目录</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"inode的特殊作用\"><a href=\"#inode的特殊作用\" class=\"headerlink\" title=\"inode的特殊作用\"></a>inode的特殊作用</h3><p>由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。</p>\n<ul>\n<li>有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</li>\n<li>移动文件或重命名文件，只是改变文件名，不影响inode号码。</li>\n<li>打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</li>\n</ul>\n<p>第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://zhuanlan.zhihu.com/p/143430585\">理解Linux的文件描述符FD与Inode</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000009724931\">文件描述符（File Descriptor）简介</a></p>\n<p><a href=\"http://blog.csdn.net/cywosp/article/details/38965239\">每天进步一点点——Linux中的文件描述符与打开文件之间的关系</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/File_descriptor\">File descriptor</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>在 Unix 和类 Unix 的操作系统上，文件描述符 (file descriptor) 用来指向文件或者输入输出的资源。</p>\n<p>文件描述符通常有一个非负的整数数值，负值则用来表示空态或者错误状态。</p>\n<p>在 Linux 系统中，一切都看做是文件，文件又可分为: 普通文件、目录文件、链接文件和设备文件。</p>\n<p>当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行 I/O 操作的系统调用都会通过文件描述符。</p>\n<h3 id=\"系统为维护文件描述符，建立了三个表\"><a href=\"#系统为维护文件描述符，建立了三个表\" class=\"headerlink\" title=\"系统为维护文件描述符，建立了三个表\"></a>系统为维护文件描述符，建立了三个表</h3><ul>\n<li>进程级的文件描述符表</li>\n<li>系统级的文件描述符表</li>\n<li>文件系统的 i-node 表</li>\n</ul>\n<h3 id=\"inode\"><a href=\"#inode\" class=\"headerlink\" title=\"inode\"></a>inode</h3><h4 id=\"inode是什么？\"><a href=\"#inode是什么？\" class=\"headerlink\" title=\"inode是什么？\"></a>inode是什么？</h4><p>理解inode，要从文件储存说起。</p>\n<p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p>\n<p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p>\n<p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p>\n<p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p>\n<h4 id=\"inode的内容\"><a href=\"#inode的内容\" class=\"headerlink\" title=\"inode的内容\"></a>inode的内容</h4><p>inode包含文件的元信息，具体来说有以下内容：</p>\n<ul>\n<li>文件的字节数</li>\n<li>文件拥有者的User ID</li>\n<li>文件的Group ID</li>\n<li>文件的读、写、执行权限</li>\n<li>文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</li>\n<li>链接数，即有多少文件名指向这个inode</li>\n<li>文件数据block的位置</li>\n</ul>\n<p>可以用 <code>stat</code> 命令，查看某个文件的inode信息。</p>\n<p>总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。</p>\n<h4 id=\"inode的大小\"><a href=\"#inode的大小\" class=\"headerlink\" title=\"inode的大小\"></a>inode的大小</h4><p>inode 也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p>\n<p>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p>\n<p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -i</span><br></pre></td></tr></table></figure>\n\n\n<p>查看每个inode节点的大小，可以用如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo dumpe2fs -h &#x2F;dev&#x2F;hda | grep &quot;Inode size&quot;</span><br></pre></td></tr></table></figure>\n<p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p>\n<h4 id=\"inode号码\"><a href=\"#inode号码\" class=\"headerlink\" title=\"inode号码\"></a>inode号码</h4><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p>\n<p>这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p>\n<p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p>\n<p>使用 <code>ls -i</code> 命令，可以看到文件名对应的inode号码。</p>\n<h4 id=\"目录文件\"><a href=\"#目录文件\" class=\"headerlink\" title=\"目录文件\"></a>目录文件</h4><p>Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</p>\n<p>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。</p>\n<p>ls命令只列出目录文件中的所有文件名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls &#x2F;etc</span><br></pre></td></tr></table></figure>\n<p>ls -i命令列出整个目录文件，即文件名和inode号码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -i &#x2F;etc</span><br></pre></td></tr></table></figure>\n<p>如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l &#x2F;etc</span><br></pre></td></tr></table></figure>\n<p>理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。</p>\n<h3 id=\"硬链接\"><a href=\"#硬链接\" class=\"headerlink\" title=\"硬链接\"></a>硬链接</h3><p>一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。</p>\n<p>这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。</p>\n<p>ln命令可以创建硬链接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln 源文件 目标文件</span><br></pre></td></tr></table></figure>\n<p>运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。</p>\n<p>反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。</p>\n<p>这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）。</p>\n<h3 id=\"软链接\"><a href=\"#软链接\" class=\"headerlink\" title=\"软链接\"></a>软链接</h3><p>除了硬链接以外，还有一种特殊情况。</p>\n<p>文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。</p>\n<p>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。</p>\n<p><strong>ln -s命令可以创建软链接</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s 源文文件或目录 目标文件或目录</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"inode的特殊作用\"><a href=\"#inode的特殊作用\" class=\"headerlink\" title=\"inode的特殊作用\"></a>inode的特殊作用</h3><p>由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。</p>\n<ul>\n<li>有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</li>\n<li>移动文件或重命名文件，只是改变文件名，不影响inode号码。</li>\n<li>打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</li>\n</ul>\n<p>第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://zhuanlan.zhihu.com/p/143430585\">理解Linux的文件描述符FD与Inode</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000009724931\">文件描述符（File Descriptor）简介</a></p>\n<p><a href=\"http://blog.csdn.net/cywosp/article/details/38965239\">每天进步一点点——Linux中的文件描述符与打开文件之间的关系</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/File_descriptor\">File descriptor</a></p>\n"},{"title":"分析 Zygote 启动流程","_content":"\n\n\n> 本文基于源代码: android-security-10.0.0_r56\n\n\n\n# 1. 前言\n\nAndroid 基于 Linux 内核，在内核启动过程中会创建出 init 进程。之后，init 进程会解析 `init.rc` 脚本文件，进而启动 Zygote 进程。Zygote 启动完成后，监听来自客户端的请求，接收到后立即唤醒并执行相应工作。\n\n<!-- TODO -->\n\n<!-- more -->\n\n\n\n# 2. 简析 init 进程的启动流程\n\ninit 进程由内核启动，是系统用户空间的第一个进程，其进程的 pid 为 1。\n\n\n\n## 2.1 init 进程的入口\n\n在 Android 9，init 进程的入口位于 `system/core/init/init.cpp` 中的 main 函数。\n\n在 Android 10 之后，init 进程的入口改到了 `system/core/init/main.cpp` 中的 main 函数。\n\n```c++\nint main(int argc, char** argv) {\n    \n    ...\n\n    if (!strcmp(basename(argv[0]), \"ueventd\")) {\n        return ueventd_main(argc, argv);\n    }\n\n    if (argc > 1) {\n        if (!strcmp(argv[1], \"subcontext\")) {\n            android::base::InitLogging(argv, &android::base::KernelLogger);\n            const BuiltinFunctionMap& function_map = GetBuiltinFunctionMap();\n\n            return SubcontextMain(argc, argv, &function_map);\n        }\n\n        if (!strcmp(argv[1], \"selinux_setup\")) {\n            return SetupSelinux(argv);\n        }\n\n        if (!strcmp(argv[1], \"second_stage\")) {\n            return SecondStageMain(argc, argv);\n        }\n    }\n\n    return FirstStageMain(argc, argv);\n}\n```\n\n其中，`argc` 表示命令行参数的个数，`argv` 则是传入的参数，`argv[0]` 是程序的全路径名，`arg[1]` 才是实际意义上的第一个参数。\n\n> `strcmp(str1, str2)` 是字符串比较函数，返回值为整数。当两个字符串相等时，函数返回 0。\n>\n> `basename(path)` 函数可以根据给定的一个路径，返回文件名。例如：传入参数 \"/system/bin/ueventd\"，函数返回 \"ueventd\"。\n\n`main` 函数会根据传入的参数，选择执行方式：\n\n1. 如果从路径参数 `argv[0]` 解析出 \"ueventd\"，执行 `ueventd_main(argc, argv)`\n2. 如果带参启动 `init`，执行 `SubcontextMain(argc, argv, &function_map)`，`SetupSelinux(argv)`，`SecondStageMain(argc, argv)` 中的一个\n3. 否则，默认执行 `FirstStageMain(argc, argv)`\n\n\n\n## 2.2 启动的第一阶段\n\n启动的第一阶段会执行 `int FirstStageMain(int argc, char** argv)`，源代码路径为 `system/core/init/first_stage_init.cpp`。\n\n```c++\nint FirstStageMain(int argc, char** argv) {\n\n    ...\n\n    CHECKCALL(clearenv());\n    CHECKCALL(setenv(\"PATH\", _PATH_DEFPATH, 1));\n    // Get the basic filesystem setup we need put together in the initramdisk\n    // on / and then we'll let the rc file figure out the rest.\n    CHECKCALL(mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"));\n    CHECKCALL(mkdir(\"/dev/pts\", 0755));\n    CHECKCALL(mkdir(\"/dev/socket\", 0755));\n    CHECKCALL(mkdir(\"/dev/dm-user\", 0755));\n    CHECKCALL(mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL));\n#define MAKE_STR(x) __STRING(x)\n    CHECKCALL(mount(\"proc\", \"/proc\", \"proc\", 0, \"hidepid=2,gid=\" MAKE_STR(AID_READPROC)));\n#undef MAKE_STR\n\n    // Don't expose the raw commandline to unprivileged processes.\n    // 设置文件权限, 分析见 2.2.1\n    CHECKCALL(chmod(\"/proc/cmdline\", 0440));\n    std::string cmdline;\n    android::base::ReadFileToString(\"/proc/cmdline\", &cmdline);\n    // Don't expose the raw bootconfig to unprivileged processes.\n    chmod(\"/proc/bootconfig\", 0440);\n    std::string bootconfig;\n    android::base::ReadFileToString(\"/proc/bootconfig\", &bootconfig);\n    gid_t groups[] = {AID_READPROC};\n    CHECKCALL(setgroups(arraysize(groups), groups));\n    CHECKCALL(mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL));\n    CHECKCALL(mount(\"selinuxfs\", \"/sys/fs/selinux\", \"selinuxfs\", 0, NULL));\n\n    CHECKCALL(mknod(\"/dev/kmsg\", S_IFCHR | 0600, makedev(1, 11)));\n\n    if constexpr (WORLD_WRITABLE_KMSG) {\n        CHECKCALL(mknod(\"/dev/kmsg_debug\", S_IFCHR | 0622, makedev(1, 11)));\n    }\n\n    CHECKCALL(mknod(\"/dev/random\", S_IFCHR | 0666, makedev(1, 8)));\n    CHECKCALL(mknod(\"/dev/urandom\", S_IFCHR | 0666, makedev(1, 9)));\n\n    // This is needed for log wrapper, which gets called before ueventd runs.\n    CHECKCALL(mknod(\"/dev/ptmx\", S_IFCHR | 0666, makedev(5, 2)));\n    CHECKCALL(mknod(\"/dev/null\", S_IFCHR | 0666, makedev(1, 3)));\n\n    // These below mounts are done in first stage init so that first stage mount can mount\n    // subdirectories of /mnt/{vendor,product}/.  Other mounts, not required by first stage mount,\n    // should be done in rc files.\n    // Mount staging areas for devices managed by vold\n    // See storage config details at http://source.android.com/devices/storage/\n    CHECKCALL(mount(\"tmpfs\", \"/mnt\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=1000\"));\n    // /mnt/vendor is used to mount vendor-specific partitions that can not be\n    // part of the vendor partition, e.g. because they are mounted read-write.\n    CHECKCALL(mkdir(\"/mnt/vendor\", 0755));\n    // /mnt/product is used to mount product-specific partitions that can not be\n    // part of the product partition, e.g. because they are mounted read-write.\n    CHECKCALL(mkdir(\"/mnt/product\", 0755));\n\n    // /debug_ramdisk is used to preserve additional files from the debug ramdisk\n    CHECKCALL(mount(\"tmpfs\", \"/debug_ramdisk\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=0\"));\n\n    // /second_stage_resources is used to preserve files from first to second\n    // stage init\n    CHECKCALL(mount(\"tmpfs\", kSecondStageRes, \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=0\"))\n#undef CHECKCALL\n\n    SetStdioToDevNull(argv);\n    // Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually\n    // talk to the outside world...\n    InitKernelLogging(argv);\n\n    if (!errors.empty()) {\n        for (const auto& [error_string, error_errno] : errors) {\n            LOG(ERROR) << error_string << \" \" << strerror(error_errno);\n        }\n        LOG(FATAL) << \"Init encountered errors starting first stage, aborting\";\n    }\n\n    LOG(INFO) << \"init first stage started!\";\n\n    ...\n\n    // 执行 /system/bin/init/selinux_setup, 初始化 SELinux\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"selinux_setup\", nullptr};\n    auto fd = open(\"/dev/kmsg\", O_WRONLY | O_CLOEXEC);\n    dup2(fd, STDOUT_FILENO);\n    dup2(fd, STDERR_FILENO);\n    close(fd);\n    execv(path, const_cast<char**>(args));\n\n    // execv() only returns if an error happened, in which case we\n    // panic and never fall through this conditional.\n    PLOG(FATAL) << \"execv(\\\"\" << path << \"\\\") failed\";\n\n    return 1;\n}\n```\n\n函数的主要工作有：挂载文件系统，初始化 SELinux。\n\n\n\n### 2.2.1 设置文件或目录的权限\n\n在 Linux 系统上，`chmod` 命令用于控制用户对文件或者目录的权限，但只有文件所有者和超级用户可以修改文件或目录的权限。\n\n权限分为三类：读，写，执行。\n\n\n\n#### 2.2.1.1 符号表示法\n\n符号表示法用 10 位字符表示权限，其形式为：\n\n```\n-rwxrwxrwx\n```\n\n其中第一个字符表示文件类型，常见的符号有：\n\n- `-`，表示普通文件。\n- `d`，表示目录。\n- `c`，表示字符特殊文件。\n\n剩余的 9 个字符，每 3 个字符分为一组，分别表示用户，用户组，其他用户的权限。\n\n3 个字符组成的字符串，第 1 位控制读权限，第 2 位控制写权限，第 3 位控制执行权限：\n\n- 如果拥有读权限，第 1 位字符为 `r`；否则为 `-`。\n- 如果拥有写权限，第 2 位字符为 `w`；否则为 `-`。\n- 如果拥有读权限，第 3 位字符为 `r`；否则为 `-`。\n\n\n\n示例：\n\n`-rwxrw-r--`，表示一个普通文件，用户拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。\n\n\n\n#### 2.2.1.2 数字表示法\n\n可以用 4 位八进制数字表示权限，第 1 位同样表示文件类型，剩余的 3 位数字，分别表示用户，用户组，其他用户的权限。\n\n读，写，执行，这 3 类权限可以使用 3 位二进制数字表示，不同类型的权限单独对应二进制数字中一个位：\n\n|          数值          | 权限 |\n| :--------------------: | :--: |\n| 二进制：100，八进制：4 |  r   |\n| 二进制：010，八进制：2 |  w   |\n| 二进制：001，八进制：1 |  x   |\n| 二进制：000，八进制：0 |  -   |\n\n在各类权限对应的数值之和，可以代表一组特定的权限。由于和的数值范围为 0~7，因此可以通过一个八进制数字表示。示例：\n\n|          数值          | 权限 |\n| :--------------------: | :--: |\n| 二进制：111，八进制：7 | rwx  |\n| 二进制：110，八进制：6 | rw-  |\n| 二进制：101，八进制：5 | r-x  |\n| 二进制：000，八进制：0 | ---  |\n\n因此，用符号表示法表示的权限，同样可以使用数字表示法去表示，示例：\n\n| 符号表示法 | 数字表示法 |                             说明                             |\n| :--------: | :--------: | :----------------------------------------------------------: |\n| -rwxrwxrwx |    0777    |  一个普通文件，用户，用户组，其他用户都有读，写，执行的权限  |\n| -rwxrw-r-- |    0764    | 一个普通文件，用户拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。 |\n\n\n\n#### 2.2.1.3 分析源码中的权限设置\n\n```c++\n// Don't expose the raw commandline to unprivileged processes.\nCHECKCALL(chmod(\"/proc/cmdline\", 0440));\n\n// Don't expose the raw bootconfig to unprivileged processes.\nchmod(\"/proc/bootconfig\", 0440);\n```\n\n在源码中有两处使用到 `chmod` 命令，分别对文件 `/proc/cmdline, /proc/bootconfig` 设置了权限 `0440`，表明root 用户及其用户组也只有文件的读权限。\n\n\n\n## 2.3 初始化 SELinux\n\n初始化 SELinux 会执行 `int SetupSelinux(char** argv)`，源代码路径为 `system/core/init/selinux.cpp`。\n\n```c++\n// This function initializes SELinux then execs init to run in the init SELinux context.\nint SetupSelinux(char** argv) {\n    InitKernelLogging(argv);\n\n    if (REBOOT_BOOTLOADER_ON_PANIC) {\n        InstallRebootSignalHandlers();\n    }\n\n    // Set up SELinux, loading the SELinux policy.\n    // 初始化 SELinux\n    SelinuxSetupKernelLogging();\n    SelinuxInitialize();\n\n    ...\n\n    // 执行 /system/bin/init/second_stage, 进入第二阶段\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"second_stage\", nullptr};\n    execv(path, const_cast<char**>(args));\n\n    ...\n\n    return 1;\n}\n```\n\n该函数首先是初始化 SELinux，然后执行 `/system/bin/init/second_stage`，进入启动的第二阶段。\n\n\n\n## 2.4 启动的第二阶段\n\n启动的第二阶段会执行 `int SecondStageMain(int argc, char** argv)`，源代码路径为 `system/core/init/init.cpp`。\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n    if (REBOOT_BOOTLOADER_ON_PANIC) {\n        InstallRebootSignalHandlers();\n    }\n\n    SetStdioToDevNull(argv);\n    InitKernelLogging(argv);\n    LOG(INFO) << \"init second stage started!\";\n\n    ...\n\n    // Now set up SELinux for second stage.\n    // 为第二阶段设置 SeLinux\n    SelinuxSetupKernelLogging();\n    SelabelInitialize();\n    SelinuxRestoreContext();\n\n    ...\n\n    subcontexts = InitializeSubcontexts();\n\n    ActionManager& am = ActionManager::GetInstance();\n    ServiceList& sm = ServiceList::GetInstance();\n\n    // 加载 init.rc 脚本文件, 分析见 2.4.1\n    LoadBootScripts(am, sm);\n\n    ...\n\n    am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\");\n\n    am.QueueEventTrigger(\"early-init\");\n\n    // Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...\n    am.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\");\n    // ... so that we can start queuing up actions that require stuff from /dev.\n    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\");\n    am.QueueBuiltinAction(SetMmapRndBitsAction, \"SetMmapRndBits\");\n    am.QueueBuiltinAction(SetKptrRestrictAction, \"SetKptrRestrict\");\n    Keychords keychords;\n    am.QueueBuiltinAction(\n        [&epoll, &keychords](const BuiltinArguments& args) -> Result<Success> {\n            for (const auto& svc : ServiceList::GetInstance()) {\n                keychords.Register(svc->keycodes());\n            }\n            keychords.Start(&epoll, HandleKeychord);\n            return Success();\n        },\n        \"KeychordInit\");\n    am.QueueBuiltinAction(console_init_action, \"console_init\");\n\n    // Trigger all the boot actions to get us started.\n    am.QueueEventTrigger(\"init\");\n\n    // Starting the BoringSSL self test, for NIAP certification compliance.\n    am.QueueBuiltinAction(StartBoringSslSelfTest, \"StartBoringSslSelfTest\");\n\n    // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random\n    // wasn't ready immediately after wait_for_coldboot_done\n    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\");\n\n    // Initialize binder before bringing up other system services\n    am.QueueBuiltinAction(InitBinder, \"InitBinder\");\n\n    // Don't mount filesystems or start core system services in charger mode.\n    std::string bootmode = GetProperty(\"ro.bootmode\", \"\");\n    if (bootmode == \"charger\") {\n        am.QueueEventTrigger(\"charger\");\n    } else {\n        am.QueueEventTrigger(\"late-init\");\n    }\n\n    // Run all property triggers based on current state of the properties.\n    am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\");\n\n    while (true) {\n        // By default, sleep until something happens.\n        auto epoll_timeout = std::optional<std::chrono::milliseconds>{};\n\n        if (do_shutdown && !shutting_down) {\n            do_shutdown = false;\n            if (HandlePowerctlMessage(shutdown_command)) {\n                shutting_down = true;\n            }\n        }\n\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            am.ExecuteOneCommand();\n        }\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            if (!shutting_down) {\n                auto next_process_action_time = HandleProcessActions();\n\n                // If there's a process that needs restarting, wake up in time for that.\n                if (next_process_action_time) {\n                    epoll_timeout = std::chrono::ceil<std::chrono::milliseconds>(\n                            *next_process_action_time - boot_clock::now());\n                    if (*epoll_timeout < 0ms) epoll_timeout = 0ms;\n                }\n            }\n\n            // If there's more work to do, wake up again immediately.\n            if (am.HasMoreCommands()) epoll_timeout = 0ms;\n        }\n\n        if (auto result = epoll.Wait(epoll_timeout); !result) {\n            LOG(ERROR) << result.error();\n        }\n    }\n\n    return 0;\n}\n```\n\n\n\n### 2.4.1 加载 init.rc 脚本文件\n\n加载 init.rc 脚本文件会执行 `void LoadBootScripts(ActionManager& action_manager, ServiceList& service_list)`，源代码路径为 `system/core/init/init.cpp`。\n\n```c++\nstatic void LoadBootScripts(ActionManager& action_manager, ServiceList& service_list) {\n    Parser parser = CreateParser(action_manager, service_list);\n\n    std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\");\n    if (bootscript.empty()) {\n        parser.ParseConfig(\"/init.rc\");\n        if (!parser.ParseConfig(\"/system/etc/init\")) {\n            late_import_paths.emplace_back(\"/system/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/product/etc/init\")) {\n            late_import_paths.emplace_back(\"/product/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/product_services/etc/init\")) {\n            late_import_paths.emplace_back(\"/product_services/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/odm/etc/init\")) {\n            late_import_paths.emplace_back(\"/odm/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/vendor/etc/init\")) {\n            late_import_paths.emplace_back(\"/vendor/etc/init\");\n        }\n    } else {\n        parser.ParseConfig(bootscript);\n    }\n}\n```\n\n\n\n\n\n# 参考\n\n[Android系统启动-综述](http://gityuan.com/2016/02/01/android-booting/)\n\n[Android系统启动-zygote篇](http://gityuan.com/2016/02/13/android-zygote/)\n\n","source":"_drafts/exploring-zygote-startup-process.md","raw":"---\ntitle: 分析 Zygote 启动流程\ntags:\n- Zygote\ncategories:\n- [Android]\n---\n\n\n\n> 本文基于源代码: android-security-10.0.0_r56\n\n\n\n# 1. 前言\n\nAndroid 基于 Linux 内核，在内核启动过程中会创建出 init 进程。之后，init 进程会解析 `init.rc` 脚本文件，进而启动 Zygote 进程。Zygote 启动完成后，监听来自客户端的请求，接收到后立即唤醒并执行相应工作。\n\n<!-- TODO -->\n\n<!-- more -->\n\n\n\n# 2. 简析 init 进程的启动流程\n\ninit 进程由内核启动，是系统用户空间的第一个进程，其进程的 pid 为 1。\n\n\n\n## 2.1 init 进程的入口\n\n在 Android 9，init 进程的入口位于 `system/core/init/init.cpp` 中的 main 函数。\n\n在 Android 10 之后，init 进程的入口改到了 `system/core/init/main.cpp` 中的 main 函数。\n\n```c++\nint main(int argc, char** argv) {\n    \n    ...\n\n    if (!strcmp(basename(argv[0]), \"ueventd\")) {\n        return ueventd_main(argc, argv);\n    }\n\n    if (argc > 1) {\n        if (!strcmp(argv[1], \"subcontext\")) {\n            android::base::InitLogging(argv, &android::base::KernelLogger);\n            const BuiltinFunctionMap& function_map = GetBuiltinFunctionMap();\n\n            return SubcontextMain(argc, argv, &function_map);\n        }\n\n        if (!strcmp(argv[1], \"selinux_setup\")) {\n            return SetupSelinux(argv);\n        }\n\n        if (!strcmp(argv[1], \"second_stage\")) {\n            return SecondStageMain(argc, argv);\n        }\n    }\n\n    return FirstStageMain(argc, argv);\n}\n```\n\n其中，`argc` 表示命令行参数的个数，`argv` 则是传入的参数，`argv[0]` 是程序的全路径名，`arg[1]` 才是实际意义上的第一个参数。\n\n> `strcmp(str1, str2)` 是字符串比较函数，返回值为整数。当两个字符串相等时，函数返回 0。\n>\n> `basename(path)` 函数可以根据给定的一个路径，返回文件名。例如：传入参数 \"/system/bin/ueventd\"，函数返回 \"ueventd\"。\n\n`main` 函数会根据传入的参数，选择执行方式：\n\n1. 如果从路径参数 `argv[0]` 解析出 \"ueventd\"，执行 `ueventd_main(argc, argv)`\n2. 如果带参启动 `init`，执行 `SubcontextMain(argc, argv, &function_map)`，`SetupSelinux(argv)`，`SecondStageMain(argc, argv)` 中的一个\n3. 否则，默认执行 `FirstStageMain(argc, argv)`\n\n\n\n## 2.2 启动的第一阶段\n\n启动的第一阶段会执行 `int FirstStageMain(int argc, char** argv)`，源代码路径为 `system/core/init/first_stage_init.cpp`。\n\n```c++\nint FirstStageMain(int argc, char** argv) {\n\n    ...\n\n    CHECKCALL(clearenv());\n    CHECKCALL(setenv(\"PATH\", _PATH_DEFPATH, 1));\n    // Get the basic filesystem setup we need put together in the initramdisk\n    // on / and then we'll let the rc file figure out the rest.\n    CHECKCALL(mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"));\n    CHECKCALL(mkdir(\"/dev/pts\", 0755));\n    CHECKCALL(mkdir(\"/dev/socket\", 0755));\n    CHECKCALL(mkdir(\"/dev/dm-user\", 0755));\n    CHECKCALL(mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL));\n#define MAKE_STR(x) __STRING(x)\n    CHECKCALL(mount(\"proc\", \"/proc\", \"proc\", 0, \"hidepid=2,gid=\" MAKE_STR(AID_READPROC)));\n#undef MAKE_STR\n\n    // Don't expose the raw commandline to unprivileged processes.\n    // 设置文件权限, 分析见 2.2.1\n    CHECKCALL(chmod(\"/proc/cmdline\", 0440));\n    std::string cmdline;\n    android::base::ReadFileToString(\"/proc/cmdline\", &cmdline);\n    // Don't expose the raw bootconfig to unprivileged processes.\n    chmod(\"/proc/bootconfig\", 0440);\n    std::string bootconfig;\n    android::base::ReadFileToString(\"/proc/bootconfig\", &bootconfig);\n    gid_t groups[] = {AID_READPROC};\n    CHECKCALL(setgroups(arraysize(groups), groups));\n    CHECKCALL(mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL));\n    CHECKCALL(mount(\"selinuxfs\", \"/sys/fs/selinux\", \"selinuxfs\", 0, NULL));\n\n    CHECKCALL(mknod(\"/dev/kmsg\", S_IFCHR | 0600, makedev(1, 11)));\n\n    if constexpr (WORLD_WRITABLE_KMSG) {\n        CHECKCALL(mknod(\"/dev/kmsg_debug\", S_IFCHR | 0622, makedev(1, 11)));\n    }\n\n    CHECKCALL(mknod(\"/dev/random\", S_IFCHR | 0666, makedev(1, 8)));\n    CHECKCALL(mknod(\"/dev/urandom\", S_IFCHR | 0666, makedev(1, 9)));\n\n    // This is needed for log wrapper, which gets called before ueventd runs.\n    CHECKCALL(mknod(\"/dev/ptmx\", S_IFCHR | 0666, makedev(5, 2)));\n    CHECKCALL(mknod(\"/dev/null\", S_IFCHR | 0666, makedev(1, 3)));\n\n    // These below mounts are done in first stage init so that first stage mount can mount\n    // subdirectories of /mnt/{vendor,product}/.  Other mounts, not required by first stage mount,\n    // should be done in rc files.\n    // Mount staging areas for devices managed by vold\n    // See storage config details at http://source.android.com/devices/storage/\n    CHECKCALL(mount(\"tmpfs\", \"/mnt\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=1000\"));\n    // /mnt/vendor is used to mount vendor-specific partitions that can not be\n    // part of the vendor partition, e.g. because they are mounted read-write.\n    CHECKCALL(mkdir(\"/mnt/vendor\", 0755));\n    // /mnt/product is used to mount product-specific partitions that can not be\n    // part of the product partition, e.g. because they are mounted read-write.\n    CHECKCALL(mkdir(\"/mnt/product\", 0755));\n\n    // /debug_ramdisk is used to preserve additional files from the debug ramdisk\n    CHECKCALL(mount(\"tmpfs\", \"/debug_ramdisk\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=0\"));\n\n    // /second_stage_resources is used to preserve files from first to second\n    // stage init\n    CHECKCALL(mount(\"tmpfs\", kSecondStageRes, \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=0\"))\n#undef CHECKCALL\n\n    SetStdioToDevNull(argv);\n    // Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually\n    // talk to the outside world...\n    InitKernelLogging(argv);\n\n    if (!errors.empty()) {\n        for (const auto& [error_string, error_errno] : errors) {\n            LOG(ERROR) << error_string << \" \" << strerror(error_errno);\n        }\n        LOG(FATAL) << \"Init encountered errors starting first stage, aborting\";\n    }\n\n    LOG(INFO) << \"init first stage started!\";\n\n    ...\n\n    // 执行 /system/bin/init/selinux_setup, 初始化 SELinux\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"selinux_setup\", nullptr};\n    auto fd = open(\"/dev/kmsg\", O_WRONLY | O_CLOEXEC);\n    dup2(fd, STDOUT_FILENO);\n    dup2(fd, STDERR_FILENO);\n    close(fd);\n    execv(path, const_cast<char**>(args));\n\n    // execv() only returns if an error happened, in which case we\n    // panic and never fall through this conditional.\n    PLOG(FATAL) << \"execv(\\\"\" << path << \"\\\") failed\";\n\n    return 1;\n}\n```\n\n函数的主要工作有：挂载文件系统，初始化 SELinux。\n\n\n\n### 2.2.1 设置文件或目录的权限\n\n在 Linux 系统上，`chmod` 命令用于控制用户对文件或者目录的权限，但只有文件所有者和超级用户可以修改文件或目录的权限。\n\n权限分为三类：读，写，执行。\n\n\n\n#### 2.2.1.1 符号表示法\n\n符号表示法用 10 位字符表示权限，其形式为：\n\n```\n-rwxrwxrwx\n```\n\n其中第一个字符表示文件类型，常见的符号有：\n\n- `-`，表示普通文件。\n- `d`，表示目录。\n- `c`，表示字符特殊文件。\n\n剩余的 9 个字符，每 3 个字符分为一组，分别表示用户，用户组，其他用户的权限。\n\n3 个字符组成的字符串，第 1 位控制读权限，第 2 位控制写权限，第 3 位控制执行权限：\n\n- 如果拥有读权限，第 1 位字符为 `r`；否则为 `-`。\n- 如果拥有写权限，第 2 位字符为 `w`；否则为 `-`。\n- 如果拥有读权限，第 3 位字符为 `r`；否则为 `-`。\n\n\n\n示例：\n\n`-rwxrw-r--`，表示一个普通文件，用户拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。\n\n\n\n#### 2.2.1.2 数字表示法\n\n可以用 4 位八进制数字表示权限，第 1 位同样表示文件类型，剩余的 3 位数字，分别表示用户，用户组，其他用户的权限。\n\n读，写，执行，这 3 类权限可以使用 3 位二进制数字表示，不同类型的权限单独对应二进制数字中一个位：\n\n|          数值          | 权限 |\n| :--------------------: | :--: |\n| 二进制：100，八进制：4 |  r   |\n| 二进制：010，八进制：2 |  w   |\n| 二进制：001，八进制：1 |  x   |\n| 二进制：000，八进制：0 |  -   |\n\n在各类权限对应的数值之和，可以代表一组特定的权限。由于和的数值范围为 0~7，因此可以通过一个八进制数字表示。示例：\n\n|          数值          | 权限 |\n| :--------------------: | :--: |\n| 二进制：111，八进制：7 | rwx  |\n| 二进制：110，八进制：6 | rw-  |\n| 二进制：101，八进制：5 | r-x  |\n| 二进制：000，八进制：0 | ---  |\n\n因此，用符号表示法表示的权限，同样可以使用数字表示法去表示，示例：\n\n| 符号表示法 | 数字表示法 |                             说明                             |\n| :--------: | :--------: | :----------------------------------------------------------: |\n| -rwxrwxrwx |    0777    |  一个普通文件，用户，用户组，其他用户都有读，写，执行的权限  |\n| -rwxrw-r-- |    0764    | 一个普通文件，用户拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。 |\n\n\n\n#### 2.2.1.3 分析源码中的权限设置\n\n```c++\n// Don't expose the raw commandline to unprivileged processes.\nCHECKCALL(chmod(\"/proc/cmdline\", 0440));\n\n// Don't expose the raw bootconfig to unprivileged processes.\nchmod(\"/proc/bootconfig\", 0440);\n```\n\n在源码中有两处使用到 `chmod` 命令，分别对文件 `/proc/cmdline, /proc/bootconfig` 设置了权限 `0440`，表明root 用户及其用户组也只有文件的读权限。\n\n\n\n## 2.3 初始化 SELinux\n\n初始化 SELinux 会执行 `int SetupSelinux(char** argv)`，源代码路径为 `system/core/init/selinux.cpp`。\n\n```c++\n// This function initializes SELinux then execs init to run in the init SELinux context.\nint SetupSelinux(char** argv) {\n    InitKernelLogging(argv);\n\n    if (REBOOT_BOOTLOADER_ON_PANIC) {\n        InstallRebootSignalHandlers();\n    }\n\n    // Set up SELinux, loading the SELinux policy.\n    // 初始化 SELinux\n    SelinuxSetupKernelLogging();\n    SelinuxInitialize();\n\n    ...\n\n    // 执行 /system/bin/init/second_stage, 进入第二阶段\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"second_stage\", nullptr};\n    execv(path, const_cast<char**>(args));\n\n    ...\n\n    return 1;\n}\n```\n\n该函数首先是初始化 SELinux，然后执行 `/system/bin/init/second_stage`，进入启动的第二阶段。\n\n\n\n## 2.4 启动的第二阶段\n\n启动的第二阶段会执行 `int SecondStageMain(int argc, char** argv)`，源代码路径为 `system/core/init/init.cpp`。\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n    if (REBOOT_BOOTLOADER_ON_PANIC) {\n        InstallRebootSignalHandlers();\n    }\n\n    SetStdioToDevNull(argv);\n    InitKernelLogging(argv);\n    LOG(INFO) << \"init second stage started!\";\n\n    ...\n\n    // Now set up SELinux for second stage.\n    // 为第二阶段设置 SeLinux\n    SelinuxSetupKernelLogging();\n    SelabelInitialize();\n    SelinuxRestoreContext();\n\n    ...\n\n    subcontexts = InitializeSubcontexts();\n\n    ActionManager& am = ActionManager::GetInstance();\n    ServiceList& sm = ServiceList::GetInstance();\n\n    // 加载 init.rc 脚本文件, 分析见 2.4.1\n    LoadBootScripts(am, sm);\n\n    ...\n\n    am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\");\n\n    am.QueueEventTrigger(\"early-init\");\n\n    // Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...\n    am.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\");\n    // ... so that we can start queuing up actions that require stuff from /dev.\n    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\");\n    am.QueueBuiltinAction(SetMmapRndBitsAction, \"SetMmapRndBits\");\n    am.QueueBuiltinAction(SetKptrRestrictAction, \"SetKptrRestrict\");\n    Keychords keychords;\n    am.QueueBuiltinAction(\n        [&epoll, &keychords](const BuiltinArguments& args) -> Result<Success> {\n            for (const auto& svc : ServiceList::GetInstance()) {\n                keychords.Register(svc->keycodes());\n            }\n            keychords.Start(&epoll, HandleKeychord);\n            return Success();\n        },\n        \"KeychordInit\");\n    am.QueueBuiltinAction(console_init_action, \"console_init\");\n\n    // Trigger all the boot actions to get us started.\n    am.QueueEventTrigger(\"init\");\n\n    // Starting the BoringSSL self test, for NIAP certification compliance.\n    am.QueueBuiltinAction(StartBoringSslSelfTest, \"StartBoringSslSelfTest\");\n\n    // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random\n    // wasn't ready immediately after wait_for_coldboot_done\n    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\");\n\n    // Initialize binder before bringing up other system services\n    am.QueueBuiltinAction(InitBinder, \"InitBinder\");\n\n    // Don't mount filesystems or start core system services in charger mode.\n    std::string bootmode = GetProperty(\"ro.bootmode\", \"\");\n    if (bootmode == \"charger\") {\n        am.QueueEventTrigger(\"charger\");\n    } else {\n        am.QueueEventTrigger(\"late-init\");\n    }\n\n    // Run all property triggers based on current state of the properties.\n    am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\");\n\n    while (true) {\n        // By default, sleep until something happens.\n        auto epoll_timeout = std::optional<std::chrono::milliseconds>{};\n\n        if (do_shutdown && !shutting_down) {\n            do_shutdown = false;\n            if (HandlePowerctlMessage(shutdown_command)) {\n                shutting_down = true;\n            }\n        }\n\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            am.ExecuteOneCommand();\n        }\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            if (!shutting_down) {\n                auto next_process_action_time = HandleProcessActions();\n\n                // If there's a process that needs restarting, wake up in time for that.\n                if (next_process_action_time) {\n                    epoll_timeout = std::chrono::ceil<std::chrono::milliseconds>(\n                            *next_process_action_time - boot_clock::now());\n                    if (*epoll_timeout < 0ms) epoll_timeout = 0ms;\n                }\n            }\n\n            // If there's more work to do, wake up again immediately.\n            if (am.HasMoreCommands()) epoll_timeout = 0ms;\n        }\n\n        if (auto result = epoll.Wait(epoll_timeout); !result) {\n            LOG(ERROR) << result.error();\n        }\n    }\n\n    return 0;\n}\n```\n\n\n\n### 2.4.1 加载 init.rc 脚本文件\n\n加载 init.rc 脚本文件会执行 `void LoadBootScripts(ActionManager& action_manager, ServiceList& service_list)`，源代码路径为 `system/core/init/init.cpp`。\n\n```c++\nstatic void LoadBootScripts(ActionManager& action_manager, ServiceList& service_list) {\n    Parser parser = CreateParser(action_manager, service_list);\n\n    std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\");\n    if (bootscript.empty()) {\n        parser.ParseConfig(\"/init.rc\");\n        if (!parser.ParseConfig(\"/system/etc/init\")) {\n            late_import_paths.emplace_back(\"/system/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/product/etc/init\")) {\n            late_import_paths.emplace_back(\"/product/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/product_services/etc/init\")) {\n            late_import_paths.emplace_back(\"/product_services/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/odm/etc/init\")) {\n            late_import_paths.emplace_back(\"/odm/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/vendor/etc/init\")) {\n            late_import_paths.emplace_back(\"/vendor/etc/init\");\n        }\n    } else {\n        parser.ParseConfig(bootscript);\n    }\n}\n```\n\n\n\n\n\n# 参考\n\n[Android系统启动-综述](http://gityuan.com/2016/02/01/android-booting/)\n\n[Android系统启动-zygote篇](http://gityuan.com/2016/02/13/android-zygote/)\n\n","slug":"exploring-zygote-startup-process","published":0,"date":"2021-08-17T09:00:08.586Z","updated":"2021-08-23T09:57:32.453Z","_id":"cksh4vd82000eqkpr503zbpok","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>本文基于源代码: android-security-10.0.0_r56</p>\n</blockquote>\n<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>Android 基于 Linux 内核，在内核启动过程中会创建出 init 进程。之后，init 进程会解析 <code>init.rc</code> 脚本文件，进而启动 Zygote 进程。Zygote 启动完成后，监听来自客户端的请求，接收到后立即唤醒并执行相应工作。</p>\n<!-- TODO -->\n\n<a id=\"more\"></a>\n\n\n\n<h1 id=\"2-简析-init-进程的启动流程\"><a href=\"#2-简析-init-进程的启动流程\" class=\"headerlink\" title=\"2. 简析 init 进程的启动流程\"></a>2. 简析 init 进程的启动流程</h1><p>init 进程由内核启动，是系统用户空间的第一个进程，其进程的 pid 为 1。</p>\n<h2 id=\"2-1-init-进程的入口\"><a href=\"#2-1-init-进程的入口\" class=\"headerlink\" title=\"2.1 init 进程的入口\"></a>2.1 init 进程的入口</h2><p>在 Android 9，init 进程的入口位于 <code>system/core/init/init.cpp</code> 中的 main 函数。</p>\n<p>在 Android 10 之后，init 进程的入口改到了 <code>system/core/init/main.cpp</code> 中的 main 函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(basename(argv[<span class=\"number\">0</span>]), <span class=\"string\">&quot;ueventd&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ueventd_main(argc, argv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;subcontext&quot;</span>)) &#123;</span><br><span class=\"line\">            android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class=\"line\">            <span class=\"keyword\">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> SubcontextMain(argc, argv, &amp;function_map);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;selinux_setup&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SetupSelinux(argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;second_stage&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SecondStageMain(argc, argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> FirstStageMain(argc, argv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，<code>argc</code> 表示命令行参数的个数，<code>argv</code> 则是传入的参数，<code>argv[0]</code> 是程序的全路径名，<code>arg[1]</code> 才是实际意义上的第一个参数。</p>\n<blockquote>\n<p><code>strcmp(str1, str2)</code> 是字符串比较函数，返回值为整数。当两个字符串相等时，函数返回 0。</p>\n<p><code>basename(path)</code> 函数可以根据给定的一个路径，返回文件名。例如：传入参数 “/system/bin/ueventd”，函数返回 “ueventd”。</p>\n</blockquote>\n<p><code>main</code> 函数会根据传入的参数，选择执行方式：</p>\n<ol>\n<li>如果从路径参数 <code>argv[0]</code> 解析出 “ueventd”，执行 <code>ueventd_main(argc, argv)</code></li>\n<li>如果带参启动 <code>init</code>，执行 <code>SubcontextMain(argc, argv, &amp;function_map)</code>，<code>SetupSelinux(argv)</code>，<code>SecondStageMain(argc, argv)</code> 中的一个</li>\n<li>否则，默认执行 <code>FirstStageMain(argc, argv)</code></li>\n</ol>\n<h2 id=\"2-2-启动的第一阶段\"><a href=\"#2-2-启动的第一阶段\" class=\"headerlink\" title=\"2.2 启动的第一阶段\"></a>2.2 启动的第一阶段</h2><p>启动的第一阶段会执行 <code>int FirstStageMain(int argc, char** argv)</code>，源代码路径为 <code>system/core/init/first_stage_init.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FirstStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(clearenv());</span><br><span class=\"line\">    CHECKCALL(setenv(<span class=\"string\">&quot;PATH&quot;</span>, _PATH_DEFPATH, <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"comment\">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class=\"line\">    <span class=\"comment\">// on / and then we&#x27;ll let the rc file figure out the rest.</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/dev&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class=\"string\">&quot;mode=0755&quot;</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/pts&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/socket&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/dm-user&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;devpts&quot;</span>, <span class=\"string\">&quot;/dev/pts&quot;</span>, <span class=\"string\">&quot;devpts&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;proc&quot;</span>, <span class=\"string\">&quot;/proc&quot;</span>, <span class=\"string\">&quot;proc&quot;</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;hidepid=2,gid=&quot;</span> MAKE_STR(AID_READPROC)));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> MAKE_STR</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t expose the raw commandline to unprivileged processes.</span></span><br><span class=\"line\">    <span class=\"comment\">// 设置文件权限, 分析见 2.2.1</span></span><br><span class=\"line\">    CHECKCALL(chmod(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, <span class=\"number\">0440</span>));</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> cmdline;</span><br><span class=\"line\">    android::base::ReadFileToString(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, &amp;cmdline);</span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t expose the raw bootconfig to unprivileged processes.</span></span><br><span class=\"line\">    chmod(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, <span class=\"number\">0440</span>);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootconfig;</span><br><span class=\"line\">    android::base::ReadFileToString(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, &amp;bootconfig);</span><br><span class=\"line\">    <span class=\"keyword\">gid_t</span> groups[] = &#123;AID_READPROC&#125;;</span><br><span class=\"line\">    CHECKCALL(setgroups(arraysize(groups), groups));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;sysfs&quot;</span>, <span class=\"string\">&quot;/sys&quot;</span>, <span class=\"string\">&quot;sysfs&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;selinuxfs&quot;</span>, <span class=\"string\">&quot;/sys/fs/selinux&quot;</span>, <span class=\"string\">&quot;selinuxfs&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/kmsg&quot;</span>, S_IFCHR | <span class=\"number\">0600</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">11</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">if</span> <span class=\"title\">constexpr</span> <span class=\"params\">(WORLD_WRITABLE_KMSG)</span> </span>&#123;</span><br><span class=\"line\">        CHECKCALL(mknod(<span class=\"string\">&quot;/dev/kmsg_debug&quot;</span>, S_IFCHR | <span class=\"number\">0622</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">11</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/random&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">8</span>)));</span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/urandom&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">9</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This is needed for log wrapper, which gets called before ueventd runs.</span></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/ptmx&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">5</span>, <span class=\"number\">2</span>)));</span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/null&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">3</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// These below mounts are done in first stage init so that first stage mount can mount</span></span><br><span class=\"line\">    <span class=\"comment\">// subdirectories of /mnt/&#123;vendor,product&#125;/.  Other mounts, not required by first stage mount,</span></span><br><span class=\"line\">    <span class=\"comment\">// should be done in rc files.</span></span><br><span class=\"line\">    <span class=\"comment\">// Mount staging areas for devices managed by vold</span></span><br><span class=\"line\">    <span class=\"comment\">// See storage config details at http://source.android.com/devices/storage/</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/mnt&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=1000&quot;</span>));</span><br><span class=\"line\">    <span class=\"comment\">// /mnt/vendor is used to mount vendor-specific partitions that can not be</span></span><br><span class=\"line\">    <span class=\"comment\">// part of the vendor partition, e.g. because they are mounted read-write.</span></span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/mnt/vendor&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    <span class=\"comment\">// /mnt/product is used to mount product-specific partitions that can not be</span></span><br><span class=\"line\">    <span class=\"comment\">// part of the product partition, e.g. because they are mounted read-write.</span></span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/mnt/product&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /debug_ramdisk is used to preserve additional files from the debug ramdisk</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/debug_ramdisk&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=0&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /second_stage_resources is used to preserve files from first to second</span></span><br><span class=\"line\">    <span class=\"comment\">// stage init</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, kSecondStageRes, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=0&quot;</span>))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> CHECKCALL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    SetStdioToDevNull(argv);</span><br><span class=\"line\">    <span class=\"comment\">// Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually</span></span><br><span class=\"line\">    <span class=\"comment\">// talk to the outside world...</span></span><br><span class=\"line\">    InitKernelLogging(argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!errors.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; [error_string, error_errno] : errors) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; error_string &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; strerror(error_errno);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;Init encountered errors starting first stage, aborting&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG(INFO) &lt;&lt; <span class=\"string\">&quot;init first stage started!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 /system/bin/init/selinux_setup, 初始化 SELinux</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;selinux_setup&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> fd = open(<span class=\"string\">&quot;/dev/kmsg&quot;</span>, O_WRONLY | O_CLOEXEC);</span><br><span class=\"line\">    dup2(fd, STDOUT_FILENO);</span><br><span class=\"line\">    dup2(fd, STDERR_FILENO);</span><br><span class=\"line\">    close(fd);</span><br><span class=\"line\">    execv(path, <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">char</span>**&gt;(args));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// execv() only returns if an error happened, in which case we</span></span><br><span class=\"line\">    <span class=\"comment\">// panic and never fall through this conditional.</span></span><br><span class=\"line\">    PLOG(FATAL) &lt;&lt; <span class=\"string\">&quot;execv(\\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class=\"string\">&quot;\\&quot;) failed&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数的主要工作有：挂载文件系统，初始化 SELinux。</p>\n<h3 id=\"2-2-1-设置文件或目录的权限\"><a href=\"#2-2-1-设置文件或目录的权限\" class=\"headerlink\" title=\"2.2.1 设置文件或目录的权限\"></a>2.2.1 设置文件或目录的权限</h3><p>在 Linux 系统上，<code>chmod</code> 命令用于控制用户对文件或者目录的权限，但只有文件所有者和超级用户可以修改文件或目录的权限。</p>\n<p>权限分为三类：读，写，执行。</p>\n<h4 id=\"2-2-1-1-符号表示法\"><a href=\"#2-2-1-1-符号表示法\" class=\"headerlink\" title=\"2.2.1.1 符号表示法\"></a>2.2.1.1 符号表示法</h4><p>符号表示法用 10 位字符表示权限，其形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rwxrwxrwx</span><br></pre></td></tr></table></figure>\n<p>其中第一个字符表示文件类型，常见的符号有：</p>\n<ul>\n<li><code>-</code>，表示普通文件。</li>\n<li><code>d</code>，表示目录。</li>\n<li><code>c</code>，表示字符特殊文件。</li>\n</ul>\n<p>剩余的 9 个字符，每 3 个字符分为一组，分别表示用户，用户组，其他用户的权限。</p>\n<p>3 个字符组成的字符串，第 1 位控制读权限，第 2 位控制写权限，第 3 位控制执行权限：</p>\n<ul>\n<li>如果拥有读权限，第 1 位字符为 <code>r</code>；否则为 <code>-</code>。</li>\n<li>如果拥有写权限，第 2 位字符为 <code>w</code>；否则为 <code>-</code>。</li>\n<li>如果拥有读权限，第 3 位字符为 <code>r</code>；否则为 <code>-</code>。</li>\n</ul>\n<p>示例：</p>\n<p><code>-rwxrw-r--</code>，表示一个普通文件，用户拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。</p>\n<h4 id=\"2-2-1-2-数字表示法\"><a href=\"#2-2-1-2-数字表示法\" class=\"headerlink\" title=\"2.2.1.2 数字表示法\"></a>2.2.1.2 数字表示法</h4><p>可以用 4 位八进制数字表示权限，第 1 位同样表示文件类型，剩余的 3 位数字，分别表示用户，用户组，其他用户的权限。</p>\n<p>读，写，执行，这 3 类权限可以使用 3 位二进制数字表示，不同类型的权限单独对应二进制数字中一个位：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数值</th>\n<th align=\"center\">权限</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">二进制：100，八进制：4</td>\n<td align=\"center\">r</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：010，八进制：2</td>\n<td align=\"center\">w</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：001，八进制：1</td>\n<td align=\"center\">x</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：000，八进制：0</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p>在各类权限对应的数值之和，可以代表一组特定的权限。由于和的数值范围为 0~7，因此可以通过一个八进制数字表示。示例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数值</th>\n<th align=\"center\">权限</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">二进制：111，八进制：7</td>\n<td align=\"center\">rwx</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：110，八进制：6</td>\n<td align=\"center\">rw-</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：101，八进制：5</td>\n<td align=\"center\">r-x</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：000，八进制：0</td>\n<td align=\"center\">—</td>\n</tr>\n</tbody></table>\n<p>因此，用符号表示法表示的权限，同样可以使用数字表示法去表示，示例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号表示法</th>\n<th align=\"center\">数字表示法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-rwxrwxrwx</td>\n<td align=\"center\">0777</td>\n<td align=\"center\">一个普通文件，用户，用户组，其他用户都有读，写，执行的权限</td>\n</tr>\n<tr>\n<td align=\"center\">-rwxrw-r–</td>\n<td align=\"center\">0764</td>\n<td align=\"center\">一个普通文件，用户拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-2-1-3-分析源码中的权限设置\"><a href=\"#2-2-1-3-分析源码中的权限设置\" class=\"headerlink\" title=\"2.2.1.3 分析源码中的权限设置\"></a>2.2.1.3 分析源码中的权限设置</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Don&#x27;t expose the raw commandline to unprivileged processes.</span></span><br><span class=\"line\">CHECKCALL(chmod(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, <span class=\"number\">0440</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Don&#x27;t expose the raw bootconfig to unprivileged processes.</span></span><br><span class=\"line\">chmod(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, <span class=\"number\">0440</span>);</span><br></pre></td></tr></table></figure>\n<p>在源码中有两处使用到 <code>chmod</code> 命令，分别对文件 <code>/proc/cmdline, /proc/bootconfig</code> 设置了权限 <code>0440</code>，表明root 用户及其用户组也只有文件的读权限。</p>\n<h2 id=\"2-3-初始化-SELinux\"><a href=\"#2-3-初始化-SELinux\" class=\"headerlink\" title=\"2.3 初始化 SELinux\"></a>2.3 初始化 SELinux</h2><p>初始化 SELinux 会执行 <code>int SetupSelinux(char** argv)</code>，源代码路径为 <code>system/core/init/selinux.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This function initializes SELinux then execs init to run in the init SELinux context.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SetupSelinux</span><span class=\"params\">(<span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    InitKernelLogging(argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class=\"line\">        InstallRebootSignalHandlers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set up SELinux, loading the SELinux policy.</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 SELinux</span></span><br><span class=\"line\">    SelinuxSetupKernelLogging();</span><br><span class=\"line\">    SelinuxInitialize();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 /system/bin/init/second_stage, 进入第二阶段</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;second_stage&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    execv(path, <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">char</span>**&gt;(args));</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数首先是初始化 SELinux，然后执行 <code>/system/bin/init/second_stage</code>，进入启动的第二阶段。</p>\n<h2 id=\"2-4-启动的第二阶段\"><a href=\"#2-4-启动的第二阶段\" class=\"headerlink\" title=\"2.4 启动的第二阶段\"></a>2.4 启动的第二阶段</h2><p>启动的第二阶段会执行 <code>int SecondStageMain(int argc, char** argv)</code>，源代码路径为 <code>system/core/init/init.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class=\"line\">        InstallRebootSignalHandlers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SetStdioToDevNull(argv);</span><br><span class=\"line\">    InitKernelLogging(argv);</span><br><span class=\"line\">    LOG(INFO) &lt;&lt; <span class=\"string\">&quot;init second stage started!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Now set up SELinux for second stage.</span></span><br><span class=\"line\">    <span class=\"comment\">// 为第二阶段设置 SeLinux</span></span><br><span class=\"line\">    SelinuxSetupKernelLogging();</span><br><span class=\"line\">    SelabelInitialize();</span><br><span class=\"line\">    SelinuxRestoreContext();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    subcontexts = InitializeSubcontexts();</span><br><span class=\"line\"></span><br><span class=\"line\">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class=\"line\">    ServiceList&amp; sm = ServiceList::GetInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 加载 init.rc 脚本文件, 分析见 2.4.1</span></span><br><span class=\"line\">    LoadBootScripts(am, sm);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueBuiltinAction(SetupCgroupsAction, <span class=\"string\">&quot;SetupCgroups&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;early-init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span></span><br><span class=\"line\">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class=\"string\">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... so that we can start queuing up actions that require stuff from /dev.</span></span><br><span class=\"line\">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class=\"string\">&quot;MixHwrngIntoLinuxRng&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(SetMmapRndBitsAction, <span class=\"string\">&quot;SetMmapRndBits&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(SetKptrRestrictAction, <span class=\"string\">&quot;SetKptrRestrict&quot;</span>);</span><br><span class=\"line\">    Keychords keychords;</span><br><span class=\"line\">    am.QueueBuiltinAction(</span><br><span class=\"line\">        [&amp;epoll, &amp;keychords](<span class=\"keyword\">const</span> BuiltinArguments&amp; args) -&gt; Result&lt;Success&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; svc : ServiceList::GetInstance()) &#123;</span><br><span class=\"line\">                keychords.Register(svc-&gt;keycodes());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            keychords.Start(&amp;epoll, HandleKeychord);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;KeychordInit&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(console_init_action, <span class=\"string\">&quot;console_init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Trigger all the boot actions to get us started.</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Starting the BoringSSL self test, for NIAP certification compliance.</span></span><br><span class=\"line\">    am.QueueBuiltinAction(StartBoringSslSelfTest, <span class=\"string\">&quot;StartBoringSslSelfTest&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span></span><br><span class=\"line\">    <span class=\"comment\">// wasn&#x27;t ready immediately after wait_for_coldboot_done</span></span><br><span class=\"line\">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class=\"string\">&quot;MixHwrngIntoLinuxRng&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialize binder before bringing up other system services</span></span><br><span class=\"line\">    am.QueueBuiltinAction(InitBinder, <span class=\"string\">&quot;InitBinder&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t mount filesystems or start core system services in charger mode.</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootmode = GetProperty(<span class=\"string\">&quot;ro.bootmode&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootmode == <span class=\"string\">&quot;charger&quot;</span>) &#123;</span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;charger&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;late-init&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Run all property triggers based on current state of the properties.</span></span><br><span class=\"line\">    am.QueueBuiltinAction(queue_property_triggers_action, <span class=\"string\">&quot;queue_property_triggers&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// By default, sleep until something happens.</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> epoll_timeout = <span class=\"built_in\">std</span>::optional&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (do_shutdown &amp;&amp; !shutting_down) &#123;</span><br><span class=\"line\">            do_shutdown = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (HandlePowerctlMessage(shutdown_command)) &#123;</span><br><span class=\"line\">                shutting_down = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            am.ExecuteOneCommand();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!shutting_down) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> next_process_action_time = HandleProcessActions();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// If there&#x27;s a process that needs restarting, wake up in time for that.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next_process_action_time) &#123;</span><br><span class=\"line\">                    epoll_timeout = <span class=\"built_in\">std</span>::chrono::<span class=\"built_in\">ceil</span>&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;(</span><br><span class=\"line\">                            *next_process_action_time - boot_clock::now());</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (*epoll_timeout &lt; <span class=\"number\">0</span>ms) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// If there&#x27;s more work to do, wake up again immediately.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (am.HasMoreCommands()) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Wait(epoll_timeout); !result) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; result.error();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-4-1-加载-init-rc-脚本文件\"><a href=\"#2-4-1-加载-init-rc-脚本文件\" class=\"headerlink\" title=\"2.4.1 加载 init.rc 脚本文件\"></a>2.4.1 加载 init.rc 脚本文件</h3><p>加载 init.rc 脚本文件会执行 <code>void LoadBootScripts(ActionManager&amp; action_manager, ServiceList&amp; service_list)</code>，源代码路径为 <code>system/core/init/init.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">LoadBootScripts</span><span class=\"params\">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class=\"line\">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootscript = GetProperty(<span class=\"string\">&quot;ro.boot.init_rc&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootscript.empty()) &#123;</span><br><span class=\"line\">        parser.ParseConfig(<span class=\"string\">&quot;/init.rc&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/system/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/system/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/odm/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/odm/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        parser.ParseConfig(bootscript);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://gityuan.com/2016/02/01/android-booting/\">Android系统启动-综述</a></p>\n<p><a href=\"http://gityuan.com/2016/02/13/android-zygote/\">Android系统启动-zygote篇</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文基于源代码: android-security-10.0.0_r56</p>\n</blockquote>\n<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>Android 基于 Linux 内核，在内核启动过程中会创建出 init 进程。之后，init 进程会解析 <code>init.rc</code> 脚本文件，进而启动 Zygote 进程。Zygote 启动完成后，监听来自客户端的请求，接收到后立即唤醒并执行相应工作。</p>\n<!-- TODO -->","more":"<h1 id=\"2-简析-init-进程的启动流程\"><a href=\"#2-简析-init-进程的启动流程\" class=\"headerlink\" title=\"2. 简析 init 进程的启动流程\"></a>2. 简析 init 进程的启动流程</h1><p>init 进程由内核启动，是系统用户空间的第一个进程，其进程的 pid 为 1。</p>\n<h2 id=\"2-1-init-进程的入口\"><a href=\"#2-1-init-进程的入口\" class=\"headerlink\" title=\"2.1 init 进程的入口\"></a>2.1 init 进程的入口</h2><p>在 Android 9，init 进程的入口位于 <code>system/core/init/init.cpp</code> 中的 main 函数。</p>\n<p>在 Android 10 之后，init 进程的入口改到了 <code>system/core/init/main.cpp</code> 中的 main 函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(basename(argv[<span class=\"number\">0</span>]), <span class=\"string\">&quot;ueventd&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ueventd_main(argc, argv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;subcontext&quot;</span>)) &#123;</span><br><span class=\"line\">            android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class=\"line\">            <span class=\"keyword\">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> SubcontextMain(argc, argv, &amp;function_map);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;selinux_setup&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SetupSelinux(argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;second_stage&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SecondStageMain(argc, argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> FirstStageMain(argc, argv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，<code>argc</code> 表示命令行参数的个数，<code>argv</code> 则是传入的参数，<code>argv[0]</code> 是程序的全路径名，<code>arg[1]</code> 才是实际意义上的第一个参数。</p>\n<blockquote>\n<p><code>strcmp(str1, str2)</code> 是字符串比较函数，返回值为整数。当两个字符串相等时，函数返回 0。</p>\n<p><code>basename(path)</code> 函数可以根据给定的一个路径，返回文件名。例如：传入参数 “/system/bin/ueventd”，函数返回 “ueventd”。</p>\n</blockquote>\n<p><code>main</code> 函数会根据传入的参数，选择执行方式：</p>\n<ol>\n<li>如果从路径参数 <code>argv[0]</code> 解析出 “ueventd”，执行 <code>ueventd_main(argc, argv)</code></li>\n<li>如果带参启动 <code>init</code>，执行 <code>SubcontextMain(argc, argv, &amp;function_map)</code>，<code>SetupSelinux(argv)</code>，<code>SecondStageMain(argc, argv)</code> 中的一个</li>\n<li>否则，默认执行 <code>FirstStageMain(argc, argv)</code></li>\n</ol>\n<h2 id=\"2-2-启动的第一阶段\"><a href=\"#2-2-启动的第一阶段\" class=\"headerlink\" title=\"2.2 启动的第一阶段\"></a>2.2 启动的第一阶段</h2><p>启动的第一阶段会执行 <code>int FirstStageMain(int argc, char** argv)</code>，源代码路径为 <code>system/core/init/first_stage_init.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FirstStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(clearenv());</span><br><span class=\"line\">    CHECKCALL(setenv(<span class=\"string\">&quot;PATH&quot;</span>, _PATH_DEFPATH, <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"comment\">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class=\"line\">    <span class=\"comment\">// on / and then we&#x27;ll let the rc file figure out the rest.</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/dev&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class=\"string\">&quot;mode=0755&quot;</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/pts&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/socket&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/dm-user&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;devpts&quot;</span>, <span class=\"string\">&quot;/dev/pts&quot;</span>, <span class=\"string\">&quot;devpts&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;proc&quot;</span>, <span class=\"string\">&quot;/proc&quot;</span>, <span class=\"string\">&quot;proc&quot;</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;hidepid=2,gid=&quot;</span> MAKE_STR(AID_READPROC)));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> MAKE_STR</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t expose the raw commandline to unprivileged processes.</span></span><br><span class=\"line\">    <span class=\"comment\">// 设置文件权限, 分析见 2.2.1</span></span><br><span class=\"line\">    CHECKCALL(chmod(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, <span class=\"number\">0440</span>));</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> cmdline;</span><br><span class=\"line\">    android::base::ReadFileToString(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, &amp;cmdline);</span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t expose the raw bootconfig to unprivileged processes.</span></span><br><span class=\"line\">    chmod(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, <span class=\"number\">0440</span>);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootconfig;</span><br><span class=\"line\">    android::base::ReadFileToString(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, &amp;bootconfig);</span><br><span class=\"line\">    <span class=\"keyword\">gid_t</span> groups[] = &#123;AID_READPROC&#125;;</span><br><span class=\"line\">    CHECKCALL(setgroups(arraysize(groups), groups));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;sysfs&quot;</span>, <span class=\"string\">&quot;/sys&quot;</span>, <span class=\"string\">&quot;sysfs&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;selinuxfs&quot;</span>, <span class=\"string\">&quot;/sys/fs/selinux&quot;</span>, <span class=\"string\">&quot;selinuxfs&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/kmsg&quot;</span>, S_IFCHR | <span class=\"number\">0600</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">11</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">if</span> <span class=\"title\">constexpr</span> <span class=\"params\">(WORLD_WRITABLE_KMSG)</span> </span>&#123;</span><br><span class=\"line\">        CHECKCALL(mknod(<span class=\"string\">&quot;/dev/kmsg_debug&quot;</span>, S_IFCHR | <span class=\"number\">0622</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">11</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/random&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">8</span>)));</span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/urandom&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">9</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This is needed for log wrapper, which gets called before ueventd runs.</span></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/ptmx&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">5</span>, <span class=\"number\">2</span>)));</span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/null&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">3</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// These below mounts are done in first stage init so that first stage mount can mount</span></span><br><span class=\"line\">    <span class=\"comment\">// subdirectories of /mnt/&#123;vendor,product&#125;/.  Other mounts, not required by first stage mount,</span></span><br><span class=\"line\">    <span class=\"comment\">// should be done in rc files.</span></span><br><span class=\"line\">    <span class=\"comment\">// Mount staging areas for devices managed by vold</span></span><br><span class=\"line\">    <span class=\"comment\">// See storage config details at http://source.android.com/devices/storage/</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/mnt&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=1000&quot;</span>));</span><br><span class=\"line\">    <span class=\"comment\">// /mnt/vendor is used to mount vendor-specific partitions that can not be</span></span><br><span class=\"line\">    <span class=\"comment\">// part of the vendor partition, e.g. because they are mounted read-write.</span></span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/mnt/vendor&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    <span class=\"comment\">// /mnt/product is used to mount product-specific partitions that can not be</span></span><br><span class=\"line\">    <span class=\"comment\">// part of the product partition, e.g. because they are mounted read-write.</span></span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/mnt/product&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /debug_ramdisk is used to preserve additional files from the debug ramdisk</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/debug_ramdisk&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=0&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /second_stage_resources is used to preserve files from first to second</span></span><br><span class=\"line\">    <span class=\"comment\">// stage init</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, kSecondStageRes, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=0&quot;</span>))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> CHECKCALL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    SetStdioToDevNull(argv);</span><br><span class=\"line\">    <span class=\"comment\">// Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually</span></span><br><span class=\"line\">    <span class=\"comment\">// talk to the outside world...</span></span><br><span class=\"line\">    InitKernelLogging(argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!errors.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; [error_string, error_errno] : errors) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; error_string &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; strerror(error_errno);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;Init encountered errors starting first stage, aborting&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG(INFO) &lt;&lt; <span class=\"string\">&quot;init first stage started!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 /system/bin/init/selinux_setup, 初始化 SELinux</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;selinux_setup&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> fd = open(<span class=\"string\">&quot;/dev/kmsg&quot;</span>, O_WRONLY | O_CLOEXEC);</span><br><span class=\"line\">    dup2(fd, STDOUT_FILENO);</span><br><span class=\"line\">    dup2(fd, STDERR_FILENO);</span><br><span class=\"line\">    close(fd);</span><br><span class=\"line\">    execv(path, <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">char</span>**&gt;(args));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// execv() only returns if an error happened, in which case we</span></span><br><span class=\"line\">    <span class=\"comment\">// panic and never fall through this conditional.</span></span><br><span class=\"line\">    PLOG(FATAL) &lt;&lt; <span class=\"string\">&quot;execv(\\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class=\"string\">&quot;\\&quot;) failed&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数的主要工作有：挂载文件系统，初始化 SELinux。</p>\n<h3 id=\"2-2-1-设置文件或目录的权限\"><a href=\"#2-2-1-设置文件或目录的权限\" class=\"headerlink\" title=\"2.2.1 设置文件或目录的权限\"></a>2.2.1 设置文件或目录的权限</h3><p>在 Linux 系统上，<code>chmod</code> 命令用于控制用户对文件或者目录的权限，但只有文件所有者和超级用户可以修改文件或目录的权限。</p>\n<p>权限分为三类：读，写，执行。</p>\n<h4 id=\"2-2-1-1-符号表示法\"><a href=\"#2-2-1-1-符号表示法\" class=\"headerlink\" title=\"2.2.1.1 符号表示法\"></a>2.2.1.1 符号表示法</h4><p>符号表示法用 10 位字符表示权限，其形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rwxrwxrwx</span><br></pre></td></tr></table></figure>\n<p>其中第一个字符表示文件类型，常见的符号有：</p>\n<ul>\n<li><code>-</code>，表示普通文件。</li>\n<li><code>d</code>，表示目录。</li>\n<li><code>c</code>，表示字符特殊文件。</li>\n</ul>\n<p>剩余的 9 个字符，每 3 个字符分为一组，分别表示用户，用户组，其他用户的权限。</p>\n<p>3 个字符组成的字符串，第 1 位控制读权限，第 2 位控制写权限，第 3 位控制执行权限：</p>\n<ul>\n<li>如果拥有读权限，第 1 位字符为 <code>r</code>；否则为 <code>-</code>。</li>\n<li>如果拥有写权限，第 2 位字符为 <code>w</code>；否则为 <code>-</code>。</li>\n<li>如果拥有读权限，第 3 位字符为 <code>r</code>；否则为 <code>-</code>。</li>\n</ul>\n<p>示例：</p>\n<p><code>-rwxrw-r--</code>，表示一个普通文件，用户拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。</p>\n<h4 id=\"2-2-1-2-数字表示法\"><a href=\"#2-2-1-2-数字表示法\" class=\"headerlink\" title=\"2.2.1.2 数字表示法\"></a>2.2.1.2 数字表示法</h4><p>可以用 4 位八进制数字表示权限，第 1 位同样表示文件类型，剩余的 3 位数字，分别表示用户，用户组，其他用户的权限。</p>\n<p>读，写，执行，这 3 类权限可以使用 3 位二进制数字表示，不同类型的权限单独对应二进制数字中一个位：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数值</th>\n<th align=\"center\">权限</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">二进制：100，八进制：4</td>\n<td align=\"center\">r</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：010，八进制：2</td>\n<td align=\"center\">w</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：001，八进制：1</td>\n<td align=\"center\">x</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：000，八进制：0</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p>在各类权限对应的数值之和，可以代表一组特定的权限。由于和的数值范围为 0~7，因此可以通过一个八进制数字表示。示例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数值</th>\n<th align=\"center\">权限</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">二进制：111，八进制：7</td>\n<td align=\"center\">rwx</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：110，八进制：6</td>\n<td align=\"center\">rw-</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：101，八进制：5</td>\n<td align=\"center\">r-x</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：000，八进制：0</td>\n<td align=\"center\">—</td>\n</tr>\n</tbody></table>\n<p>因此，用符号表示法表示的权限，同样可以使用数字表示法去表示，示例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号表示法</th>\n<th align=\"center\">数字表示法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-rwxrwxrwx</td>\n<td align=\"center\">0777</td>\n<td align=\"center\">一个普通文件，用户，用户组，其他用户都有读，写，执行的权限</td>\n</tr>\n<tr>\n<td align=\"center\">-rwxrw-r–</td>\n<td align=\"center\">0764</td>\n<td align=\"center\">一个普通文件，用户拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-2-1-3-分析源码中的权限设置\"><a href=\"#2-2-1-3-分析源码中的权限设置\" class=\"headerlink\" title=\"2.2.1.3 分析源码中的权限设置\"></a>2.2.1.3 分析源码中的权限设置</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Don&#x27;t expose the raw commandline to unprivileged processes.</span></span><br><span class=\"line\">CHECKCALL(chmod(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, <span class=\"number\">0440</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Don&#x27;t expose the raw bootconfig to unprivileged processes.</span></span><br><span class=\"line\">chmod(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, <span class=\"number\">0440</span>);</span><br></pre></td></tr></table></figure>\n<p>在源码中有两处使用到 <code>chmod</code> 命令，分别对文件 <code>/proc/cmdline, /proc/bootconfig</code> 设置了权限 <code>0440</code>，表明root 用户及其用户组也只有文件的读权限。</p>\n<h2 id=\"2-3-初始化-SELinux\"><a href=\"#2-3-初始化-SELinux\" class=\"headerlink\" title=\"2.3 初始化 SELinux\"></a>2.3 初始化 SELinux</h2><p>初始化 SELinux 会执行 <code>int SetupSelinux(char** argv)</code>，源代码路径为 <code>system/core/init/selinux.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This function initializes SELinux then execs init to run in the init SELinux context.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SetupSelinux</span><span class=\"params\">(<span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    InitKernelLogging(argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class=\"line\">        InstallRebootSignalHandlers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set up SELinux, loading the SELinux policy.</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 SELinux</span></span><br><span class=\"line\">    SelinuxSetupKernelLogging();</span><br><span class=\"line\">    SelinuxInitialize();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 /system/bin/init/second_stage, 进入第二阶段</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;second_stage&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    execv(path, <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">char</span>**&gt;(args));</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数首先是初始化 SELinux，然后执行 <code>/system/bin/init/second_stage</code>，进入启动的第二阶段。</p>\n<h2 id=\"2-4-启动的第二阶段\"><a href=\"#2-4-启动的第二阶段\" class=\"headerlink\" title=\"2.4 启动的第二阶段\"></a>2.4 启动的第二阶段</h2><p>启动的第二阶段会执行 <code>int SecondStageMain(int argc, char** argv)</code>，源代码路径为 <code>system/core/init/init.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class=\"line\">        InstallRebootSignalHandlers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SetStdioToDevNull(argv);</span><br><span class=\"line\">    InitKernelLogging(argv);</span><br><span class=\"line\">    LOG(INFO) &lt;&lt; <span class=\"string\">&quot;init second stage started!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Now set up SELinux for second stage.</span></span><br><span class=\"line\">    <span class=\"comment\">// 为第二阶段设置 SeLinux</span></span><br><span class=\"line\">    SelinuxSetupKernelLogging();</span><br><span class=\"line\">    SelabelInitialize();</span><br><span class=\"line\">    SelinuxRestoreContext();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    subcontexts = InitializeSubcontexts();</span><br><span class=\"line\"></span><br><span class=\"line\">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class=\"line\">    ServiceList&amp; sm = ServiceList::GetInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 加载 init.rc 脚本文件, 分析见 2.4.1</span></span><br><span class=\"line\">    LoadBootScripts(am, sm);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueBuiltinAction(SetupCgroupsAction, <span class=\"string\">&quot;SetupCgroups&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;early-init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span></span><br><span class=\"line\">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class=\"string\">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... so that we can start queuing up actions that require stuff from /dev.</span></span><br><span class=\"line\">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class=\"string\">&quot;MixHwrngIntoLinuxRng&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(SetMmapRndBitsAction, <span class=\"string\">&quot;SetMmapRndBits&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(SetKptrRestrictAction, <span class=\"string\">&quot;SetKptrRestrict&quot;</span>);</span><br><span class=\"line\">    Keychords keychords;</span><br><span class=\"line\">    am.QueueBuiltinAction(</span><br><span class=\"line\">        [&amp;epoll, &amp;keychords](<span class=\"keyword\">const</span> BuiltinArguments&amp; args) -&gt; Result&lt;Success&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; svc : ServiceList::GetInstance()) &#123;</span><br><span class=\"line\">                keychords.Register(svc-&gt;keycodes());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            keychords.Start(&amp;epoll, HandleKeychord);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;KeychordInit&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(console_init_action, <span class=\"string\">&quot;console_init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Trigger all the boot actions to get us started.</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Starting the BoringSSL self test, for NIAP certification compliance.</span></span><br><span class=\"line\">    am.QueueBuiltinAction(StartBoringSslSelfTest, <span class=\"string\">&quot;StartBoringSslSelfTest&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span></span><br><span class=\"line\">    <span class=\"comment\">// wasn&#x27;t ready immediately after wait_for_coldboot_done</span></span><br><span class=\"line\">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class=\"string\">&quot;MixHwrngIntoLinuxRng&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialize binder before bringing up other system services</span></span><br><span class=\"line\">    am.QueueBuiltinAction(InitBinder, <span class=\"string\">&quot;InitBinder&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t mount filesystems or start core system services in charger mode.</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootmode = GetProperty(<span class=\"string\">&quot;ro.bootmode&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootmode == <span class=\"string\">&quot;charger&quot;</span>) &#123;</span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;charger&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;late-init&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Run all property triggers based on current state of the properties.</span></span><br><span class=\"line\">    am.QueueBuiltinAction(queue_property_triggers_action, <span class=\"string\">&quot;queue_property_triggers&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// By default, sleep until something happens.</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> epoll_timeout = <span class=\"built_in\">std</span>::optional&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (do_shutdown &amp;&amp; !shutting_down) &#123;</span><br><span class=\"line\">            do_shutdown = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (HandlePowerctlMessage(shutdown_command)) &#123;</span><br><span class=\"line\">                shutting_down = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            am.ExecuteOneCommand();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!shutting_down) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> next_process_action_time = HandleProcessActions();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// If there&#x27;s a process that needs restarting, wake up in time for that.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next_process_action_time) &#123;</span><br><span class=\"line\">                    epoll_timeout = <span class=\"built_in\">std</span>::chrono::<span class=\"built_in\">ceil</span>&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;(</span><br><span class=\"line\">                            *next_process_action_time - boot_clock::now());</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (*epoll_timeout &lt; <span class=\"number\">0</span>ms) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// If there&#x27;s more work to do, wake up again immediately.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (am.HasMoreCommands()) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Wait(epoll_timeout); !result) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; result.error();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-4-1-加载-init-rc-脚本文件\"><a href=\"#2-4-1-加载-init-rc-脚本文件\" class=\"headerlink\" title=\"2.4.1 加载 init.rc 脚本文件\"></a>2.4.1 加载 init.rc 脚本文件</h3><p>加载 init.rc 脚本文件会执行 <code>void LoadBootScripts(ActionManager&amp; action_manager, ServiceList&amp; service_list)</code>，源代码路径为 <code>system/core/init/init.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">LoadBootScripts</span><span class=\"params\">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class=\"line\">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootscript = GetProperty(<span class=\"string\">&quot;ro.boot.init_rc&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootscript.empty()) &#123;</span><br><span class=\"line\">        parser.ParseConfig(<span class=\"string\">&quot;/init.rc&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/system/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/system/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/odm/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/odm/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        parser.ParseConfig(bootscript);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://gityuan.com/2016/02/01/android-booting/\">Android系统启动-综述</a></p>\n<p><a href=\"http://gityuan.com/2016/02/13/android-zygote/\">Android系统启动-zygote篇</a></p>"},{"title":"分析 Android Binder","mathjax":true,"_content":"","source":"_drafts/exploring-android-binder.md","raw":"---\ntitle: 分析 Android Binder\ncategories:\n- [Android, Framework, Binder]\nmathjax: true\n---\n","slug":"exploring-android-binder","published":0,"date":"2021-06-23T12:56:57.338Z","updated":"2021-08-18T06:49:11.269Z","_id":"cksh4vtpi000hqkprcbem8gz5","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分析 Android app 进程创建流程","_content":"\n\n\n> 本文基于源代码: android-security-10.0.0_r56\n\n\n\n## 1. 前言\n\n<!-- more -->\n\n\n\n### 1.1 前置知识\n\n<!-- TODO -->\n\n\n\n#### 1.1.1 Android 系统启动概述\n\n<!-- TODO -->\n\n\n\n#### 1.1.2 Linux fork\n\n<!-- TODO -->\n\n\n\n## 2. system_server 侧的逻辑\n\n<!-- TODO -->\n\nsystem_server 作为进程创建的发起方，入口在 ProcessList 当中，进程的启动流程最终会走到 `ProcessList.startProcess` 方法。\n\n\n\n### 2.1 ProcessList.startProcess(HostingRecord, String, ProcessRecord, int, int[], int, int, String, String, String, String, long)\n\n```java\nprivate Process.ProcessStartResult startProcess(HostingRecord hostingRecord, String entryPoint,\n        ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,\n        String seInfo, String requiredAbi, String instructionSet, String invokeWith,\n        long startTime) {\n    try {\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" +\n                app.processName);\n        checkSlow(startTime, \"startProcess: asking zygote to start proc\");\n        final Process.ProcessStartResult startResult;\n        if (hostingRecord.usesWebviewZygote()) {\n            startResult = startWebView(entryPoint,\n                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,\n                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,\n                    app.info.dataDir, null, app.info.packageName,\n                    new String[] {PROC_START_SEQ_IDENT + app.startSeq});\n        } else if (hostingRecord.usesAppZygote()) {\n            final AppZygote appZygote = createAppZygoteForProcessIfNeeded(app);\n\n            startResult = appZygote.getProcess().start(entryPoint,\n                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,\n                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,\n                    app.info.dataDir, null, app.info.packageName,\n                    /*useUsapPool=*/ false,\n                    new String[] {PROC_START_SEQ_IDENT + app.startSeq});\n        } else {\n            // 一般的进程启动流程会进入此分支\n            startResult = Process.start(entryPoint,\n                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,\n                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,\n                    app.info.dataDir, invokeWith, app.info.packageName,\n                    new String[] {PROC_START_SEQ_IDENT + app.startSeq});\n        }\n        checkSlow(startTime, \"startProcess: returned from zygote!\");\n        return startResult;\n    } finally {\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n    }\n}\n```\n\n一般的进程启动流程，会调用 `Process.start` 方法，创建新进程。\n\n\n\n### 2.2 Process.start(String, String, int, int, int[], int, int, int, String, String, String, String, String, String, String[])\n\n```java\npublic static ProcessStartResult start(@NonNull final String processClass,\n                                       @Nullable final String niceName,\n                                       int uid, int gid, @Nullable int[] gids,\n                                       int runtimeFlags,\n                                       int mountExternal,\n                                       int targetSdkVersion,\n                                       @Nullable String seInfo,\n                                       @NonNull String abi,\n                                       @Nullable String instructionSet,\n                                       @Nullable String appDataDir,\n                                       @Nullable String invokeWith,\n                                       @Nullable String packageName,\n                                       @Nullable String[] zygoteArgs) {\n    return ZYGOTE_PROCESS.start(processClass, niceName, uid, gid, gids,\n                runtimeFlags, mountExternal, targetSdkVersion, seInfo,\n                abi, instructionSet, appDataDir, invokeWith, packageName,\n                /*useUsapPool=*/ true, zygoteArgs);\n}\n```\n\n其中，`ZYGOTE_PROCESS` 是 ZygoteProcess 的实例：\n\n```java\n/**\n * State associated with the zygote process.\n * @hide\n */\npublic static final ZygoteProcess ZYGOTE_PROCESS = new ZygoteProcess();\n```\n\n再来看看 ZygoteProcess 的构造方法：\n\n```java\npublic ZygoteProcess() {\n    mZygoteSocketAddress =\n            new LocalSocketAddress(Zygote.PRIMARY_SOCKET_NAME,\n                                   LocalSocketAddress.Namespace.RESERVED);\n    mZygoteSecondarySocketAddress =\n            new LocalSocketAddress(Zygote.SECONDARY_SOCKET_NAME,\n                                   LocalSocketAddress.Namespace.RESERVED);\n\n    mUsapPoolSocketAddress =\n            new LocalSocketAddress(Zygote.USAP_POOL_PRIMARY_SOCKET_NAME,\n                                   LocalSocketAddress.Namespace.RESERVED);\n    mUsapPoolSecondarySocketAddress =\n            new LocalSocketAddress(Zygote.USAP_POOL_SECONDARY_SOCKET_NAME,\n                                   LocalSocketAddress.Namespace.RESERVED);\n}\n```\n\nZygoteProcess 的构造方法初始化了数个 Socket 地址，这些地址将会在与 Zygote 进程建立连接时用到。\n\n接下来分析 `ZygoteProcess.start` 方法。\n\n\n\n### 2.3 ZygoteProcess.start(String, String, int, int, int[], int, int, int, String, String, String, String, String, String, boolean, String[])\n\n```java\npublic final Process.ProcessStartResult start(@NonNull final String processClass,\n                                              final String niceName,\n                                              int uid, int gid, @Nullable int[] gids,\n                                              int runtimeFlags, int mountExternal,\n                                              int targetSdkVersion,\n                                              @Nullable String seInfo,\n                                              @NonNull String abi,\n                                              @Nullable String instructionSet,\n                                              @Nullable String appDataDir,\n                                              @Nullable String invokeWith,\n                                              @Nullable String packageName,\n                                              boolean useUsapPool,\n                                              @Nullable String[] zygoteArgs) {\n    // UASP 相关, 分析见 2.3.1\n    if (fetchUsapPoolEnabledPropWithMinInterval()) {\n        informZygotesOfUsapPoolStatus();\n    }\n\n    try {\n        return startViaZygote(processClass, niceName, uid, gid, gids,\n                runtimeFlags, mountExternal, targetSdkVersion, seInfo,\n                abi, instructionSet, appDataDir, invokeWith, /*startChildZygote=*/ false,\n                packageName, useUsapPool, zygoteArgs);\n    } catch (ZygoteStartFailedEx ex) {\n        Log.e(LOG_TAG,\n                \"Starting VM process through Zygote failed\");\n        throw new RuntimeException(\n                \"Starting VM process through Zygote failed\", ex);\n    }\n}\n```\n\n方法中有一段与 UASP 相关的逻辑，分析见 2.3.1，紧接着就会调用 `ZygoteProcess.startViaZygote` 方法。\n\n注意到，此方法还会把 `ZygoteProcess.startViaZygote` 方法可能抛出的 `ZygoteStartFailedEx` 转换成 `RuntimeException`。\n\n\n\n#### 2.3.1 ZygoteProcess.fetchUsapPoolEnabledPropWithMinInterval()\n\n```java\nprivate boolean fetchUsapPoolEnabledPropWithMinInterval() {\n    final long currentTimestamp = SystemClock.elapsedRealtime();\n\n    if (SystemProperties.get(\"dalvik.vm.boot-image\", \"\").endsWith(\"apex.art\")) {\n        if (currentTimestamp <= 15000) {\n            return false;\n        }\n    }\n\n    if (mIsFirstPropCheck\n            || (currentTimestamp - mLastPropCheckTimestamp >= Zygote.PROPERTY_CHECK_INTERVAL)) {\n        mIsFirstPropCheck = false;\n        mLastPropCheckTimestamp = currentTimestamp;\n      \n      \t// 返回是否开启 UsapPool 的判断结果, 分析见 2.3.1.1\n        return fetchUsapPoolEnabledProp();\n    }\n\n    return false;\n}\n```\n\n\n\n##### 2.3.1.1 ZygoteProcess.fetchUsapPoolEnabledProp()\n\n```java\nprivate boolean fetchUsapPoolEnabledProp() {\n    boolean origVal = mUsapPoolEnabled;\n\n    final String propertyString = Zygote.getConfigurationProperty(\n            ZygoteConfig.USAP_POOL_ENABLED, USAP_POOL_ENABLED_DEFAULT);\n\n    if (!propertyString.isEmpty()) {\n        mUsapPoolEnabled = Zygote.getConfigurationPropertyBoolean(\n              ZygoteConfig.USAP_POOL_ENABLED,\n              Boolean.parseBoolean(USAP_POOL_ENABLED_DEFAULT));\n    }\n\n    boolean valueChanged = origVal != mUsapPoolEnabled;\n\n    if (valueChanged) {\n        Log.i(LOG_TAG, \"usapPoolEnabled = \" + mUsapPoolEnabled);\n    }\n\n    return valueChanged;\n}\n```\n\n这个方法的主要目的是从系统配置文件中加载 UsapPool 的开启状态，而默认状态 `USAP_POOL_ENABLED_DEFAULT` 是 false，也就是说 UsapPool 默认是不开启的。\n\n因此，接下来的分析都会默认跳过 UASP 相关逻辑。\n\n\n\n### 2.4 ZygoteProcess.startViaZygote(String, String, int, int, int[], int, int, int, String, String, String, String, String, boolean, String, boolean, String[])\n\n```java\nprivate Process.ProcessStartResult startViaZygote(@NonNull final String processClass,\n                                                  @Nullable final String niceName,\n                                                  final int uid, final int gid,\n                                                  @Nullable final int[] gids,\n                                                  int runtimeFlags, int mountExternal,\n                                                  int targetSdkVersion,\n                                                  @Nullable String seInfo,\n                                                  @NonNull String abi,\n                                                  @Nullable String instructionSet,\n                                                  @Nullable String appDataDir,\n                                                  @Nullable String invokeWith,\n                                                  boolean startChildZygote,\n                                                  @Nullable String packageName,\n                                                  boolean useUsapPool,\n                                                  @Nullable String[] extraArgs)\n                                                  throws ZygoteStartFailedEx {\n    ArrayList<String> argsForZygote = new ArrayList<>();\n\n    // --runtime-args, --setuid=, --setgid=,\n    // and --setgroups= must go first\n    argsForZygote.add(\"--runtime-args\");\n    argsForZygote.add(\"--setuid=\" + uid);\n    argsForZygote.add(\"--setgid=\" + gid);\n    argsForZygote.add(\"--runtime-flags=\" + runtimeFlags);\n\n    ...\n\n    synchronized(mLock) {\n      \t// openZygoteSocketIfNeeded 方法分析见 2.4.1\n        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi),\n                                          useUsapPool,\n                                          argsForZygote);\n    }\n}\n```\n\n这个方法的主要目的是将 uid, gid 等参数保存在数组 `argsForZygote` 当中，接下来将会用到这些参数。\n\n\n\n#### 2.4.1 ZygoteProcess.openZygoteSocketIfNeeded(String)\n\n```java\n@GuardedBy(\"mLock\")\nprivate ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {\n    try {\n        attemptConnectionToPrimaryZygote();\n\n        if (primaryZygoteState.matches(abi)) {\n            return primaryZygoteState;\n        }\n\n        if (mZygoteSecondarySocketAddress != null) {\n            // The primary zygote didn't match. Try the secondary.\n            attemptConnectionToSecondaryZygote();\n\n            if (secondaryZygoteState.matches(abi)) {\n                return secondaryZygoteState;\n            }\n        }\n    } catch (IOException ioe) {\n        throw new ZygoteStartFailedEx(\"Error connecting to zygote\", ioe);\n    }\n\n    throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);\n}\n```\n\n此方法主要目的是尝试与 Zygote 进程建立连接，如果失败，将会抛出异常。\n\n注意到，方法的注解 `@GuardedBy(\"mLock\")` 表明外部在调用此方法之前需要对 `mLock` 加锁，以确保方法调用是同步的。\n\n\n\n### 2.5 ZygoteProcess.zygoteSendArgsAndGetResult(ZygoteState, boolean, ArrayList)\n\n```java\n@GuardedBy(\"mLock\")\nprivate Process.ProcessStartResult zygoteSendArgsAndGetResult(\n        ZygoteState zygoteState, boolean useUsapPool, @NonNull ArrayList<String> args)\n        throws ZygoteStartFailedEx {\n\n    // 检查参数中是否存在不合法字符\n    for (String arg : args) {\n        if (arg.indexOf('\\n') >= 0) {\n            throw new ZygoteStartFailedEx(\"Embedded newlines not allowed\");\n        } else if (arg.indexOf('\\r') >= 0) {\n            throw new ZygoteStartFailedEx(\"Embedded carriage returns not allowed\");\n        }\n    }\n\n    String msgStr = args.size() + \"\\n\" + String.join(\"\\n\", args) + \"\\n\";\n\n  \t...\n\n    return attemptZygoteSendArgsAndGetResult(zygoteState, msgStr);\n}\n```\n\n此方法检查参数的合法性，紧接着就调用了 `ZygoteProcess.attemptZygoteSendArgsAndGetResult` 方法。\n\n\n\n### 2.6 ZygoteProcess.attemptZygoteSendArgsAndGetResult(ZygoteState, String)\n\n```java\nprivate Process.ProcessStartResult attemptZygoteSendArgsAndGetResult(\n        ZygoteState zygoteState, String msgStr) throws ZygoteStartFailedEx {\n    try {\n      \t// 已经与 Zygote 进程建立了 Socket 连接, 此时两者间的通信就像读写文件流一样方便\n        final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;\n        final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;\n\n      \t// 往 Zygote 写入参数\n        zygoteWriter.write(msgStr);\n        zygoteWriter.flush();\n\n      \t// 读取结果\n        Process.ProcessStartResult result = new Process.ProcessStartResult();\n        result.pid = zygoteInputStream.readInt();\n        result.usingWrapper = zygoteInputStream.readBoolean();\n\n        if (result.pid < 0) {\n            // 如果读取到的 pid 小于 0, 说明进程创建失败\n            throw new ZygoteStartFailedEx(\"fork() failed\");\n        }\n\n        return result;\n    } catch (IOException ex) {\n      \t// 当出现 IOException, 会关闭与 Zygote 进程的连接\n        zygoteState.close();\n\n        Log.e(LOG_TAG, \"IO Exception while communicating with Zygote - \"\n                + ex.toString());\n        throw new ZygoteStartFailedEx(ex);\n    }\n  \n    // 注意到, 方法结束后没有调用 zygoteState.close(), 说明此时仍会与 Zygote 进程保持连接\n}\n```\n\n此方法主要工作是与 Zygote 进程进行通信，向 Zygote 写入参数，通知 Zygote 创建进程。\n\n如果从 Zygote 返回的 pid < 0，则说明进程创建失败；否则说明进程创建成功，通信结果包装在 `Process.ProcessStartResult` 当中。\n\n\n\n## 3. Zygote 侧的逻辑\n\n<!-- TODO -->\n\n\n\n### 3.1 Zygote 的启动过程\n\nZygote 进程是由 init 进程创建的，在 Zygote 进程启动之后就会进入 `ZygoteInit.main` 方法。\n\n\n\n#### 3.1.1 ZygoteInit.main(String)\n\n```java\npublic static void main(String argv[]) {\n    ZygoteServer zygoteServer = null;\n\n    // 在 Zygote 即将启动时调用, 调用此方法后可以使得任何线程的创建都将出错\n    ZygoteHooks.startZygoteNoThreadCreation();\n\n    try {\n      \t// 分析见 3.1.1.1\n        Os.setpgid(0, 0);\n    } catch (ErrnoException ex) {\n        throw new RuntimeException(\"Failed to setpgid(0,0)\", ex);\n    }\n\n    Runnable caller;\n    try {\n        \n      \t...\n\n      \t// 开启 DDMS\n        RuntimeInit.enableDdms();\n\n      \t// 加载系统配置, 接下来的启动流程将会使用到这些配置\n        boolean startSystemServer = false;\n        String zygoteSocketName = \"zygote\";\n        String abiList = null;\n        boolean enableLazyPreload = false;\n        for (int i = 1; i < argv.length; i++) {\n            if (\"start-system-server\".equals(argv[i])) {\n                startSystemServer = true;\n            } else if (\"--enable-lazy-preload\".equals(argv[i])) {\n                enableLazyPreload = true;\n            } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                abiList = argv[i].substring(ABI_LIST_ARG.length());\n            } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length());\n            } else {\n                throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n            }\n        }\n\n      \t// Zygote.PRIMARY_SOCKET_NAME = \"zygote\"\n        final boolean isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME);\n\n        if (abiList == null) {\n            throw new RuntimeException(\"No ABI list supplied.\");\n        }\n\n        if (!enableLazyPreload) {\n            bootTimingsTraceLog.traceBegin(\"ZygotePreload\");\n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,\n                    SystemClock.uptimeMillis());\n          \n            // 预加载资源\n            preload(bootTimingsTraceLog);\n          \n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,\n                    SystemClock.uptimeMillis());\n            bootTimingsTraceLog.traceEnd();\n        } else {\n            Zygote.resetNicePriority();\n        }\n\n        bootTimingsTraceLog.traceBegin(\"PostZygoteInitGC\");\n      \t// Zygote 启动过程走到这里, 会主动触发 GC\n        gcAndFinalize();\n        bootTimingsTraceLog.traceEnd();\n\n        bootTimingsTraceLog.traceEnd(); // ZygoteInit\n        \n      \t// TODO: 分析\n        Trace.setTracingEnabled(false, 0);\n\n\n      \t// TODO: 分析\n        Zygote.initNativeState(isPrimaryZygote);\n\n      \t// 在 Zygote 启动结束后调用, 与此方法开头调用的 ZygoteHooks.startZygoteNoThreadCreation() 对应\n        // 此时线程的创建恢复正常\n        ZygoteHooks.stopZygoteNoThreadCreation();\n\n      \t// ZygoteServer 的构造方法分析见 3.1.1.2\n        zygoteServer = new ZygoteServer(isPrimaryZygote);\n\n      \t// 启动 system_server 进程\n        if (startSystemServer) {\n            Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);\n\n          \t// 在 forkSystemServer 方法中执行了 fork 操作\n          \t// 在父进程, 即 zygote 进程, 返回的 Runnable 是 null\n          \t// 而在子进程, 即 system_server 进程, 返回的是非 null 的 Runnable\n            if (r != null) {\n              \t// 子进程在执行完 r.run() 后, 直接 return\n              \t// 意味着只有父进程才能走到后续的代码流程\n                r.run();\n                return;\n            }\n        }\n\n        Log.i(TAG, \"Accepting command socket connections\");\n\n      \t// 分析见 3.1.1.3\n        caller = zygoteServer.runSelectLoop(abiList);\n    } catch (Throwable ex) {\n        Log.e(TAG, \"System zygote died with exception\", ex);\n        throw ex;\n    } finally {\n        if (zygoteServer != null) {\n            zygoteServer.closeServerSocket();\n        }\n    }\n\n    if (caller != null) {\n        caller.run();\n    }\n}\n```\n\n此方法主要工作是启动 Zygote 进程，包含了预加载资源、创建 Socket、启动 system_server 进程等步骤，最后调用 `ZygoteServer.runSelectLoop` 方法。\n\n\n\n##### 3.1.1.1 Os.setpgid(int, int)\n\n```java\n/**\n * See <a href=\"http://man7.org/linux/man-pages/man2/setpgid.2.html\">setpgid(2)</a>.\n * @hide\n */\n@libcore.api.CorePlatformApi\npublic static void setpgid(int pid, int pgid) throws ErrnoException { Libcore.os.setpgid(pid, pgid); }\n```\n\n注意到，此时传入的参数 `pid`, `pgid` 都为 0。\n\n通过代码注释上的文档，可以了解到，当参数 `pid` 等于 0 时，将会给进程分配一个被使用过的进程 ID；当参数 `pgid` 等于 0 时，进程的 PGID 将会与它的进程 ID 保持一致。\n\n\n\n##### 3.1.1.2 ZygoteServer(boolean)\n\n```java\nZygoteServer(boolean isPrimaryZygote) {\n    mUsapPoolEventFD = Zygote.getUsapPoolEventFD();\n\n    if (isPrimaryZygote) {\n        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME);\n        mUsapPoolSocket =\n                Zygote.createManagedSocketFromInitSocket(\n                        Zygote.USAP_POOL_PRIMARY_SOCKET_NAME);\n    } else {\n        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.SECONDARY_SOCKET_NAME);\n        mUsapPoolSocket =\n                Zygote.createManagedSocketFromInitSocket(\n                        Zygote.USAP_POOL_SECONDARY_SOCKET_NAME);\n    }\n\n    fetchUsapPoolPolicyProps();\n\n    mUsapPoolSupported = true;\n}\n```\n\nZygoteServer 的构造方法主要工作是初始化作为服务端 Zygote 的 Socket 地址。\n\n\n\n##### 3.1.1.3 ZygoteServer.runSelectLoop(String)\n\n```java\nRunnable runSelectLoop(String abiList) {\n    ArrayList<FileDescriptor> socketFDs = new ArrayList<FileDescriptor>();\n    ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();\n\n    socketFDs.add(mZygoteSocket.getFileDescriptor());\n    peers.add(null);\n\n    while (true) {\n        fetchUsapPoolPolicyPropsWithMinInterval();\n\n        int[] usapPipeFDs = null;\n        StructPollfd[] pollFDs = null;\n\n        if (mUsapPoolEnabled) {\n            usapPipeFDs = Zygote.getUsapPipeFDs();\n            pollFDs = new StructPollfd[socketFDs.size() + 1 + usapPipeFDs.length];\n        } else {\n            pollFDs = new StructPollfd[socketFDs.size()];\n        }\n\n        int pollIndex = 0;\n        for (FileDescriptor socketFD : socketFDs) {\n            pollFDs[pollIndex] = new StructPollfd();\n            pollFDs[pollIndex].fd = socketFD;\n            pollFDs[pollIndex].events = (short) POLLIN;\n            ++pollIndex;\n        }\n\n        ...\n\n        try {\n            Os.poll(pollFDs, -1);\n        } catch (ErrnoException ex) {\n            throw new RuntimeException(\"poll failed\", ex);\n        }\n\n        boolean usapPoolFDRead = false;\n\n        while (--pollIndex >= 0) {\n            if ((pollFDs[pollIndex].revents & POLLIN) == 0) {\n                continue;\n            }\n\n            if (pollIndex == 0) {\n                // Zygote server socket\n\n                ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                peers.add(newPeer);\n                socketFDs.add(newPeer.getFileDescriptor());\n\n            } else if (pollIndex < usapPoolEventFDIndex) {\n                // Session socket accepted from the Zygote server socket\n\n                try {\n                    ZygoteConnection connection = peers.get(pollIndex);\n                    final Runnable command = connection.processOneCommand(this);\n\n                    // TODO (chriswailes): Is this extra check necessary?\n                    if (mIsForkChild) {\n                        // We're in the child. We should always have a command to run at this\n                        // stage if processOneCommand hasn't called \"exec\".\n                        if (command == null) {\n                            throw new IllegalStateException(\"command == null\");\n                        }\n\n                        return command;\n                    } else {\n                        // We're in the server - we should never have any commands to run.\n                        if (command != null) {\n                            throw new IllegalStateException(\"command != null\");\n                        }\n\n                        if (connection.isClosedByPeer()) {\n                            connection.closeSocket();\n                            peers.remove(pollIndex);\n                            socketFDs.remove(pollIndex);\n                        }\n                    }\n                } catch (Exception e) {\n                    if (!mIsForkChild) {\n\n                        Slog.e(TAG, \"Exception executing zygote command: \", e);\n\n                        ZygoteConnection conn = peers.remove(pollIndex);\n                        conn.closeSocket();\n\n                        socketFDs.remove(pollIndex);\n                    } else {\n                        Log.e(TAG, \"Caught post-fork exception in child process.\", e);\n                        throw e;\n                    }\n                } finally {\n                    mIsForkChild = false;\n                }\n            } else {\n                long messagePayload = -1;\n\n                try {\n                    byte[] buffer = new byte[Zygote.USAP_MANAGEMENT_MESSAGE_BYTES];\n                    int readBytes = Os.read(pollFDs[pollIndex].fd, buffer, 0, buffer.length);\n\n                    if (readBytes == Zygote.USAP_MANAGEMENT_MESSAGE_BYTES) {\n                        DataInputStream inputStream =\n                                new DataInputStream(new ByteArrayInputStream(buffer));\n\n                        messagePayload = inputStream.readLong();\n                    } else {\n                        Log.e(TAG, \"Incomplete read from USAP management FD of size \"\n                                + readBytes);\n                        continue;\n                    }\n                } catch (Exception ex) {\n                    if (pollIndex == usapPoolEventFDIndex) {\n                        Log.e(TAG, \"Failed to read from USAP pool event FD: \"\n                                + ex.getMessage());\n                    } else {\n                        Log.e(TAG, \"Failed to read from USAP reporting pipe: \"\n                                + ex.getMessage());\n                    }\n\n                    continue;\n                }\n\n                if (pollIndex > usapPoolEventFDIndex) {\n                    Zygote.removeUsapTableEntry((int) messagePayload);\n                }\n\n                usapPoolFDRead = true;\n            }\n        }\n\n        ...\n\n    }\n}\n```\n\n\n\n## 参考\n\n[Android系统启动-综述](http://gityuan.com/2016/02/01/android-booting/)\n\n[理解Android进程创建流程](http://gityuan.com/2016/03/26/app-process-create/)\n\n[Android系统启动Zygote进程(api 29)](https://www.jianshu.com/p/47d0121484fc)\n\n","source":"_drafts/exploring-android-app-process-startup-process.md","raw":"---\ntitle: 分析 Android app 进程创建流程\ntags:\n- Zygote\ncategories:\n- [Android]\n---\n\n\n\n> 本文基于源代码: android-security-10.0.0_r56\n\n\n\n## 1. 前言\n\n<!-- more -->\n\n\n\n### 1.1 前置知识\n\n<!-- TODO -->\n\n\n\n#### 1.1.1 Android 系统启动概述\n\n<!-- TODO -->\n\n\n\n#### 1.1.2 Linux fork\n\n<!-- TODO -->\n\n\n\n## 2. system_server 侧的逻辑\n\n<!-- TODO -->\n\nsystem_server 作为进程创建的发起方，入口在 ProcessList 当中，进程的启动流程最终会走到 `ProcessList.startProcess` 方法。\n\n\n\n### 2.1 ProcessList.startProcess(HostingRecord, String, ProcessRecord, int, int[], int, int, String, String, String, String, long)\n\n```java\nprivate Process.ProcessStartResult startProcess(HostingRecord hostingRecord, String entryPoint,\n        ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,\n        String seInfo, String requiredAbi, String instructionSet, String invokeWith,\n        long startTime) {\n    try {\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" +\n                app.processName);\n        checkSlow(startTime, \"startProcess: asking zygote to start proc\");\n        final Process.ProcessStartResult startResult;\n        if (hostingRecord.usesWebviewZygote()) {\n            startResult = startWebView(entryPoint,\n                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,\n                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,\n                    app.info.dataDir, null, app.info.packageName,\n                    new String[] {PROC_START_SEQ_IDENT + app.startSeq});\n        } else if (hostingRecord.usesAppZygote()) {\n            final AppZygote appZygote = createAppZygoteForProcessIfNeeded(app);\n\n            startResult = appZygote.getProcess().start(entryPoint,\n                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,\n                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,\n                    app.info.dataDir, null, app.info.packageName,\n                    /*useUsapPool=*/ false,\n                    new String[] {PROC_START_SEQ_IDENT + app.startSeq});\n        } else {\n            // 一般的进程启动流程会进入此分支\n            startResult = Process.start(entryPoint,\n                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,\n                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,\n                    app.info.dataDir, invokeWith, app.info.packageName,\n                    new String[] {PROC_START_SEQ_IDENT + app.startSeq});\n        }\n        checkSlow(startTime, \"startProcess: returned from zygote!\");\n        return startResult;\n    } finally {\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n    }\n}\n```\n\n一般的进程启动流程，会调用 `Process.start` 方法，创建新进程。\n\n\n\n### 2.2 Process.start(String, String, int, int, int[], int, int, int, String, String, String, String, String, String, String[])\n\n```java\npublic static ProcessStartResult start(@NonNull final String processClass,\n                                       @Nullable final String niceName,\n                                       int uid, int gid, @Nullable int[] gids,\n                                       int runtimeFlags,\n                                       int mountExternal,\n                                       int targetSdkVersion,\n                                       @Nullable String seInfo,\n                                       @NonNull String abi,\n                                       @Nullable String instructionSet,\n                                       @Nullable String appDataDir,\n                                       @Nullable String invokeWith,\n                                       @Nullable String packageName,\n                                       @Nullable String[] zygoteArgs) {\n    return ZYGOTE_PROCESS.start(processClass, niceName, uid, gid, gids,\n                runtimeFlags, mountExternal, targetSdkVersion, seInfo,\n                abi, instructionSet, appDataDir, invokeWith, packageName,\n                /*useUsapPool=*/ true, zygoteArgs);\n}\n```\n\n其中，`ZYGOTE_PROCESS` 是 ZygoteProcess 的实例：\n\n```java\n/**\n * State associated with the zygote process.\n * @hide\n */\npublic static final ZygoteProcess ZYGOTE_PROCESS = new ZygoteProcess();\n```\n\n再来看看 ZygoteProcess 的构造方法：\n\n```java\npublic ZygoteProcess() {\n    mZygoteSocketAddress =\n            new LocalSocketAddress(Zygote.PRIMARY_SOCKET_NAME,\n                                   LocalSocketAddress.Namespace.RESERVED);\n    mZygoteSecondarySocketAddress =\n            new LocalSocketAddress(Zygote.SECONDARY_SOCKET_NAME,\n                                   LocalSocketAddress.Namespace.RESERVED);\n\n    mUsapPoolSocketAddress =\n            new LocalSocketAddress(Zygote.USAP_POOL_PRIMARY_SOCKET_NAME,\n                                   LocalSocketAddress.Namespace.RESERVED);\n    mUsapPoolSecondarySocketAddress =\n            new LocalSocketAddress(Zygote.USAP_POOL_SECONDARY_SOCKET_NAME,\n                                   LocalSocketAddress.Namespace.RESERVED);\n}\n```\n\nZygoteProcess 的构造方法初始化了数个 Socket 地址，这些地址将会在与 Zygote 进程建立连接时用到。\n\n接下来分析 `ZygoteProcess.start` 方法。\n\n\n\n### 2.3 ZygoteProcess.start(String, String, int, int, int[], int, int, int, String, String, String, String, String, String, boolean, String[])\n\n```java\npublic final Process.ProcessStartResult start(@NonNull final String processClass,\n                                              final String niceName,\n                                              int uid, int gid, @Nullable int[] gids,\n                                              int runtimeFlags, int mountExternal,\n                                              int targetSdkVersion,\n                                              @Nullable String seInfo,\n                                              @NonNull String abi,\n                                              @Nullable String instructionSet,\n                                              @Nullable String appDataDir,\n                                              @Nullable String invokeWith,\n                                              @Nullable String packageName,\n                                              boolean useUsapPool,\n                                              @Nullable String[] zygoteArgs) {\n    // UASP 相关, 分析见 2.3.1\n    if (fetchUsapPoolEnabledPropWithMinInterval()) {\n        informZygotesOfUsapPoolStatus();\n    }\n\n    try {\n        return startViaZygote(processClass, niceName, uid, gid, gids,\n                runtimeFlags, mountExternal, targetSdkVersion, seInfo,\n                abi, instructionSet, appDataDir, invokeWith, /*startChildZygote=*/ false,\n                packageName, useUsapPool, zygoteArgs);\n    } catch (ZygoteStartFailedEx ex) {\n        Log.e(LOG_TAG,\n                \"Starting VM process through Zygote failed\");\n        throw new RuntimeException(\n                \"Starting VM process through Zygote failed\", ex);\n    }\n}\n```\n\n方法中有一段与 UASP 相关的逻辑，分析见 2.3.1，紧接着就会调用 `ZygoteProcess.startViaZygote` 方法。\n\n注意到，此方法还会把 `ZygoteProcess.startViaZygote` 方法可能抛出的 `ZygoteStartFailedEx` 转换成 `RuntimeException`。\n\n\n\n#### 2.3.1 ZygoteProcess.fetchUsapPoolEnabledPropWithMinInterval()\n\n```java\nprivate boolean fetchUsapPoolEnabledPropWithMinInterval() {\n    final long currentTimestamp = SystemClock.elapsedRealtime();\n\n    if (SystemProperties.get(\"dalvik.vm.boot-image\", \"\").endsWith(\"apex.art\")) {\n        if (currentTimestamp <= 15000) {\n            return false;\n        }\n    }\n\n    if (mIsFirstPropCheck\n            || (currentTimestamp - mLastPropCheckTimestamp >= Zygote.PROPERTY_CHECK_INTERVAL)) {\n        mIsFirstPropCheck = false;\n        mLastPropCheckTimestamp = currentTimestamp;\n      \n      \t// 返回是否开启 UsapPool 的判断结果, 分析见 2.3.1.1\n        return fetchUsapPoolEnabledProp();\n    }\n\n    return false;\n}\n```\n\n\n\n##### 2.3.1.1 ZygoteProcess.fetchUsapPoolEnabledProp()\n\n```java\nprivate boolean fetchUsapPoolEnabledProp() {\n    boolean origVal = mUsapPoolEnabled;\n\n    final String propertyString = Zygote.getConfigurationProperty(\n            ZygoteConfig.USAP_POOL_ENABLED, USAP_POOL_ENABLED_DEFAULT);\n\n    if (!propertyString.isEmpty()) {\n        mUsapPoolEnabled = Zygote.getConfigurationPropertyBoolean(\n              ZygoteConfig.USAP_POOL_ENABLED,\n              Boolean.parseBoolean(USAP_POOL_ENABLED_DEFAULT));\n    }\n\n    boolean valueChanged = origVal != mUsapPoolEnabled;\n\n    if (valueChanged) {\n        Log.i(LOG_TAG, \"usapPoolEnabled = \" + mUsapPoolEnabled);\n    }\n\n    return valueChanged;\n}\n```\n\n这个方法的主要目的是从系统配置文件中加载 UsapPool 的开启状态，而默认状态 `USAP_POOL_ENABLED_DEFAULT` 是 false，也就是说 UsapPool 默认是不开启的。\n\n因此，接下来的分析都会默认跳过 UASP 相关逻辑。\n\n\n\n### 2.4 ZygoteProcess.startViaZygote(String, String, int, int, int[], int, int, int, String, String, String, String, String, boolean, String, boolean, String[])\n\n```java\nprivate Process.ProcessStartResult startViaZygote(@NonNull final String processClass,\n                                                  @Nullable final String niceName,\n                                                  final int uid, final int gid,\n                                                  @Nullable final int[] gids,\n                                                  int runtimeFlags, int mountExternal,\n                                                  int targetSdkVersion,\n                                                  @Nullable String seInfo,\n                                                  @NonNull String abi,\n                                                  @Nullable String instructionSet,\n                                                  @Nullable String appDataDir,\n                                                  @Nullable String invokeWith,\n                                                  boolean startChildZygote,\n                                                  @Nullable String packageName,\n                                                  boolean useUsapPool,\n                                                  @Nullable String[] extraArgs)\n                                                  throws ZygoteStartFailedEx {\n    ArrayList<String> argsForZygote = new ArrayList<>();\n\n    // --runtime-args, --setuid=, --setgid=,\n    // and --setgroups= must go first\n    argsForZygote.add(\"--runtime-args\");\n    argsForZygote.add(\"--setuid=\" + uid);\n    argsForZygote.add(\"--setgid=\" + gid);\n    argsForZygote.add(\"--runtime-flags=\" + runtimeFlags);\n\n    ...\n\n    synchronized(mLock) {\n      \t// openZygoteSocketIfNeeded 方法分析见 2.4.1\n        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi),\n                                          useUsapPool,\n                                          argsForZygote);\n    }\n}\n```\n\n这个方法的主要目的是将 uid, gid 等参数保存在数组 `argsForZygote` 当中，接下来将会用到这些参数。\n\n\n\n#### 2.4.1 ZygoteProcess.openZygoteSocketIfNeeded(String)\n\n```java\n@GuardedBy(\"mLock\")\nprivate ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {\n    try {\n        attemptConnectionToPrimaryZygote();\n\n        if (primaryZygoteState.matches(abi)) {\n            return primaryZygoteState;\n        }\n\n        if (mZygoteSecondarySocketAddress != null) {\n            // The primary zygote didn't match. Try the secondary.\n            attemptConnectionToSecondaryZygote();\n\n            if (secondaryZygoteState.matches(abi)) {\n                return secondaryZygoteState;\n            }\n        }\n    } catch (IOException ioe) {\n        throw new ZygoteStartFailedEx(\"Error connecting to zygote\", ioe);\n    }\n\n    throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);\n}\n```\n\n此方法主要目的是尝试与 Zygote 进程建立连接，如果失败，将会抛出异常。\n\n注意到，方法的注解 `@GuardedBy(\"mLock\")` 表明外部在调用此方法之前需要对 `mLock` 加锁，以确保方法调用是同步的。\n\n\n\n### 2.5 ZygoteProcess.zygoteSendArgsAndGetResult(ZygoteState, boolean, ArrayList)\n\n```java\n@GuardedBy(\"mLock\")\nprivate Process.ProcessStartResult zygoteSendArgsAndGetResult(\n        ZygoteState zygoteState, boolean useUsapPool, @NonNull ArrayList<String> args)\n        throws ZygoteStartFailedEx {\n\n    // 检查参数中是否存在不合法字符\n    for (String arg : args) {\n        if (arg.indexOf('\\n') >= 0) {\n            throw new ZygoteStartFailedEx(\"Embedded newlines not allowed\");\n        } else if (arg.indexOf('\\r') >= 0) {\n            throw new ZygoteStartFailedEx(\"Embedded carriage returns not allowed\");\n        }\n    }\n\n    String msgStr = args.size() + \"\\n\" + String.join(\"\\n\", args) + \"\\n\";\n\n  \t...\n\n    return attemptZygoteSendArgsAndGetResult(zygoteState, msgStr);\n}\n```\n\n此方法检查参数的合法性，紧接着就调用了 `ZygoteProcess.attemptZygoteSendArgsAndGetResult` 方法。\n\n\n\n### 2.6 ZygoteProcess.attemptZygoteSendArgsAndGetResult(ZygoteState, String)\n\n```java\nprivate Process.ProcessStartResult attemptZygoteSendArgsAndGetResult(\n        ZygoteState zygoteState, String msgStr) throws ZygoteStartFailedEx {\n    try {\n      \t// 已经与 Zygote 进程建立了 Socket 连接, 此时两者间的通信就像读写文件流一样方便\n        final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;\n        final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;\n\n      \t// 往 Zygote 写入参数\n        zygoteWriter.write(msgStr);\n        zygoteWriter.flush();\n\n      \t// 读取结果\n        Process.ProcessStartResult result = new Process.ProcessStartResult();\n        result.pid = zygoteInputStream.readInt();\n        result.usingWrapper = zygoteInputStream.readBoolean();\n\n        if (result.pid < 0) {\n            // 如果读取到的 pid 小于 0, 说明进程创建失败\n            throw new ZygoteStartFailedEx(\"fork() failed\");\n        }\n\n        return result;\n    } catch (IOException ex) {\n      \t// 当出现 IOException, 会关闭与 Zygote 进程的连接\n        zygoteState.close();\n\n        Log.e(LOG_TAG, \"IO Exception while communicating with Zygote - \"\n                + ex.toString());\n        throw new ZygoteStartFailedEx(ex);\n    }\n  \n    // 注意到, 方法结束后没有调用 zygoteState.close(), 说明此时仍会与 Zygote 进程保持连接\n}\n```\n\n此方法主要工作是与 Zygote 进程进行通信，向 Zygote 写入参数，通知 Zygote 创建进程。\n\n如果从 Zygote 返回的 pid < 0，则说明进程创建失败；否则说明进程创建成功，通信结果包装在 `Process.ProcessStartResult` 当中。\n\n\n\n## 3. Zygote 侧的逻辑\n\n<!-- TODO -->\n\n\n\n### 3.1 Zygote 的启动过程\n\nZygote 进程是由 init 进程创建的，在 Zygote 进程启动之后就会进入 `ZygoteInit.main` 方法。\n\n\n\n#### 3.1.1 ZygoteInit.main(String)\n\n```java\npublic static void main(String argv[]) {\n    ZygoteServer zygoteServer = null;\n\n    // 在 Zygote 即将启动时调用, 调用此方法后可以使得任何线程的创建都将出错\n    ZygoteHooks.startZygoteNoThreadCreation();\n\n    try {\n      \t// 分析见 3.1.1.1\n        Os.setpgid(0, 0);\n    } catch (ErrnoException ex) {\n        throw new RuntimeException(\"Failed to setpgid(0,0)\", ex);\n    }\n\n    Runnable caller;\n    try {\n        \n      \t...\n\n      \t// 开启 DDMS\n        RuntimeInit.enableDdms();\n\n      \t// 加载系统配置, 接下来的启动流程将会使用到这些配置\n        boolean startSystemServer = false;\n        String zygoteSocketName = \"zygote\";\n        String abiList = null;\n        boolean enableLazyPreload = false;\n        for (int i = 1; i < argv.length; i++) {\n            if (\"start-system-server\".equals(argv[i])) {\n                startSystemServer = true;\n            } else if (\"--enable-lazy-preload\".equals(argv[i])) {\n                enableLazyPreload = true;\n            } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                abiList = argv[i].substring(ABI_LIST_ARG.length());\n            } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length());\n            } else {\n                throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n            }\n        }\n\n      \t// Zygote.PRIMARY_SOCKET_NAME = \"zygote\"\n        final boolean isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME);\n\n        if (abiList == null) {\n            throw new RuntimeException(\"No ABI list supplied.\");\n        }\n\n        if (!enableLazyPreload) {\n            bootTimingsTraceLog.traceBegin(\"ZygotePreload\");\n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,\n                    SystemClock.uptimeMillis());\n          \n            // 预加载资源\n            preload(bootTimingsTraceLog);\n          \n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,\n                    SystemClock.uptimeMillis());\n            bootTimingsTraceLog.traceEnd();\n        } else {\n            Zygote.resetNicePriority();\n        }\n\n        bootTimingsTraceLog.traceBegin(\"PostZygoteInitGC\");\n      \t// Zygote 启动过程走到这里, 会主动触发 GC\n        gcAndFinalize();\n        bootTimingsTraceLog.traceEnd();\n\n        bootTimingsTraceLog.traceEnd(); // ZygoteInit\n        \n      \t// TODO: 分析\n        Trace.setTracingEnabled(false, 0);\n\n\n      \t// TODO: 分析\n        Zygote.initNativeState(isPrimaryZygote);\n\n      \t// 在 Zygote 启动结束后调用, 与此方法开头调用的 ZygoteHooks.startZygoteNoThreadCreation() 对应\n        // 此时线程的创建恢复正常\n        ZygoteHooks.stopZygoteNoThreadCreation();\n\n      \t// ZygoteServer 的构造方法分析见 3.1.1.2\n        zygoteServer = new ZygoteServer(isPrimaryZygote);\n\n      \t// 启动 system_server 进程\n        if (startSystemServer) {\n            Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);\n\n          \t// 在 forkSystemServer 方法中执行了 fork 操作\n          \t// 在父进程, 即 zygote 进程, 返回的 Runnable 是 null\n          \t// 而在子进程, 即 system_server 进程, 返回的是非 null 的 Runnable\n            if (r != null) {\n              \t// 子进程在执行完 r.run() 后, 直接 return\n              \t// 意味着只有父进程才能走到后续的代码流程\n                r.run();\n                return;\n            }\n        }\n\n        Log.i(TAG, \"Accepting command socket connections\");\n\n      \t// 分析见 3.1.1.3\n        caller = zygoteServer.runSelectLoop(abiList);\n    } catch (Throwable ex) {\n        Log.e(TAG, \"System zygote died with exception\", ex);\n        throw ex;\n    } finally {\n        if (zygoteServer != null) {\n            zygoteServer.closeServerSocket();\n        }\n    }\n\n    if (caller != null) {\n        caller.run();\n    }\n}\n```\n\n此方法主要工作是启动 Zygote 进程，包含了预加载资源、创建 Socket、启动 system_server 进程等步骤，最后调用 `ZygoteServer.runSelectLoop` 方法。\n\n\n\n##### 3.1.1.1 Os.setpgid(int, int)\n\n```java\n/**\n * See <a href=\"http://man7.org/linux/man-pages/man2/setpgid.2.html\">setpgid(2)</a>.\n * @hide\n */\n@libcore.api.CorePlatformApi\npublic static void setpgid(int pid, int pgid) throws ErrnoException { Libcore.os.setpgid(pid, pgid); }\n```\n\n注意到，此时传入的参数 `pid`, `pgid` 都为 0。\n\n通过代码注释上的文档，可以了解到，当参数 `pid` 等于 0 时，将会给进程分配一个被使用过的进程 ID；当参数 `pgid` 等于 0 时，进程的 PGID 将会与它的进程 ID 保持一致。\n\n\n\n##### 3.1.1.2 ZygoteServer(boolean)\n\n```java\nZygoteServer(boolean isPrimaryZygote) {\n    mUsapPoolEventFD = Zygote.getUsapPoolEventFD();\n\n    if (isPrimaryZygote) {\n        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME);\n        mUsapPoolSocket =\n                Zygote.createManagedSocketFromInitSocket(\n                        Zygote.USAP_POOL_PRIMARY_SOCKET_NAME);\n    } else {\n        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.SECONDARY_SOCKET_NAME);\n        mUsapPoolSocket =\n                Zygote.createManagedSocketFromInitSocket(\n                        Zygote.USAP_POOL_SECONDARY_SOCKET_NAME);\n    }\n\n    fetchUsapPoolPolicyProps();\n\n    mUsapPoolSupported = true;\n}\n```\n\nZygoteServer 的构造方法主要工作是初始化作为服务端 Zygote 的 Socket 地址。\n\n\n\n##### 3.1.1.3 ZygoteServer.runSelectLoop(String)\n\n```java\nRunnable runSelectLoop(String abiList) {\n    ArrayList<FileDescriptor> socketFDs = new ArrayList<FileDescriptor>();\n    ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();\n\n    socketFDs.add(mZygoteSocket.getFileDescriptor());\n    peers.add(null);\n\n    while (true) {\n        fetchUsapPoolPolicyPropsWithMinInterval();\n\n        int[] usapPipeFDs = null;\n        StructPollfd[] pollFDs = null;\n\n        if (mUsapPoolEnabled) {\n            usapPipeFDs = Zygote.getUsapPipeFDs();\n            pollFDs = new StructPollfd[socketFDs.size() + 1 + usapPipeFDs.length];\n        } else {\n            pollFDs = new StructPollfd[socketFDs.size()];\n        }\n\n        int pollIndex = 0;\n        for (FileDescriptor socketFD : socketFDs) {\n            pollFDs[pollIndex] = new StructPollfd();\n            pollFDs[pollIndex].fd = socketFD;\n            pollFDs[pollIndex].events = (short) POLLIN;\n            ++pollIndex;\n        }\n\n        ...\n\n        try {\n            Os.poll(pollFDs, -1);\n        } catch (ErrnoException ex) {\n            throw new RuntimeException(\"poll failed\", ex);\n        }\n\n        boolean usapPoolFDRead = false;\n\n        while (--pollIndex >= 0) {\n            if ((pollFDs[pollIndex].revents & POLLIN) == 0) {\n                continue;\n            }\n\n            if (pollIndex == 0) {\n                // Zygote server socket\n\n                ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                peers.add(newPeer);\n                socketFDs.add(newPeer.getFileDescriptor());\n\n            } else if (pollIndex < usapPoolEventFDIndex) {\n                // Session socket accepted from the Zygote server socket\n\n                try {\n                    ZygoteConnection connection = peers.get(pollIndex);\n                    final Runnable command = connection.processOneCommand(this);\n\n                    // TODO (chriswailes): Is this extra check necessary?\n                    if (mIsForkChild) {\n                        // We're in the child. We should always have a command to run at this\n                        // stage if processOneCommand hasn't called \"exec\".\n                        if (command == null) {\n                            throw new IllegalStateException(\"command == null\");\n                        }\n\n                        return command;\n                    } else {\n                        // We're in the server - we should never have any commands to run.\n                        if (command != null) {\n                            throw new IllegalStateException(\"command != null\");\n                        }\n\n                        if (connection.isClosedByPeer()) {\n                            connection.closeSocket();\n                            peers.remove(pollIndex);\n                            socketFDs.remove(pollIndex);\n                        }\n                    }\n                } catch (Exception e) {\n                    if (!mIsForkChild) {\n\n                        Slog.e(TAG, \"Exception executing zygote command: \", e);\n\n                        ZygoteConnection conn = peers.remove(pollIndex);\n                        conn.closeSocket();\n\n                        socketFDs.remove(pollIndex);\n                    } else {\n                        Log.e(TAG, \"Caught post-fork exception in child process.\", e);\n                        throw e;\n                    }\n                } finally {\n                    mIsForkChild = false;\n                }\n            } else {\n                long messagePayload = -1;\n\n                try {\n                    byte[] buffer = new byte[Zygote.USAP_MANAGEMENT_MESSAGE_BYTES];\n                    int readBytes = Os.read(pollFDs[pollIndex].fd, buffer, 0, buffer.length);\n\n                    if (readBytes == Zygote.USAP_MANAGEMENT_MESSAGE_BYTES) {\n                        DataInputStream inputStream =\n                                new DataInputStream(new ByteArrayInputStream(buffer));\n\n                        messagePayload = inputStream.readLong();\n                    } else {\n                        Log.e(TAG, \"Incomplete read from USAP management FD of size \"\n                                + readBytes);\n                        continue;\n                    }\n                } catch (Exception ex) {\n                    if (pollIndex == usapPoolEventFDIndex) {\n                        Log.e(TAG, \"Failed to read from USAP pool event FD: \"\n                                + ex.getMessage());\n                    } else {\n                        Log.e(TAG, \"Failed to read from USAP reporting pipe: \"\n                                + ex.getMessage());\n                    }\n\n                    continue;\n                }\n\n                if (pollIndex > usapPoolEventFDIndex) {\n                    Zygote.removeUsapTableEntry((int) messagePayload);\n                }\n\n                usapPoolFDRead = true;\n            }\n        }\n\n        ...\n\n    }\n}\n```\n\n\n\n## 参考\n\n[Android系统启动-综述](http://gityuan.com/2016/02/01/android-booting/)\n\n[理解Android进程创建流程](http://gityuan.com/2016/03/26/app-process-create/)\n\n[Android系统启动Zygote进程(api 29)](https://www.jianshu.com/p/47d0121484fc)\n\n","slug":"exploring-android-app-process-startup-process","published":0,"date":"2021-08-06T03:14:54.945Z","updated":"2021-08-19T03:05:58.376Z","_id":"cksh4x6tu000lqkprd6fo4ta8","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>本文基于源代码: android-security-10.0.0_r56</p>\n</blockquote>\n<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><a id=\"more\"></a>\n\n\n\n<h3 id=\"1-1-前置知识\"><a href=\"#1-1-前置知识\" class=\"headerlink\" title=\"1.1 前置知识\"></a>1.1 前置知识</h3><!-- TODO -->\n\n\n\n<h4 id=\"1-1-1-Android-系统启动概述\"><a href=\"#1-1-1-Android-系统启动概述\" class=\"headerlink\" title=\"1.1.1 Android 系统启动概述\"></a>1.1.1 Android 系统启动概述</h4><!-- TODO -->\n\n\n\n<h4 id=\"1-1-2-Linux-fork\"><a href=\"#1-1-2-Linux-fork\" class=\"headerlink\" title=\"1.1.2 Linux fork\"></a>1.1.2 Linux fork</h4><!-- TODO -->\n\n\n\n<h2 id=\"2-system-server-侧的逻辑\"><a href=\"#2-system-server-侧的逻辑\" class=\"headerlink\" title=\"2. system_server 侧的逻辑\"></a>2. system_server 侧的逻辑</h2><!-- TODO -->\n\n<p>system_server 作为进程创建的发起方，入口在 ProcessList 当中，进程的启动流程最终会走到 <code>ProcessList.startProcess</code> 方法。</p>\n<h3 id=\"2-1-ProcessList-startProcess-HostingRecord-String-ProcessRecord-int-int-int-int-String-String-String-String-long\"><a href=\"#2-1-ProcessList-startProcess-HostingRecord-String-ProcessRecord-int-int-int-int-String-String-String-String-long\" class=\"headerlink\" title=\"2.1 ProcessList.startProcess(HostingRecord, String, ProcessRecord, int, int[], int, int, String, String, String, String, long)\"></a>2.1 ProcessList.startProcess(HostingRecord, String, ProcessRecord, int, int[], int, int, String, String, String, String, long)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Process.<span class=\"function\">ProcessStartResult <span class=\"title\">startProcess</span><span class=\"params\">(HostingRecord hostingRecord, String entryPoint,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ProcessRecord app, <span class=\"keyword\">int</span> uid, <span class=\"keyword\">int</span>[] gids, <span class=\"keyword\">int</span> runtimeFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">long</span> startTime)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">&quot;Start proc: &quot;</span> +</span><br><span class=\"line\">                app.processName);</span><br><span class=\"line\">        checkSlow(startTime, <span class=\"string\">&quot;startProcess: asking zygote to start proc&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Process.ProcessStartResult startResult;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hostingRecord.usesWebviewZygote()) &#123;</span><br><span class=\"line\">            startResult = startWebView(entryPoint,</span><br><span class=\"line\">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class=\"line\">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class=\"line\">                    app.info.dataDir, <span class=\"keyword\">null</span>, app.info.packageName,</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hostingRecord.usesAppZygote()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> AppZygote appZygote = createAppZygoteForProcessIfNeeded(app);</span><br><span class=\"line\"></span><br><span class=\"line\">            startResult = appZygote.getProcess().start(entryPoint,</span><br><span class=\"line\">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class=\"line\">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class=\"line\">                    app.info.dataDir, <span class=\"keyword\">null</span>, app.info.packageName,</span><br><span class=\"line\">                    <span class=\"comment\">/*useUsapPool=*/</span> <span class=\"keyword\">false</span>,</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 一般的进程启动流程会进入此分支</span></span><br><span class=\"line\">            startResult = Process.start(entryPoint,</span><br><span class=\"line\">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class=\"line\">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class=\"line\">                    app.info.dataDir, invokeWith, app.info.packageName,</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        checkSlow(startTime, <span class=\"string\">&quot;startProcess: returned from zygote!&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> startResult;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般的进程启动流程，会调用 <code>Process.start</code> 方法，创建新进程。</p>\n<h3 id=\"2-2-Process-start-String-String-int-int-int-int-int-int-String-String-String-String-String-String-String\"><a href=\"#2-2-Process-start-String-String-int-int-int-int-int-int-String-String-String-String-String-String-String\" class=\"headerlink\" title=\"2.2 Process.start(String, String, int, int, int[], int, int, int, String, String, String, String, String, String, String[])\"></a>2.2 Process.start(String, String, int, int, int[], int, int, int, String, String, String, String, String, String, String[])</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ProcessStartResult <span class=\"title\">start</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@Nullable</span> <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"keyword\">int</span> uid, <span class=\"keyword\">int</span> gid, <span class=\"meta\">@Nullable</span> <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"keyword\">int</span> runtimeFlags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@Nullable</span> String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@NonNull</span> String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@Nullable</span> String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@Nullable</span> String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@Nullable</span> String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@Nullable</span> String packageName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@Nullable</span> String[] zygoteArgs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ZYGOTE_PROCESS.start(processClass, niceName, uid, gid, gids,</span><br><span class=\"line\">                runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class=\"line\">                abi, instructionSet, appDataDir, invokeWith, packageName,</span><br><span class=\"line\">                <span class=\"comment\">/*useUsapPool=*/</span> <span class=\"keyword\">true</span>, zygoteArgs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，<code>ZYGOTE_PROCESS</code> 是 ZygoteProcess 的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * State associated with the zygote process.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ZygoteProcess ZYGOTE_PROCESS = <span class=\"keyword\">new</span> ZygoteProcess();</span><br></pre></td></tr></table></figure>\n<p>再来看看 ZygoteProcess 的构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ZygoteProcess</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mZygoteSocketAddress =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> LocalSocketAddress(Zygote.PRIMARY_SOCKET_NAME,</span><br><span class=\"line\">                                   LocalSocketAddress.Namespace.RESERVED);</span><br><span class=\"line\">    mZygoteSecondarySocketAddress =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> LocalSocketAddress(Zygote.SECONDARY_SOCKET_NAME,</span><br><span class=\"line\">                                   LocalSocketAddress.Namespace.RESERVED);</span><br><span class=\"line\"></span><br><span class=\"line\">    mUsapPoolSocketAddress =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> LocalSocketAddress(Zygote.USAP_POOL_PRIMARY_SOCKET_NAME,</span><br><span class=\"line\">                                   LocalSocketAddress.Namespace.RESERVED);</span><br><span class=\"line\">    mUsapPoolSecondarySocketAddress =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> LocalSocketAddress(Zygote.USAP_POOL_SECONDARY_SOCKET_NAME,</span><br><span class=\"line\">                                   LocalSocketAddress.Namespace.RESERVED);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ZygoteProcess 的构造方法初始化了数个 Socket 地址，这些地址将会在与 Zygote 进程建立连接时用到。</p>\n<p>接下来分析 <code>ZygoteProcess.start</code> 方法。</p>\n<h3 id=\"2-3-ZygoteProcess-start-String-String-int-int-int-int-int-int-String-String-String-String-String-String-boolean-String\"><a href=\"#2-3-ZygoteProcess-start-String-String-int-int-int-int-int-int-String-String-String-String-String-String-boolean-String\" class=\"headerlink\" title=\"2.3 ZygoteProcess.start(String, String, int, int, int[], int, int, int, String, String, String, String, String, String, boolean, String[])\"></a>2.3 ZygoteProcess.start(String, String, int, int, int[], int, int, int, String, String, String, String, String, String, boolean, String[])</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Process.<span class=\"function\">ProcessStartResult <span class=\"title\">start</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"keyword\">int</span> uid, <span class=\"keyword\">int</span> gid, <span class=\"meta\">@Nullable</span> <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"keyword\">int</span> runtimeFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"meta\">@Nullable</span> String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"meta\">@NonNull</span> String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"meta\">@Nullable</span> String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"meta\">@Nullable</span> String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"meta\">@Nullable</span> String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"meta\">@Nullable</span> String packageName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"keyword\">boolean</span> useUsapPool,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"meta\">@Nullable</span> String[] zygoteArgs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// UASP 相关, 分析见 2.3.1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fetchUsapPoolEnabledPropWithMinInterval()) &#123;</span><br><span class=\"line\">        informZygotesOfUsapPoolStatus();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class=\"line\">                runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class=\"line\">                abi, instructionSet, appDataDir, invokeWith, <span class=\"comment\">/*startChildZygote=*/</span> <span class=\"keyword\">false</span>,</span><br><span class=\"line\">                packageName, useUsapPool, zygoteArgs);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class=\"line\">        Log.e(LOG_TAG,</span><br><span class=\"line\">                <span class=\"string\">&quot;Starting VM process through Zygote failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"string\">&quot;Starting VM process through Zygote failed&quot;</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法中有一段与 UASP 相关的逻辑，分析见 2.3.1，紧接着就会调用 <code>ZygoteProcess.startViaZygote</code> 方法。</p>\n<p>注意到，此方法还会把 <code>ZygoteProcess.startViaZygote</code> 方法可能抛出的 <code>ZygoteStartFailedEx</code> 转换成 <code>RuntimeException</code>。</p>\n<h4 id=\"2-3-1-ZygoteProcess-fetchUsapPoolEnabledPropWithMinInterval\"><a href=\"#2-3-1-ZygoteProcess-fetchUsapPoolEnabledPropWithMinInterval\" class=\"headerlink\" title=\"2.3.1 ZygoteProcess.fetchUsapPoolEnabledPropWithMinInterval()\"></a>2.3.1 ZygoteProcess.fetchUsapPoolEnabledPropWithMinInterval()</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">fetchUsapPoolEnabledPropWithMinInterval</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> currentTimestamp = SystemClock.elapsedRealtime();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (SystemProperties.get(<span class=\"string\">&quot;dalvik.vm.boot-image&quot;</span>, <span class=\"string\">&quot;&quot;</span>).endsWith(<span class=\"string\">&quot;apex.art&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentTimestamp &lt;= <span class=\"number\">15000</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIsFirstPropCheck</span><br><span class=\"line\">            || (currentTimestamp - mLastPropCheckTimestamp &gt;= Zygote.PROPERTY_CHECK_INTERVAL)) &#123;</span><br><span class=\"line\">        mIsFirstPropCheck = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mLastPropCheckTimestamp = currentTimestamp;</span><br><span class=\"line\">      </span><br><span class=\"line\">      \t<span class=\"comment\">// 返回是否开启 UsapPool 的判断结果, 分析见 2.3.1.1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> fetchUsapPoolEnabledProp();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h5 id=\"2-3-1-1-ZygoteProcess-fetchUsapPoolEnabledProp\"><a href=\"#2-3-1-1-ZygoteProcess-fetchUsapPoolEnabledProp\" class=\"headerlink\" title=\"2.3.1.1 ZygoteProcess.fetchUsapPoolEnabledProp()\"></a>2.3.1.1 ZygoteProcess.fetchUsapPoolEnabledProp()</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">fetchUsapPoolEnabledProp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> origVal = mUsapPoolEnabled;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String propertyString = Zygote.getConfigurationProperty(</span><br><span class=\"line\">            ZygoteConfig.USAP_POOL_ENABLED, USAP_POOL_ENABLED_DEFAULT);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!propertyString.isEmpty()) &#123;</span><br><span class=\"line\">        mUsapPoolEnabled = Zygote.getConfigurationPropertyBoolean(</span><br><span class=\"line\">              ZygoteConfig.USAP_POOL_ENABLED,</span><br><span class=\"line\">              Boolean.parseBoolean(USAP_POOL_ENABLED_DEFAULT));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> valueChanged = origVal != mUsapPoolEnabled;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (valueChanged) &#123;</span><br><span class=\"line\">        Log.i(LOG_TAG, <span class=\"string\">&quot;usapPoolEnabled = &quot;</span> + mUsapPoolEnabled);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> valueChanged;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法的主要目的是从系统配置文件中加载 UsapPool 的开启状态，而默认状态 <code>USAP_POOL_ENABLED_DEFAULT</code> 是 false，也就是说 UsapPool 默认是不开启的。</p>\n<p>因此，接下来的分析都会默认跳过 UASP 相关逻辑。</p>\n<h3 id=\"2-4-ZygoteProcess-startViaZygote-String-String-int-int-int-int-int-int-String-String-String-String-String-boolean-String-boolean-String\"><a href=\"#2-4-ZygoteProcess-startViaZygote-String-String-int-int-int-int-int-int-String-String-String-String-String-boolean-String-boolean-String\" class=\"headerlink\" title=\"2.4 ZygoteProcess.startViaZygote(String, String, int, int, int[], int, int, int, String, String, String, String, String, boolean, String, boolean, String[])\"></a>2.4 ZygoteProcess.startViaZygote(String, String, int, int, int[], int, int, int, String, String, String, String, String, boolean, String, boolean, String[])</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Process.<span class=\"function\">ProcessStartResult <span class=\"title\">startViaZygote</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> uid, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> gid,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">int</span> runtimeFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@NonNull</span> String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">boolean</span> startChildZygote,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> String packageName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">boolean</span> useUsapPool,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> String[] extraArgs)</span></span></span><br><span class=\"line\"><span class=\"function\">                                                  <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">    ArrayList&lt;String&gt; argsForZygote = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// --runtime-args, --setuid=, --setgid=,</span></span><br><span class=\"line\">    <span class=\"comment\">// and --setgroups= must go first</span></span><br><span class=\"line\">    argsForZygote.add(<span class=\"string\">&quot;--runtime-args&quot;</span>);</span><br><span class=\"line\">    argsForZygote.add(<span class=\"string\">&quot;--setuid=&quot;</span> + uid);</span><br><span class=\"line\">    argsForZygote.add(<span class=\"string\">&quot;--setgid=&quot;</span> + gid);</span><br><span class=\"line\">    argsForZygote.add(<span class=\"string\">&quot;--runtime-flags=&quot;</span> + runtimeFlags);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(mLock) &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// openZygoteSocketIfNeeded 方法分析见 2.4.1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi),</span><br><span class=\"line\">                                          useUsapPool,</span><br><span class=\"line\">                                          argsForZygote);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法的主要目的是将 uid, gid 等参数保存在数组 <code>argsForZygote</code> 当中，接下来将会用到这些参数。</p>\n<h4 id=\"2-4-1-ZygoteProcess-openZygoteSocketIfNeeded-String\"><a href=\"#2-4-1-ZygoteProcess-openZygoteSocketIfNeeded-String\" class=\"headerlink\" title=\"2.4.1 ZygoteProcess.openZygoteSocketIfNeeded(String)\"></a>2.4.1 ZygoteProcess.openZygoteSocketIfNeeded(String)</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GuardedBy(&quot;mLock&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ZygoteState <span class=\"title\">openZygoteSocketIfNeeded</span><span class=\"params\">(String abi)</span> <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        attemptConnectionToPrimaryZygote();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> primaryZygoteState;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mZygoteSecondarySocketAddress != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The primary zygote didn&#x27;t match. Try the secondary.</span></span><br><span class=\"line\">            attemptConnectionToSecondaryZygote();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> secondaryZygoteState;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">&quot;Error connecting to zygote&quot;</span>, ioe);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">&quot;Unsupported zygote ABI: &quot;</span> + abi);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此方法主要目的是尝试与 Zygote 进程建立连接，如果失败，将会抛出异常。</p>\n<p>注意到，方法的注解 <code>@GuardedBy(&quot;mLock&quot;)</code> 表明外部在调用此方法之前需要对 <code>mLock</code> 加锁，以确保方法调用是同步的。</p>\n<h3 id=\"2-5-ZygoteProcess-zygoteSendArgsAndGetResult-ZygoteState-boolean-ArrayList\"><a href=\"#2-5-ZygoteProcess-zygoteSendArgsAndGetResult-ZygoteState-boolean-ArrayList\" class=\"headerlink\" title=\"2.5 ZygoteProcess.zygoteSendArgsAndGetResult(ZygoteState, boolean, ArrayList)\"></a>2.5 ZygoteProcess.zygoteSendArgsAndGetResult(ZygoteState, boolean, ArrayList)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GuardedBy(&quot;mLock&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Process.<span class=\"function\">ProcessStartResult <span class=\"title\">zygoteSendArgsAndGetResult</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ZygoteState zygoteState, <span class=\"keyword\">boolean</span> useUsapPool, <span class=\"meta\">@NonNull</span> ArrayList&lt;String&gt; args)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 检查参数中是否存在不合法字符</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String arg : args) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg.indexOf(<span class=\"string\">&#x27;\\n&#x27;</span>) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">&quot;Embedded newlines not allowed&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arg.indexOf(<span class=\"string\">&#x27;\\r&#x27;</span>) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">&quot;Embedded carriage returns not allowed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    String msgStr = args.size() + <span class=\"string\">&quot;\\n&quot;</span> + String.join(<span class=\"string\">&quot;\\n&quot;</span>, args) + <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> attemptZygoteSendArgsAndGetResult(zygoteState, msgStr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此方法检查参数的合法性，紧接着就调用了 <code>ZygoteProcess.attemptZygoteSendArgsAndGetResult</code> 方法。</p>\n<h3 id=\"2-6-ZygoteProcess-attemptZygoteSendArgsAndGetResult-ZygoteState-String\"><a href=\"#2-6-ZygoteProcess-attemptZygoteSendArgsAndGetResult-ZygoteState-String\" class=\"headerlink\" title=\"2.6 ZygoteProcess.attemptZygoteSendArgsAndGetResult(ZygoteState, String)\"></a>2.6 ZygoteProcess.attemptZygoteSendArgsAndGetResult(ZygoteState, String)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Process.<span class=\"function\">ProcessStartResult <span class=\"title\">attemptZygoteSendArgsAndGetResult</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ZygoteState zygoteState, String msgStr)</span> <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 已经与 Zygote 进程建立了 Socket 连接, 此时两者间的通信就像读写文件流一样方便</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 往 Zygote 写入参数</span></span><br><span class=\"line\">        zygoteWriter.write(msgStr);</span><br><span class=\"line\">        zygoteWriter.flush();</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 读取结果</span></span><br><span class=\"line\">        Process.ProcessStartResult result = <span class=\"keyword\">new</span> Process.ProcessStartResult();</span><br><span class=\"line\">        result.pid = zygoteInputStream.readInt();</span><br><span class=\"line\">        result.usingWrapper = zygoteInputStream.readBoolean();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.pid &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果读取到的 pid 小于 0, 说明进程创建失败</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">&quot;fork() failed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 当出现 IOException, 会关闭与 Zygote 进程的连接</span></span><br><span class=\"line\">        zygoteState.close();</span><br><span class=\"line\"></span><br><span class=\"line\">        Log.e(LOG_TAG, <span class=\"string\">&quot;IO Exception while communicating with Zygote - &quot;</span></span><br><span class=\"line\">                + ex.toString());</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 注意到, 方法结束后没有调用 zygoteState.close(), 说明此时仍会与 Zygote 进程保持连接</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此方法主要工作是与 Zygote 进程进行通信，向 Zygote 写入参数，通知 Zygote 创建进程。</p>\n<p>如果从 Zygote 返回的 pid &lt; 0，则说明进程创建失败；否则说明进程创建成功，通信结果包装在 <code>Process.ProcessStartResult</code> 当中。</p>\n<h2 id=\"3-Zygote-侧的逻辑\"><a href=\"#3-Zygote-侧的逻辑\" class=\"headerlink\" title=\"3. Zygote 侧的逻辑\"></a>3. Zygote 侧的逻辑</h2><!-- TODO -->\n\n\n\n<h3 id=\"3-1-Zygote-的启动过程\"><a href=\"#3-1-Zygote-的启动过程\" class=\"headerlink\" title=\"3.1 Zygote 的启动过程\"></a>3.1 Zygote 的启动过程</h3><p>Zygote 进程是由 init 进程创建的，在 Zygote 进程启动之后就会进入 <code>ZygoteInit.main</code> 方法。</p>\n<h4 id=\"3-1-1-ZygoteInit-main-String\"><a href=\"#3-1-1-ZygoteInit-main-String\" class=\"headerlink\" title=\"3.1.1 ZygoteInit.main(String)\"></a>3.1.1 ZygoteInit.main(String)</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String argv[])</span> </span>&#123;</span><br><span class=\"line\">    ZygoteServer zygoteServer = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在 Zygote 即将启动时调用, 调用此方法后可以使得任何线程的创建都将出错</span></span><br><span class=\"line\">    ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 分析见 3.1.1.1</span></span><br><span class=\"line\">        Os.setpgid(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ErrnoException ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Failed to setpgid(0,0)&quot;</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Runnable caller;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">      \t...</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 开启 DDMS</span></span><br><span class=\"line\">        RuntimeInit.enableDdms();</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 加载系统配置, 接下来的启动流程将会使用到这些配置</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> startSystemServer = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        String zygoteSocketName = <span class=\"string\">&quot;zygote&quot;</span>;</span><br><span class=\"line\">        String abiList = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> enableLazyPreload = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"string\">&quot;start-system-server&quot;</span>.equals(argv[i])) &#123;</span><br><span class=\"line\">                startSystemServer = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;--enable-lazy-preload&quot;</span>.equals(argv[i])) &#123;</span><br><span class=\"line\">                enableLazyPreload = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class=\"line\">                abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class=\"line\">                zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Unknown command line argument: &quot;</span> + argv[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// Zygote.PRIMARY_SOCKET_NAME = &quot;zygote&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (abiList == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;No ABI list supplied.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!enableLazyPreload) &#123;</span><br><span class=\"line\">            bootTimingsTraceLog.traceBegin(<span class=\"string\">&quot;ZygotePreload&quot;</span>);</span><br><span class=\"line\">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</span><br><span class=\"line\">                    SystemClock.uptimeMillis());</span><br><span class=\"line\">          </span><br><span class=\"line\">            <span class=\"comment\">// 预加载资源</span></span><br><span class=\"line\">            preload(bootTimingsTraceLog);</span><br><span class=\"line\">          </span><br><span class=\"line\">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</span><br><span class=\"line\">                    SystemClock.uptimeMillis());</span><br><span class=\"line\">            bootTimingsTraceLog.traceEnd();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Zygote.resetNicePriority();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        bootTimingsTraceLog.traceBegin(<span class=\"string\">&quot;PostZygoteInitGC&quot;</span>);</span><br><span class=\"line\">      \t<span class=\"comment\">// Zygote 启动过程走到这里, 会主动触发 GC</span></span><br><span class=\"line\">        gcAndFinalize();</span><br><span class=\"line\">        bootTimingsTraceLog.traceEnd();</span><br><span class=\"line\"></span><br><span class=\"line\">        bootTimingsTraceLog.traceEnd(); <span class=\"comment\">// ZygoteInit</span></span><br><span class=\"line\">        </span><br><span class=\"line\">      \t<span class=\"comment\">// <span class=\"doctag\">TODO:</span> 分析</span></span><br><span class=\"line\">        Trace.setTracingEnabled(<span class=\"keyword\">false</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// <span class=\"doctag\">TODO:</span> 分析</span></span><br><span class=\"line\">        Zygote.initNativeState(isPrimaryZygote);</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 在 Zygote 启动结束后调用, 与此方法开头调用的 ZygoteHooks.startZygoteNoThreadCreation() 对应</span></span><br><span class=\"line\">        <span class=\"comment\">// 此时线程的创建恢复正常</span></span><br><span class=\"line\">        ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// ZygoteServer 的构造方法分析见 3.1.1.2</span></span><br><span class=\"line\">        zygoteServer = <span class=\"keyword\">new</span> ZygoteServer(isPrimaryZygote);</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 启动 system_server 进程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (startSystemServer) &#123;</span><br><span class=\"line\">            Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class=\"line\"></span><br><span class=\"line\">          \t<span class=\"comment\">// 在 forkSystemServer 方法中执行了 fork 操作</span></span><br><span class=\"line\">          \t<span class=\"comment\">// 在父进程, 即 zygote 进程, 返回的 Runnable 是 null</span></span><br><span class=\"line\">          \t<span class=\"comment\">// 而在子进程, 即 system_server 进程, 返回的是非 null 的 Runnable</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              \t<span class=\"comment\">// 子进程在执行完 r.run() 后, 直接 return</span></span><br><span class=\"line\">              \t<span class=\"comment\">// 意味着只有父进程才能走到后续的代码流程</span></span><br><span class=\"line\">                r.run();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">&quot;Accepting command socket connections&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 分析见 3.1.1.3</span></span><br><span class=\"line\">        caller = zygoteServer.runSelectLoop(abiList);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">&quot;System zygote died with exception&quot;</span>, ex);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (zygoteServer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            zygoteServer.closeServerSocket();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (caller != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        caller.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此方法主要工作是启动 Zygote 进程，包含了预加载资源、创建 Socket、启动 system_server 进程等步骤，最后调用 <code>ZygoteServer.runSelectLoop</code> 方法。</p>\n<h5 id=\"3-1-1-1-Os-setpgid-int-int\"><a href=\"#3-1-1-1-Os-setpgid-int-int\" class=\"headerlink\" title=\"3.1.1.1 Os.setpgid(int, int)\"></a>3.1.1.1 Os.setpgid(int, int)</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * See &lt;a href=&quot;http://man7.org/linux/man-pages/man2/setpgid.2.html&quot;&gt;setpgid(2)&lt;/a&gt;.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@libcore</span>.api.CorePlatformApi</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setpgid</span><span class=\"params\">(<span class=\"keyword\">int</span> pid, <span class=\"keyword\">int</span> pgid)</span> <span class=\"keyword\">throws</span> ErrnoException </span>&#123; Libcore.os.setpgid(pid, pgid); &#125;</span><br></pre></td></tr></table></figure>\n<p>注意到，此时传入的参数 <code>pid</code>, <code>pgid</code> 都为 0。</p>\n<p>通过代码注释上的文档，可以了解到，当参数 <code>pid</code> 等于 0 时，将会给进程分配一个被使用过的进程 ID；当参数 <code>pgid</code> 等于 0 时，进程的 PGID 将会与它的进程 ID 保持一致。</p>\n<h5 id=\"3-1-1-2-ZygoteServer-boolean\"><a href=\"#3-1-1-2-ZygoteServer-boolean\" class=\"headerlink\" title=\"3.1.1.2 ZygoteServer(boolean)\"></a>3.1.1.2 ZygoteServer(boolean)</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZygoteServer(<span class=\"keyword\">boolean</span> isPrimaryZygote) &#123;</span><br><span class=\"line\">    mUsapPoolEventFD = Zygote.getUsapPoolEventFD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isPrimaryZygote) &#123;</span><br><span class=\"line\">        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME);</span><br><span class=\"line\">        mUsapPoolSocket =</span><br><span class=\"line\">                Zygote.createManagedSocketFromInitSocket(</span><br><span class=\"line\">                        Zygote.USAP_POOL_PRIMARY_SOCKET_NAME);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.SECONDARY_SOCKET_NAME);</span><br><span class=\"line\">        mUsapPoolSocket =</span><br><span class=\"line\">                Zygote.createManagedSocketFromInitSocket(</span><br><span class=\"line\">                        Zygote.USAP_POOL_SECONDARY_SOCKET_NAME);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fetchUsapPoolPolicyProps();</span><br><span class=\"line\"></span><br><span class=\"line\">    mUsapPoolSupported = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ZygoteServer 的构造方法主要工作是初始化作为服务端 Zygote 的 Socket 地址。</p>\n<h5 id=\"3-1-1-3-ZygoteServer-runSelectLoop-String\"><a href=\"#3-1-1-3-ZygoteServer-runSelectLoop-String\" class=\"headerlink\" title=\"3.1.1.3 ZygoteServer.runSelectLoop(String)\"></a>3.1.1.3 ZygoteServer.runSelectLoop(String)</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Runnable <span class=\"title\">runSelectLoop</span><span class=\"params\">(String abiList)</span> </span>&#123;</span><br><span class=\"line\">    ArrayList&lt;FileDescriptor&gt; socketFDs = <span class=\"keyword\">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class=\"line\">    ArrayList&lt;ZygoteConnection&gt; peers = <span class=\"keyword\">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    socketFDs.add(mZygoteSocket.getFileDescriptor());</span><br><span class=\"line\">    peers.add(<span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        fetchUsapPoolPolicyPropsWithMinInterval();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] usapPipeFDs = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        StructPollfd[] pollFDs = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mUsapPoolEnabled) &#123;</span><br><span class=\"line\">            usapPipeFDs = Zygote.getUsapPipeFDs();</span><br><span class=\"line\">            pollFDs = <span class=\"keyword\">new</span> StructPollfd[socketFDs.size() + <span class=\"number\">1</span> + usapPipeFDs.length];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            pollFDs = <span class=\"keyword\">new</span> StructPollfd[socketFDs.size()];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> pollIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (FileDescriptor socketFD : socketFDs) &#123;</span><br><span class=\"line\">            pollFDs[pollIndex] = <span class=\"keyword\">new</span> StructPollfd();</span><br><span class=\"line\">            pollFDs[pollIndex].fd = socketFD;</span><br><span class=\"line\">            pollFDs[pollIndex].events = (<span class=\"keyword\">short</span>) POLLIN;</span><br><span class=\"line\">            ++pollIndex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Os.poll(pollFDs, -<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ErrnoException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;poll failed&quot;</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> usapPoolFDRead = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (--pollIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((pollFDs[pollIndex].revents &amp; POLLIN) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pollIndex == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Zygote server socket</span></span><br><span class=\"line\"></span><br><span class=\"line\">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class=\"line\">                peers.add(newPeer);</span><br><span class=\"line\">                socketFDs.add(newPeer.getFileDescriptor());</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pollIndex &lt; usapPoolEventFDIndex) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Session socket accepted from the Zygote server socket</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    ZygoteConnection connection = peers.get(pollIndex);</span><br><span class=\"line\">                    <span class=\"keyword\">final</span> Runnable command = connection.processOneCommand(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// TODO (chriswailes): Is this extra check necessary?</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (mIsForkChild) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// We&#x27;re in the child. We should always have a command to run at this</span></span><br><span class=\"line\">                        <span class=\"comment\">// stage if processOneCommand hasn&#x27;t called &quot;exec&quot;.</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;command == null&quot;</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> command;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// We&#x27;re in the server - we should never have any commands to run.</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (command != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;command != null&quot;</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (connection.isClosedByPeer()) &#123;</span><br><span class=\"line\">                            connection.closeSocket();</span><br><span class=\"line\">                            peers.remove(pollIndex);</span><br><span class=\"line\">                            socketFDs.remove(pollIndex);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!mIsForkChild) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        Slog.e(TAG, <span class=\"string\">&quot;Exception executing zygote command: &quot;</span>, e);</span><br><span class=\"line\"></span><br><span class=\"line\">                        ZygoteConnection conn = peers.remove(pollIndex);</span><br><span class=\"line\">                        conn.closeSocket();</span><br><span class=\"line\"></span><br><span class=\"line\">                        socketFDs.remove(pollIndex);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        Log.e(TAG, <span class=\"string\">&quot;Caught post-fork exception in child process.&quot;</span>, e);</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    mIsForkChild = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> messagePayload = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[Zygote.USAP_MANAGEMENT_MESSAGE_BYTES];</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> readBytes = Os.read(pollFDs[pollIndex].fd, buffer, <span class=\"number\">0</span>, buffer.length);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (readBytes == Zygote.USAP_MANAGEMENT_MESSAGE_BYTES) &#123;</span><br><span class=\"line\">                        DataInputStream inputStream =</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> DataInputStream(<span class=\"keyword\">new</span> ByteArrayInputStream(buffer));</span><br><span class=\"line\"></span><br><span class=\"line\">                        messagePayload = inputStream.readLong();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        Log.e(TAG, <span class=\"string\">&quot;Incomplete read from USAP management FD of size &quot;</span></span><br><span class=\"line\">                                + readBytes);</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (pollIndex == usapPoolEventFDIndex) &#123;</span><br><span class=\"line\">                        Log.e(TAG, <span class=\"string\">&quot;Failed to read from USAP pool event FD: &quot;</span></span><br><span class=\"line\">                                + ex.getMessage());</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        Log.e(TAG, <span class=\"string\">&quot;Failed to read from USAP reporting pipe: &quot;</span></span><br><span class=\"line\">                                + ex.getMessage());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pollIndex &gt; usapPoolEventFDIndex) &#123;</span><br><span class=\"line\">                    Zygote.removeUsapTableEntry((<span class=\"keyword\">int</span>) messagePayload);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                usapPoolFDRead = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://gityuan.com/2016/02/01/android-booting/\">Android系统启动-综述</a></p>\n<p><a href=\"http://gityuan.com/2016/03/26/app-process-create/\">理解Android进程创建流程</a></p>\n<p><a href=\"https://www.jianshu.com/p/47d0121484fc\">Android系统启动Zygote进程(api 29)</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文基于源代码: android-security-10.0.0_r56</p>\n</blockquote>\n<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2>","more":"<h3 id=\"1-1-前置知识\"><a href=\"#1-1-前置知识\" class=\"headerlink\" title=\"1.1 前置知识\"></a>1.1 前置知识</h3><!-- TODO -->\n\n\n\n<h4 id=\"1-1-1-Android-系统启动概述\"><a href=\"#1-1-1-Android-系统启动概述\" class=\"headerlink\" title=\"1.1.1 Android 系统启动概述\"></a>1.1.1 Android 系统启动概述</h4><!-- TODO -->\n\n\n\n<h4 id=\"1-1-2-Linux-fork\"><a href=\"#1-1-2-Linux-fork\" class=\"headerlink\" title=\"1.1.2 Linux fork\"></a>1.1.2 Linux fork</h4><!-- TODO -->\n\n\n\n<h2 id=\"2-system-server-侧的逻辑\"><a href=\"#2-system-server-侧的逻辑\" class=\"headerlink\" title=\"2. system_server 侧的逻辑\"></a>2. system_server 侧的逻辑</h2><!-- TODO -->\n\n<p>system_server 作为进程创建的发起方，入口在 ProcessList 当中，进程的启动流程最终会走到 <code>ProcessList.startProcess</code> 方法。</p>\n<h3 id=\"2-1-ProcessList-startProcess-HostingRecord-String-ProcessRecord-int-int-int-int-String-String-String-String-long\"><a href=\"#2-1-ProcessList-startProcess-HostingRecord-String-ProcessRecord-int-int-int-int-String-String-String-String-long\" class=\"headerlink\" title=\"2.1 ProcessList.startProcess(HostingRecord, String, ProcessRecord, int, int[], int, int, String, String, String, String, long)\"></a>2.1 ProcessList.startProcess(HostingRecord, String, ProcessRecord, int, int[], int, int, String, String, String, String, long)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Process.<span class=\"function\">ProcessStartResult <span class=\"title\">startProcess</span><span class=\"params\">(HostingRecord hostingRecord, String entryPoint,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ProcessRecord app, <span class=\"keyword\">int</span> uid, <span class=\"keyword\">int</span>[] gids, <span class=\"keyword\">int</span> runtimeFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">long</span> startTime)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">&quot;Start proc: &quot;</span> +</span><br><span class=\"line\">                app.processName);</span><br><span class=\"line\">        checkSlow(startTime, <span class=\"string\">&quot;startProcess: asking zygote to start proc&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Process.ProcessStartResult startResult;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hostingRecord.usesWebviewZygote()) &#123;</span><br><span class=\"line\">            startResult = startWebView(entryPoint,</span><br><span class=\"line\">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class=\"line\">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class=\"line\">                    app.info.dataDir, <span class=\"keyword\">null</span>, app.info.packageName,</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hostingRecord.usesAppZygote()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> AppZygote appZygote = createAppZygoteForProcessIfNeeded(app);</span><br><span class=\"line\"></span><br><span class=\"line\">            startResult = appZygote.getProcess().start(entryPoint,</span><br><span class=\"line\">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class=\"line\">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class=\"line\">                    app.info.dataDir, <span class=\"keyword\">null</span>, app.info.packageName,</span><br><span class=\"line\">                    <span class=\"comment\">/*useUsapPool=*/</span> <span class=\"keyword\">false</span>,</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 一般的进程启动流程会进入此分支</span></span><br><span class=\"line\">            startResult = Process.start(entryPoint,</span><br><span class=\"line\">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class=\"line\">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class=\"line\">                    app.info.dataDir, invokeWith, app.info.packageName,</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        checkSlow(startTime, <span class=\"string\">&quot;startProcess: returned from zygote!&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> startResult;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般的进程启动流程，会调用 <code>Process.start</code> 方法，创建新进程。</p>\n<h3 id=\"2-2-Process-start-String-String-int-int-int-int-int-int-String-String-String-String-String-String-String\"><a href=\"#2-2-Process-start-String-String-int-int-int-int-int-int-String-String-String-String-String-String-String\" class=\"headerlink\" title=\"2.2 Process.start(String, String, int, int, int[], int, int, int, String, String, String, String, String, String, String[])\"></a>2.2 Process.start(String, String, int, int, int[], int, int, int, String, String, String, String, String, String, String[])</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ProcessStartResult <span class=\"title\">start</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@Nullable</span> <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"keyword\">int</span> uid, <span class=\"keyword\">int</span> gid, <span class=\"meta\">@Nullable</span> <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"keyword\">int</span> runtimeFlags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@Nullable</span> String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@NonNull</span> String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@Nullable</span> String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@Nullable</span> String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@Nullable</span> String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@Nullable</span> String packageName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@Nullable</span> String[] zygoteArgs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ZYGOTE_PROCESS.start(processClass, niceName, uid, gid, gids,</span><br><span class=\"line\">                runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class=\"line\">                abi, instructionSet, appDataDir, invokeWith, packageName,</span><br><span class=\"line\">                <span class=\"comment\">/*useUsapPool=*/</span> <span class=\"keyword\">true</span>, zygoteArgs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，<code>ZYGOTE_PROCESS</code> 是 ZygoteProcess 的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * State associated with the zygote process.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ZygoteProcess ZYGOTE_PROCESS = <span class=\"keyword\">new</span> ZygoteProcess();</span><br></pre></td></tr></table></figure>\n<p>再来看看 ZygoteProcess 的构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ZygoteProcess</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mZygoteSocketAddress =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> LocalSocketAddress(Zygote.PRIMARY_SOCKET_NAME,</span><br><span class=\"line\">                                   LocalSocketAddress.Namespace.RESERVED);</span><br><span class=\"line\">    mZygoteSecondarySocketAddress =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> LocalSocketAddress(Zygote.SECONDARY_SOCKET_NAME,</span><br><span class=\"line\">                                   LocalSocketAddress.Namespace.RESERVED);</span><br><span class=\"line\"></span><br><span class=\"line\">    mUsapPoolSocketAddress =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> LocalSocketAddress(Zygote.USAP_POOL_PRIMARY_SOCKET_NAME,</span><br><span class=\"line\">                                   LocalSocketAddress.Namespace.RESERVED);</span><br><span class=\"line\">    mUsapPoolSecondarySocketAddress =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> LocalSocketAddress(Zygote.USAP_POOL_SECONDARY_SOCKET_NAME,</span><br><span class=\"line\">                                   LocalSocketAddress.Namespace.RESERVED);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ZygoteProcess 的构造方法初始化了数个 Socket 地址，这些地址将会在与 Zygote 进程建立连接时用到。</p>\n<p>接下来分析 <code>ZygoteProcess.start</code> 方法。</p>\n<h3 id=\"2-3-ZygoteProcess-start-String-String-int-int-int-int-int-int-String-String-String-String-String-String-boolean-String\"><a href=\"#2-3-ZygoteProcess-start-String-String-int-int-int-int-int-int-String-String-String-String-String-String-boolean-String\" class=\"headerlink\" title=\"2.3 ZygoteProcess.start(String, String, int, int, int[], int, int, int, String, String, String, String, String, String, boolean, String[])\"></a>2.3 ZygoteProcess.start(String, String, int, int, int[], int, int, int, String, String, String, String, String, String, boolean, String[])</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Process.<span class=\"function\">ProcessStartResult <span class=\"title\">start</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"keyword\">int</span> uid, <span class=\"keyword\">int</span> gid, <span class=\"meta\">@Nullable</span> <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"keyword\">int</span> runtimeFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"meta\">@Nullable</span> String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"meta\">@NonNull</span> String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"meta\">@Nullable</span> String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"meta\">@Nullable</span> String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"meta\">@Nullable</span> String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"meta\">@Nullable</span> String packageName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"keyword\">boolean</span> useUsapPool,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                              <span class=\"meta\">@Nullable</span> String[] zygoteArgs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// UASP 相关, 分析见 2.3.1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fetchUsapPoolEnabledPropWithMinInterval()) &#123;</span><br><span class=\"line\">        informZygotesOfUsapPoolStatus();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class=\"line\">                runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class=\"line\">                abi, instructionSet, appDataDir, invokeWith, <span class=\"comment\">/*startChildZygote=*/</span> <span class=\"keyword\">false</span>,</span><br><span class=\"line\">                packageName, useUsapPool, zygoteArgs);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class=\"line\">        Log.e(LOG_TAG,</span><br><span class=\"line\">                <span class=\"string\">&quot;Starting VM process through Zygote failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"string\">&quot;Starting VM process through Zygote failed&quot;</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法中有一段与 UASP 相关的逻辑，分析见 2.3.1，紧接着就会调用 <code>ZygoteProcess.startViaZygote</code> 方法。</p>\n<p>注意到，此方法还会把 <code>ZygoteProcess.startViaZygote</code> 方法可能抛出的 <code>ZygoteStartFailedEx</code> 转换成 <code>RuntimeException</code>。</p>\n<h4 id=\"2-3-1-ZygoteProcess-fetchUsapPoolEnabledPropWithMinInterval\"><a href=\"#2-3-1-ZygoteProcess-fetchUsapPoolEnabledPropWithMinInterval\" class=\"headerlink\" title=\"2.3.1 ZygoteProcess.fetchUsapPoolEnabledPropWithMinInterval()\"></a>2.3.1 ZygoteProcess.fetchUsapPoolEnabledPropWithMinInterval()</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">fetchUsapPoolEnabledPropWithMinInterval</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> currentTimestamp = SystemClock.elapsedRealtime();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (SystemProperties.get(<span class=\"string\">&quot;dalvik.vm.boot-image&quot;</span>, <span class=\"string\">&quot;&quot;</span>).endsWith(<span class=\"string\">&quot;apex.art&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentTimestamp &lt;= <span class=\"number\">15000</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIsFirstPropCheck</span><br><span class=\"line\">            || (currentTimestamp - mLastPropCheckTimestamp &gt;= Zygote.PROPERTY_CHECK_INTERVAL)) &#123;</span><br><span class=\"line\">        mIsFirstPropCheck = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mLastPropCheckTimestamp = currentTimestamp;</span><br><span class=\"line\">      </span><br><span class=\"line\">      \t<span class=\"comment\">// 返回是否开启 UsapPool 的判断结果, 分析见 2.3.1.1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> fetchUsapPoolEnabledProp();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h5 id=\"2-3-1-1-ZygoteProcess-fetchUsapPoolEnabledProp\"><a href=\"#2-3-1-1-ZygoteProcess-fetchUsapPoolEnabledProp\" class=\"headerlink\" title=\"2.3.1.1 ZygoteProcess.fetchUsapPoolEnabledProp()\"></a>2.3.1.1 ZygoteProcess.fetchUsapPoolEnabledProp()</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">fetchUsapPoolEnabledProp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> origVal = mUsapPoolEnabled;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String propertyString = Zygote.getConfigurationProperty(</span><br><span class=\"line\">            ZygoteConfig.USAP_POOL_ENABLED, USAP_POOL_ENABLED_DEFAULT);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!propertyString.isEmpty()) &#123;</span><br><span class=\"line\">        mUsapPoolEnabled = Zygote.getConfigurationPropertyBoolean(</span><br><span class=\"line\">              ZygoteConfig.USAP_POOL_ENABLED,</span><br><span class=\"line\">              Boolean.parseBoolean(USAP_POOL_ENABLED_DEFAULT));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> valueChanged = origVal != mUsapPoolEnabled;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (valueChanged) &#123;</span><br><span class=\"line\">        Log.i(LOG_TAG, <span class=\"string\">&quot;usapPoolEnabled = &quot;</span> + mUsapPoolEnabled);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> valueChanged;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法的主要目的是从系统配置文件中加载 UsapPool 的开启状态，而默认状态 <code>USAP_POOL_ENABLED_DEFAULT</code> 是 false，也就是说 UsapPool 默认是不开启的。</p>\n<p>因此，接下来的分析都会默认跳过 UASP 相关逻辑。</p>\n<h3 id=\"2-4-ZygoteProcess-startViaZygote-String-String-int-int-int-int-int-int-String-String-String-String-String-boolean-String-boolean-String\"><a href=\"#2-4-ZygoteProcess-startViaZygote-String-String-int-int-int-int-int-int-String-String-String-String-String-boolean-String-boolean-String\" class=\"headerlink\" title=\"2.4 ZygoteProcess.startViaZygote(String, String, int, int, int[], int, int, int, String, String, String, String, String, boolean, String, boolean, String[])\"></a>2.4 ZygoteProcess.startViaZygote(String, String, int, int, int[], int, int, int, String, String, String, String, String, boolean, String, boolean, String[])</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Process.<span class=\"function\">ProcessStartResult <span class=\"title\">startViaZygote</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> uid, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> gid,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">int</span> runtimeFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@NonNull</span> String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">boolean</span> startChildZygote,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> String packageName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">boolean</span> useUsapPool,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"meta\">@Nullable</span> String[] extraArgs)</span></span></span><br><span class=\"line\"><span class=\"function\">                                                  <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">    ArrayList&lt;String&gt; argsForZygote = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// --runtime-args, --setuid=, --setgid=,</span></span><br><span class=\"line\">    <span class=\"comment\">// and --setgroups= must go first</span></span><br><span class=\"line\">    argsForZygote.add(<span class=\"string\">&quot;--runtime-args&quot;</span>);</span><br><span class=\"line\">    argsForZygote.add(<span class=\"string\">&quot;--setuid=&quot;</span> + uid);</span><br><span class=\"line\">    argsForZygote.add(<span class=\"string\">&quot;--setgid=&quot;</span> + gid);</span><br><span class=\"line\">    argsForZygote.add(<span class=\"string\">&quot;--runtime-flags=&quot;</span> + runtimeFlags);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(mLock) &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// openZygoteSocketIfNeeded 方法分析见 2.4.1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi),</span><br><span class=\"line\">                                          useUsapPool,</span><br><span class=\"line\">                                          argsForZygote);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法的主要目的是将 uid, gid 等参数保存在数组 <code>argsForZygote</code> 当中，接下来将会用到这些参数。</p>\n<h4 id=\"2-4-1-ZygoteProcess-openZygoteSocketIfNeeded-String\"><a href=\"#2-4-1-ZygoteProcess-openZygoteSocketIfNeeded-String\" class=\"headerlink\" title=\"2.4.1 ZygoteProcess.openZygoteSocketIfNeeded(String)\"></a>2.4.1 ZygoteProcess.openZygoteSocketIfNeeded(String)</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GuardedBy(&quot;mLock&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ZygoteState <span class=\"title\">openZygoteSocketIfNeeded</span><span class=\"params\">(String abi)</span> <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        attemptConnectionToPrimaryZygote();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> primaryZygoteState;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mZygoteSecondarySocketAddress != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The primary zygote didn&#x27;t match. Try the secondary.</span></span><br><span class=\"line\">            attemptConnectionToSecondaryZygote();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> secondaryZygoteState;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">&quot;Error connecting to zygote&quot;</span>, ioe);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">&quot;Unsupported zygote ABI: &quot;</span> + abi);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此方法主要目的是尝试与 Zygote 进程建立连接，如果失败，将会抛出异常。</p>\n<p>注意到，方法的注解 <code>@GuardedBy(&quot;mLock&quot;)</code> 表明外部在调用此方法之前需要对 <code>mLock</code> 加锁，以确保方法调用是同步的。</p>\n<h3 id=\"2-5-ZygoteProcess-zygoteSendArgsAndGetResult-ZygoteState-boolean-ArrayList\"><a href=\"#2-5-ZygoteProcess-zygoteSendArgsAndGetResult-ZygoteState-boolean-ArrayList\" class=\"headerlink\" title=\"2.5 ZygoteProcess.zygoteSendArgsAndGetResult(ZygoteState, boolean, ArrayList)\"></a>2.5 ZygoteProcess.zygoteSendArgsAndGetResult(ZygoteState, boolean, ArrayList)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GuardedBy(&quot;mLock&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Process.<span class=\"function\">ProcessStartResult <span class=\"title\">zygoteSendArgsAndGetResult</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ZygoteState zygoteState, <span class=\"keyword\">boolean</span> useUsapPool, <span class=\"meta\">@NonNull</span> ArrayList&lt;String&gt; args)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 检查参数中是否存在不合法字符</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String arg : args) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg.indexOf(<span class=\"string\">&#x27;\\n&#x27;</span>) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">&quot;Embedded newlines not allowed&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arg.indexOf(<span class=\"string\">&#x27;\\r&#x27;</span>) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">&quot;Embedded carriage returns not allowed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    String msgStr = args.size() + <span class=\"string\">&quot;\\n&quot;</span> + String.join(<span class=\"string\">&quot;\\n&quot;</span>, args) + <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> attemptZygoteSendArgsAndGetResult(zygoteState, msgStr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此方法检查参数的合法性，紧接着就调用了 <code>ZygoteProcess.attemptZygoteSendArgsAndGetResult</code> 方法。</p>\n<h3 id=\"2-6-ZygoteProcess-attemptZygoteSendArgsAndGetResult-ZygoteState-String\"><a href=\"#2-6-ZygoteProcess-attemptZygoteSendArgsAndGetResult-ZygoteState-String\" class=\"headerlink\" title=\"2.6 ZygoteProcess.attemptZygoteSendArgsAndGetResult(ZygoteState, String)\"></a>2.6 ZygoteProcess.attemptZygoteSendArgsAndGetResult(ZygoteState, String)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Process.<span class=\"function\">ProcessStartResult <span class=\"title\">attemptZygoteSendArgsAndGetResult</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ZygoteState zygoteState, String msgStr)</span> <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 已经与 Zygote 进程建立了 Socket 连接, 此时两者间的通信就像读写文件流一样方便</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 往 Zygote 写入参数</span></span><br><span class=\"line\">        zygoteWriter.write(msgStr);</span><br><span class=\"line\">        zygoteWriter.flush();</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 读取结果</span></span><br><span class=\"line\">        Process.ProcessStartResult result = <span class=\"keyword\">new</span> Process.ProcessStartResult();</span><br><span class=\"line\">        result.pid = zygoteInputStream.readInt();</span><br><span class=\"line\">        result.usingWrapper = zygoteInputStream.readBoolean();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.pid &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果读取到的 pid 小于 0, 说明进程创建失败</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">&quot;fork() failed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 当出现 IOException, 会关闭与 Zygote 进程的连接</span></span><br><span class=\"line\">        zygoteState.close();</span><br><span class=\"line\"></span><br><span class=\"line\">        Log.e(LOG_TAG, <span class=\"string\">&quot;IO Exception while communicating with Zygote - &quot;</span></span><br><span class=\"line\">                + ex.toString());</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 注意到, 方法结束后没有调用 zygoteState.close(), 说明此时仍会与 Zygote 进程保持连接</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此方法主要工作是与 Zygote 进程进行通信，向 Zygote 写入参数，通知 Zygote 创建进程。</p>\n<p>如果从 Zygote 返回的 pid &lt; 0，则说明进程创建失败；否则说明进程创建成功，通信结果包装在 <code>Process.ProcessStartResult</code> 当中。</p>\n<h2 id=\"3-Zygote-侧的逻辑\"><a href=\"#3-Zygote-侧的逻辑\" class=\"headerlink\" title=\"3. Zygote 侧的逻辑\"></a>3. Zygote 侧的逻辑</h2><!-- TODO -->\n\n\n\n<h3 id=\"3-1-Zygote-的启动过程\"><a href=\"#3-1-Zygote-的启动过程\" class=\"headerlink\" title=\"3.1 Zygote 的启动过程\"></a>3.1 Zygote 的启动过程</h3><p>Zygote 进程是由 init 进程创建的，在 Zygote 进程启动之后就会进入 <code>ZygoteInit.main</code> 方法。</p>\n<h4 id=\"3-1-1-ZygoteInit-main-String\"><a href=\"#3-1-1-ZygoteInit-main-String\" class=\"headerlink\" title=\"3.1.1 ZygoteInit.main(String)\"></a>3.1.1 ZygoteInit.main(String)</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String argv[])</span> </span>&#123;</span><br><span class=\"line\">    ZygoteServer zygoteServer = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在 Zygote 即将启动时调用, 调用此方法后可以使得任何线程的创建都将出错</span></span><br><span class=\"line\">    ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 分析见 3.1.1.1</span></span><br><span class=\"line\">        Os.setpgid(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ErrnoException ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Failed to setpgid(0,0)&quot;</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Runnable caller;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">      \t...</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 开启 DDMS</span></span><br><span class=\"line\">        RuntimeInit.enableDdms();</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 加载系统配置, 接下来的启动流程将会使用到这些配置</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> startSystemServer = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        String zygoteSocketName = <span class=\"string\">&quot;zygote&quot;</span>;</span><br><span class=\"line\">        String abiList = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> enableLazyPreload = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"string\">&quot;start-system-server&quot;</span>.equals(argv[i])) &#123;</span><br><span class=\"line\">                startSystemServer = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;--enable-lazy-preload&quot;</span>.equals(argv[i])) &#123;</span><br><span class=\"line\">                enableLazyPreload = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class=\"line\">                abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class=\"line\">                zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Unknown command line argument: &quot;</span> + argv[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// Zygote.PRIMARY_SOCKET_NAME = &quot;zygote&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (abiList == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;No ABI list supplied.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!enableLazyPreload) &#123;</span><br><span class=\"line\">            bootTimingsTraceLog.traceBegin(<span class=\"string\">&quot;ZygotePreload&quot;</span>);</span><br><span class=\"line\">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</span><br><span class=\"line\">                    SystemClock.uptimeMillis());</span><br><span class=\"line\">          </span><br><span class=\"line\">            <span class=\"comment\">// 预加载资源</span></span><br><span class=\"line\">            preload(bootTimingsTraceLog);</span><br><span class=\"line\">          </span><br><span class=\"line\">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</span><br><span class=\"line\">                    SystemClock.uptimeMillis());</span><br><span class=\"line\">            bootTimingsTraceLog.traceEnd();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Zygote.resetNicePriority();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        bootTimingsTraceLog.traceBegin(<span class=\"string\">&quot;PostZygoteInitGC&quot;</span>);</span><br><span class=\"line\">      \t<span class=\"comment\">// Zygote 启动过程走到这里, 会主动触发 GC</span></span><br><span class=\"line\">        gcAndFinalize();</span><br><span class=\"line\">        bootTimingsTraceLog.traceEnd();</span><br><span class=\"line\"></span><br><span class=\"line\">        bootTimingsTraceLog.traceEnd(); <span class=\"comment\">// ZygoteInit</span></span><br><span class=\"line\">        </span><br><span class=\"line\">      \t<span class=\"comment\">// <span class=\"doctag\">TODO:</span> 分析</span></span><br><span class=\"line\">        Trace.setTracingEnabled(<span class=\"keyword\">false</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// <span class=\"doctag\">TODO:</span> 分析</span></span><br><span class=\"line\">        Zygote.initNativeState(isPrimaryZygote);</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 在 Zygote 启动结束后调用, 与此方法开头调用的 ZygoteHooks.startZygoteNoThreadCreation() 对应</span></span><br><span class=\"line\">        <span class=\"comment\">// 此时线程的创建恢复正常</span></span><br><span class=\"line\">        ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// ZygoteServer 的构造方法分析见 3.1.1.2</span></span><br><span class=\"line\">        zygoteServer = <span class=\"keyword\">new</span> ZygoteServer(isPrimaryZygote);</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 启动 system_server 进程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (startSystemServer) &#123;</span><br><span class=\"line\">            Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class=\"line\"></span><br><span class=\"line\">          \t<span class=\"comment\">// 在 forkSystemServer 方法中执行了 fork 操作</span></span><br><span class=\"line\">          \t<span class=\"comment\">// 在父进程, 即 zygote 进程, 返回的 Runnable 是 null</span></span><br><span class=\"line\">          \t<span class=\"comment\">// 而在子进程, 即 system_server 进程, 返回的是非 null 的 Runnable</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              \t<span class=\"comment\">// 子进程在执行完 r.run() 后, 直接 return</span></span><br><span class=\"line\">              \t<span class=\"comment\">// 意味着只有父进程才能走到后续的代码流程</span></span><br><span class=\"line\">                r.run();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">&quot;Accepting command socket connections&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      \t<span class=\"comment\">// 分析见 3.1.1.3</span></span><br><span class=\"line\">        caller = zygoteServer.runSelectLoop(abiList);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">&quot;System zygote died with exception&quot;</span>, ex);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (zygoteServer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            zygoteServer.closeServerSocket();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (caller != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        caller.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此方法主要工作是启动 Zygote 进程，包含了预加载资源、创建 Socket、启动 system_server 进程等步骤，最后调用 <code>ZygoteServer.runSelectLoop</code> 方法。</p>\n<h5 id=\"3-1-1-1-Os-setpgid-int-int\"><a href=\"#3-1-1-1-Os-setpgid-int-int\" class=\"headerlink\" title=\"3.1.1.1 Os.setpgid(int, int)\"></a>3.1.1.1 Os.setpgid(int, int)</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * See &lt;a href=&quot;http://man7.org/linux/man-pages/man2/setpgid.2.html&quot;&gt;setpgid(2)&lt;/a&gt;.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@libcore</span>.api.CorePlatformApi</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setpgid</span><span class=\"params\">(<span class=\"keyword\">int</span> pid, <span class=\"keyword\">int</span> pgid)</span> <span class=\"keyword\">throws</span> ErrnoException </span>&#123; Libcore.os.setpgid(pid, pgid); &#125;</span><br></pre></td></tr></table></figure>\n<p>注意到，此时传入的参数 <code>pid</code>, <code>pgid</code> 都为 0。</p>\n<p>通过代码注释上的文档，可以了解到，当参数 <code>pid</code> 等于 0 时，将会给进程分配一个被使用过的进程 ID；当参数 <code>pgid</code> 等于 0 时，进程的 PGID 将会与它的进程 ID 保持一致。</p>\n<h5 id=\"3-1-1-2-ZygoteServer-boolean\"><a href=\"#3-1-1-2-ZygoteServer-boolean\" class=\"headerlink\" title=\"3.1.1.2 ZygoteServer(boolean)\"></a>3.1.1.2 ZygoteServer(boolean)</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZygoteServer(<span class=\"keyword\">boolean</span> isPrimaryZygote) &#123;</span><br><span class=\"line\">    mUsapPoolEventFD = Zygote.getUsapPoolEventFD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isPrimaryZygote) &#123;</span><br><span class=\"line\">        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME);</span><br><span class=\"line\">        mUsapPoolSocket =</span><br><span class=\"line\">                Zygote.createManagedSocketFromInitSocket(</span><br><span class=\"line\">                        Zygote.USAP_POOL_PRIMARY_SOCKET_NAME);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.SECONDARY_SOCKET_NAME);</span><br><span class=\"line\">        mUsapPoolSocket =</span><br><span class=\"line\">                Zygote.createManagedSocketFromInitSocket(</span><br><span class=\"line\">                        Zygote.USAP_POOL_SECONDARY_SOCKET_NAME);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fetchUsapPoolPolicyProps();</span><br><span class=\"line\"></span><br><span class=\"line\">    mUsapPoolSupported = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ZygoteServer 的构造方法主要工作是初始化作为服务端 Zygote 的 Socket 地址。</p>\n<h5 id=\"3-1-1-3-ZygoteServer-runSelectLoop-String\"><a href=\"#3-1-1-3-ZygoteServer-runSelectLoop-String\" class=\"headerlink\" title=\"3.1.1.3 ZygoteServer.runSelectLoop(String)\"></a>3.1.1.3 ZygoteServer.runSelectLoop(String)</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Runnable <span class=\"title\">runSelectLoop</span><span class=\"params\">(String abiList)</span> </span>&#123;</span><br><span class=\"line\">    ArrayList&lt;FileDescriptor&gt; socketFDs = <span class=\"keyword\">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class=\"line\">    ArrayList&lt;ZygoteConnection&gt; peers = <span class=\"keyword\">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    socketFDs.add(mZygoteSocket.getFileDescriptor());</span><br><span class=\"line\">    peers.add(<span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        fetchUsapPoolPolicyPropsWithMinInterval();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] usapPipeFDs = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        StructPollfd[] pollFDs = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mUsapPoolEnabled) &#123;</span><br><span class=\"line\">            usapPipeFDs = Zygote.getUsapPipeFDs();</span><br><span class=\"line\">            pollFDs = <span class=\"keyword\">new</span> StructPollfd[socketFDs.size() + <span class=\"number\">1</span> + usapPipeFDs.length];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            pollFDs = <span class=\"keyword\">new</span> StructPollfd[socketFDs.size()];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> pollIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (FileDescriptor socketFD : socketFDs) &#123;</span><br><span class=\"line\">            pollFDs[pollIndex] = <span class=\"keyword\">new</span> StructPollfd();</span><br><span class=\"line\">            pollFDs[pollIndex].fd = socketFD;</span><br><span class=\"line\">            pollFDs[pollIndex].events = (<span class=\"keyword\">short</span>) POLLIN;</span><br><span class=\"line\">            ++pollIndex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Os.poll(pollFDs, -<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ErrnoException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;poll failed&quot;</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> usapPoolFDRead = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (--pollIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((pollFDs[pollIndex].revents &amp; POLLIN) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pollIndex == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Zygote server socket</span></span><br><span class=\"line\"></span><br><span class=\"line\">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class=\"line\">                peers.add(newPeer);</span><br><span class=\"line\">                socketFDs.add(newPeer.getFileDescriptor());</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pollIndex &lt; usapPoolEventFDIndex) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Session socket accepted from the Zygote server socket</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    ZygoteConnection connection = peers.get(pollIndex);</span><br><span class=\"line\">                    <span class=\"keyword\">final</span> Runnable command = connection.processOneCommand(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// TODO (chriswailes): Is this extra check necessary?</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (mIsForkChild) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// We&#x27;re in the child. We should always have a command to run at this</span></span><br><span class=\"line\">                        <span class=\"comment\">// stage if processOneCommand hasn&#x27;t called &quot;exec&quot;.</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;command == null&quot;</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> command;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// We&#x27;re in the server - we should never have any commands to run.</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (command != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;command != null&quot;</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (connection.isClosedByPeer()) &#123;</span><br><span class=\"line\">                            connection.closeSocket();</span><br><span class=\"line\">                            peers.remove(pollIndex);</span><br><span class=\"line\">                            socketFDs.remove(pollIndex);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!mIsForkChild) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        Slog.e(TAG, <span class=\"string\">&quot;Exception executing zygote command: &quot;</span>, e);</span><br><span class=\"line\"></span><br><span class=\"line\">                        ZygoteConnection conn = peers.remove(pollIndex);</span><br><span class=\"line\">                        conn.closeSocket();</span><br><span class=\"line\"></span><br><span class=\"line\">                        socketFDs.remove(pollIndex);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        Log.e(TAG, <span class=\"string\">&quot;Caught post-fork exception in child process.&quot;</span>, e);</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    mIsForkChild = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> messagePayload = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[Zygote.USAP_MANAGEMENT_MESSAGE_BYTES];</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> readBytes = Os.read(pollFDs[pollIndex].fd, buffer, <span class=\"number\">0</span>, buffer.length);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (readBytes == Zygote.USAP_MANAGEMENT_MESSAGE_BYTES) &#123;</span><br><span class=\"line\">                        DataInputStream inputStream =</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> DataInputStream(<span class=\"keyword\">new</span> ByteArrayInputStream(buffer));</span><br><span class=\"line\"></span><br><span class=\"line\">                        messagePayload = inputStream.readLong();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        Log.e(TAG, <span class=\"string\">&quot;Incomplete read from USAP management FD of size &quot;</span></span><br><span class=\"line\">                                + readBytes);</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (pollIndex == usapPoolEventFDIndex) &#123;</span><br><span class=\"line\">                        Log.e(TAG, <span class=\"string\">&quot;Failed to read from USAP pool event FD: &quot;</span></span><br><span class=\"line\">                                + ex.getMessage());</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        Log.e(TAG, <span class=\"string\">&quot;Failed to read from USAP reporting pipe: &quot;</span></span><br><span class=\"line\">                                + ex.getMessage());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pollIndex &gt; usapPoolEventFDIndex) &#123;</span><br><span class=\"line\">                    Zygote.removeUsapTableEntry((<span class=\"keyword\">int</span>) messagePayload);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                usapPoolFDRead = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://gityuan.com/2016/02/01/android-booting/\">Android系统启动-综述</a></p>\n<p><a href=\"http://gityuan.com/2016/03/26/app-process-create/\">理解Android进程创建流程</a></p>\n<p><a href=\"https://www.jianshu.com/p/47d0121484fc\">Android系统启动Zygote进程(api 29)</a></p>"},{"title":"分析 init 进程的启动流程","_content":"\n\n\n> 本文基于源代码：android-security-10.0.0_r56\n\n\n\n# 1. 前言\n\n<!-- TODO: 关于 init 进程更好的概述 -->\n\nAndroid 基于 Linux 内核，在内核启动过程中会创建出 init 进程。\n\ninit 进程是用户空间的第一个进程，进程的 pid = 1。\n\n<!-- more -->\n\n\n\n# 2. 启动流程\n\n<!-- TODO: 总结 -->\n\n\n\n## 2.1 init 进程的入口\n\n<!-- TODO: 为什么是入口？ -->\n\n<!-- TODO: init 就是一个普通的命令行程序, 位置在 /system/core/init？ -->\n\n在 Android 9，init 进程的入口位于 `system/core/init/init.cpp` 中的 main 函数。\n\n在 Android 10 之后，init 进程的入口改到了 `system/core/init/main.cpp` 中的 main 函数。\n\n```c++\nint main(int argc, char** argv) {\n    ...\n\n    if (!strcmp(basename(argv[0]), \"ueventd\")) {\n        return ueventd_main(argc, argv);\n    }\n\n    if (argc > 1) {\n        if (!strcmp(argv[1], \"subcontext\")) {\n            android::base::InitLogging(argv, &android::base::KernelLogger);\n            const BuiltinFunctionMap& function_map = GetBuiltinFunctionMap();\n\n            return SubcontextMain(argc, argv, &function_map);\n        }\n\n        if (!strcmp(argv[1], \"selinux_setup\")) {\n            return SetupSelinux(argv);\n        }\n\n        if (!strcmp(argv[1], \"second_stage\")) {\n            return SecondStageMain(argc, argv);\n        }\n    }\n\n    return FirstStageMain(argc, argv);\n}\n```\n\n首先来了解其中使用到的两个库函数：`basename` 函数和 `strcmp` 函数。\n\n- `basename` 的函数原型为 `char* basename(char* __path)`，可以根据给定的一个路径，返回文件名。例如：传入参数 \"/system/bin/ueventd\"，函数会返回 \"ueventd\"。\n- `strcmp` 的函数原型为 `int strcmp(const char* __lhs, const char* __rhs)`，是一个字符串比较函数，返回值为整数。当两个字符串相等时，函数返回 0。\n\n再来分析 main 函数：函数的主要工作是根据参数 `argc` 和 `argv`，选择对应的执行方式。如果参数未匹配成功，则默认调用 `FirstStageMain` 函数。\n\n\n\n## 2.2 启动的第一阶段\n\n<!-- TODO: mkdir, mknod, tmpfs -->\n\n<!-- TODO: 所挂载的文件系统的用处 -->\n\n<!-- TODO: KernelLogging(/dev/kmsg) -->\n\n<!-- TODO: InstallRebootSignalHandlers -->\n\n调用 `int FirstStageMain(int argc, char** argv)` 进入启动的第一阶段，函数所在文件的路径为 `system/core/init/first_stage_init.cpp`：\n\n```c++\nint FirstStageMain(int argc, char** argv) {\n    ...\n\n    CHECKCALL(clearenv());\n    CHECKCALL(setenv(\"PATH\", _PATH_DEFPATH, 1));\n    // Get the basic filesystem setup we need put together in the initramdisk\n    // on / and then we'll let the rc file figure out the rest.\n    CHECKCALL(mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"));\n    CHECKCALL(mkdir(\"/dev/pts\", 0755));\n    CHECKCALL(mkdir(\"/dev/socket\", 0755));\n    CHECKCALL(mkdir(\"/dev/dm-user\", 0755));\n    CHECKCALL(mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL));\n#define MAKE_STR(x) __STRING(x)\n    CHECKCALL(mount(\"proc\", \"/proc\", \"proc\", 0, \"hidepid=2,gid=\" MAKE_STR(AID_READPROC)));\n#undef MAKE_STR\n\n    // Don't expose the raw commandline to unprivileged processes.\n    // 设置文件权限 [2.2.1]\n    CHECKCALL(chmod(\"/proc/cmdline\", 0440));\n    std::string cmdline;\n    android::base::ReadFileToString(\"/proc/cmdline\", &cmdline);\n    // Don't expose the raw bootconfig to unprivileged processes.\n    chmod(\"/proc/bootconfig\", 0440);\n    std::string bootconfig;\n    android::base::ReadFileToString(\"/proc/bootconfig\", &bootconfig);\n    gid_t groups[] = {AID_READPROC};\n    CHECKCALL(setgroups(arraysize(groups), groups));\n    CHECKCALL(mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL));\n    CHECKCALL(mount(\"selinuxfs\", \"/sys/fs/selinux\", \"selinuxfs\", 0, NULL));\n\n    CHECKCALL(mknod(\"/dev/kmsg\", S_IFCHR | 0600, makedev(1, 11)));\n\n    if constexpr (WORLD_WRITABLE_KMSG) {\n        CHECKCALL(mknod(\"/dev/kmsg_debug\", S_IFCHR | 0622, makedev(1, 11)));\n    }\n\n    CHECKCALL(mknod(\"/dev/random\", S_IFCHR | 0666, makedev(1, 8)));\n    CHECKCALL(mknod(\"/dev/urandom\", S_IFCHR | 0666, makedev(1, 9)));\n\n    // This is needed for log wrapper, which gets called before ueventd runs.\n    CHECKCALL(mknod(\"/dev/ptmx\", S_IFCHR | 0666, makedev(5, 2)));\n    CHECKCALL(mknod(\"/dev/null\", S_IFCHR | 0666, makedev(1, 3)));\n\n    // These below mounts are done in first stage init so that first stage mount can mount\n    // subdirectories of /mnt/{vendor,product}/.  Other mounts, not required by first stage mount,\n    // should be done in rc files.\n    // Mount staging areas for devices managed by vold\n    // See storage config details at http://source.android.com/devices/storage/\n    CHECKCALL(mount(\"tmpfs\", \"/mnt\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=1000\"));\n    // /mnt/vendor is used to mount vendor-specific partitions that can not be\n    // part of the vendor partition, e.g. because they are mounted read-write.\n    CHECKCALL(mkdir(\"/mnt/vendor\", 0755));\n    // /mnt/product is used to mount product-specific partitions that can not be\n    // part of the product partition, e.g. because they are mounted read-write.\n    CHECKCALL(mkdir(\"/mnt/product\", 0755));\n\n    // /debug_ramdisk is used to preserve additional files from the debug ramdisk\n    CHECKCALL(mount(\"tmpfs\", \"/debug_ramdisk\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=0\"));\n\n    // /second_stage_resources is used to preserve files from first to second\n    // stage init\n    CHECKCALL(mount(\"tmpfs\", kSecondStageRes, \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=0\"))\n#undef CHECKCALL\n\n    SetStdioToDevNull(argv);\n    // Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually\n    // talk to the outside world...\n    InitKernelLogging(argv);\n\n    if (!errors.empty()) {\n        for (const auto& [error_string, error_errno] : errors) {\n            LOG(ERROR) << error_string << \" \" << strerror(error_errno);\n        }\n        LOG(FATAL) << \"Init encountered errors starting first stage, aborting\";\n    }\n\n    LOG(INFO) << \"init first stage started!\";\n\n    ...\n\n    // 执行 /system/bin/init\n    // 注意到传入的参数是 selinux_setup, 因此接下来会调用 SetupSelinux 函数进行 SELinux 的初始化 [2.3]\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"selinux_setup\", nullptr};\n    auto fd = open(\"/dev/kmsg\", O_WRONLY | O_CLOEXEC);\n    dup2(fd, STDOUT_FILENO);\n    dup2(fd, STDERR_FILENO);\n    close(fd);\n    execv(path, const_cast<char**>(args));\n\n    // execv() only returns if an error happened, in which case we\n    // panic and never fall through this conditional.\n    PLOG(FATAL) << \"execv(\\\"\" << path << \"\\\") failed\";\n\n    return 1;\n}\n```\n\n此函数主要工作是挂载一些文件系统，然后执行 `/system/bin/init`，重新进入 main 函数，通过传入参数 `\"selinux_setup\"`，进而调用 SetupSelinux 函数，进行 SELinux 的初始化。\n\n\n\n### 2.2.1 设置文件或目录的权限\n\n在 Linux 系统上，`chmod` 命令用于控制用户对文件或者目录的权限，但只有文件所有者和超级用户可以修改文件或目录的权限。\n\n权限分为三类：读，写，执行。\n\n\n\n#### 2.2.1.1 符号表示法\n\n符号表示法用 10 位字符表示权限，其形式为：\n\n```\n-rwxrwxrwx\n```\n\n其中第一个字符表示文件类型，常见的符号有：\n\n- `-`，表示普通文件。\n- `d`，表示目录。\n- `c`，表示字符特殊文件。\n\n剩余的 9 个字符，每 3 个字符分为一组，分别表示文件所有者，用户组，其他用户的权限。\n\n3 个字符组成的字符串，第 1 位控制读权限，第 2 位控制写权限，第 3 位控制执行权限：\n\n- 如果拥有读权限，第 1 位字符为 `r`，否则为 `-`。\n- 如果拥有写权限，第 2 位字符为 `w`，否则为 `-`。\n- 如果拥有执行权限，第 3 位字符为 `x`，否则为 `-`。\n\n示例：`-rwxrw-r--` 表示一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。\n\n\n\n#### 2.2.1.2 数字表示法\n\n可以用 4 位八进制数字表示权限，第 1 位同样表示文件类型，剩余的 3 位数字，分别表示文件所有者，用户组，其他用户的权限。\n\n读，写，执行，这 3 类权限可以使用 3 位二进制数字表示，不同类型的权限单独对应二进制数字中一个位：\n\n|          数值          | 权限 |\n| :--------------------: | :--: |\n| 二进制：100，八进制：4 |  r   |\n| 二进制：010，八进制：2 |  w   |\n| 二进制：001，八进制：1 |  x   |\n| 二进制：000，八进制：0 |  -   |\n\n在各类权限对应的数值之和，可以代表一组特定的权限。由于和的数值范围为 0~7，因此可以通过一个八进制数字表示。示例：\n\n|          数值          | 权限 |\n| :--------------------: | :--: |\n| 二进制：111，八进制：7 | rwx  |\n| 二进制：110，八进制：6 | rw-  |\n| 二进制：101，八进制：5 | r-x  |\n| 二进制：000，八进制：0 | ---  |\n\n因此，用符号表示法表示的权限，同样可以使用数字表示法来表示，示例：\n\n| 符号表示法 | 数字表示法 |                             说明                             |\n| :--------: | :--------: | :----------------------------------------------------------: |\n| -rwxrwxrwx |    0777    | 一个普通文件，文件所有者，用户组，其他用户都有读，写，执行的权限 |\n| -rwxrw-r-- |    0764    | 一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。 |\n\n\n\n#### 2.2.1.3 分析源码中的权限设置\n\n```c++\n// Don't expose the raw commandline to unprivileged processes.\nCHECKCALL(chmod(\"/proc/cmdline\", 0440));\n\n// Don't expose the raw bootconfig to unprivileged processes.\nchmod(\"/proc/bootconfig\", 0440);\n```\n\n在源码中有两处使用到 `chmod` 命令，分别对文件 `/proc/cmdline`，`/proc/bootconfig` 设置了权限 `0440`，表明 root 用户 (文件所有者) 及其用户组也只有文件的读权限。\n\n\n\n## 2.3 初始化 SELinux\n\n<!-- TODO: 分析 SELinux -->\n\n调用 `int SetupSelinux(char** argv)` 进行 SELinux 的初始化，该函数所在文件的路径为 `system/core/init/selinux.cpp`：\n\n```c++\n// This function initializes SELinux then execs init to run in the init SELinux context.\nint SetupSelinux(char** argv) {\n    ...\n\n    // Set up SELinux, loading the SELinux policy.\n    // 初始化 SELinux\n    SelinuxSetupKernelLogging();\n    SelinuxInitialize();\n\n    ...\n\n    // 执行 /system/bin/init\n    // 注意到传入的参数是 second_stage, 因此接下来会调用 SecondStageMain 函数进入启动的第二阶段 [2.4]\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"second_stage\", nullptr};\n    execv(path, const_cast<char**>(args));\n\n    ...\n\n    return 1;\n}\n```\n\n函数首先初始化了 SELinux，然后执行 `/system/bin/init`，重新进入 main 函数，通过传入参数 `\"second_stage\"`，进而调用 SecondStageMain 函数，进入启动的第二阶段。\n\n\n\n## 2.4 启动的第二阶段\n\n<!-- TODO: property_load_boot_defaults -->\n\n<!-- TODO: 在编译的过程中, android 的各种系统参数会被汇总到 build.prop 文件中？ -->\n\n<!-- TODO: SELinux 相关代码的分析 -->\n\n<!-- TODO: keyctl_get_keyring_ID(KEY_SPEC_SESSION_KEYRING, 1) -->\n\n<!-- TODO: InitializeSubcontext() -->\n\n<!-- TODO: ActionManager 和 ServiceList 的作用 -->\n\n调用 `int SecondStageMain(int argc, char** argv)` 进入启动的第二阶段，函数所在文件的路径为 `system/core/init/init.cpp`：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n    ...\n\n    // Set init and its forked children's oom_adj.\n    // 设置 init 进程以及由其 fork 得到的子进程 oom_score_adj 的值\n    // 数值越小, 进程优先级越高\n    if (auto result = WriteFile(\"/proc/1/oom_score_adj\", \"-1000\"); !result) {\n        LOG(ERROR) << \"Unable to write -1000 to /proc/1/oom_score_adj: \" << result.error();\n    }\n\n    ...\n\n    // 初始化属性服务 [2.4.2.1]\n    property_init();\n\n    ...\n\n    // 初始化 epoll [2.4.1.1]\n    Epoll epoll;\n    if (auto result = epoll.Open(); !result) {\n        PLOG(FATAL) << result.error();\n    }\n\n    // 使用 epoll 对 init 子进程的信号进行监听 [2.4.3.1.3]\n    // 初始化子进程退出的信号处理函数\n    InstallSignalFdHandler(&epoll);\n\n    ...\n\n    // 开启属性服务 [2.4.2.2]\n    StartPropertyService(&epoll);\n\n    ...\n\n    ActionManager& am = ActionManager::GetInstance();\n    ServiceList& sm = ServiceList::GetInstance();\n\n    // 加载启动脚本 [2.4.4]\n    LoadBootScripts(am, sm);\n\n    ...\n\n    // 添加 Action [2.4.5.1]\n    am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\");\n    am.QueueEventTrigger(\"early-init\");\n    am.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\");\n    ...\n    am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\");\n\n    // 进入无限循环状态 [2.4.5]\n    while (true) {\n        auto epoll_timeout = std::optional<std::chrono::milliseconds>{};\n\n        if (do_shutdown && !shutting_down) {\n            do_shutdown = false;\n            if (HandlePowerctlMessage(shutdown_command)) {\n                shutting_down = true;\n            }\n        }\n\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            am.ExecuteOneCommand();\n        }\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            if (!shutting_down) {\n                auto next_process_action_time = HandleProcessActions();\n\n                if (next_process_action_time) {\n                    epoll_timeout = std::chrono::ceil<std::chrono::milliseconds>(\n                            *next_process_action_time - boot_clock::now());\n                    if (*epoll_timeout < 0ms) epoll_timeout = 0ms;\n                }\n            }\n\n            if (am.HasMoreCommands()) epoll_timeout = 0ms;\n        }\n\n        if (auto result = epoll.Wait(epoll_timeout); !result) {\n            LOG(ERROR) << result.error();\n        }\n    }\n\n    return 0;\n}\n```\n\n第二阶段的工作可以大致分为 5 个部分：\n\n- epoll\n\n- 属性服务\n\n- 信号\n\n- 加载启动脚本\n\n- 进入无限循环状态\n\n接下来将分别对这 5 个部分的工作进行分析。\n\n\n\n### 2.4.1 epoll\n\nepoll 是 Linux 提供的 I/O 事件通知机制。epoll 可以监听大量的文件描述符，检查其中某一个文件描述符是否进入就绪状态。\n\n\n\n#### 2.4.1.1 初始化\n\n在 init 进程中，epoll 通过以下代码初始化：\n\n```c++\nEpoll epoll;\nif (auto result = epoll.Open(); !result) {\n    PLOG(FATAL) << result.error();\n}\n```\n\n可以知道，epoll 实例是通过调用 Open 函数创建的，函数所在文件的路径为 `system/core/init/epoll.cpp`，来分析这个函数：\n\n```c++\nResult<Success> Epoll::Open() {\n    if (epoll_fd_ >= 0) return Success();\n\n    // 关键点\n    epoll_fd_.reset(epoll_create1(EPOLL_CLOEXEC));\n\n    if (epoll_fd_ == -1) {\n        return ErrnoError() << \"epoll_create1 failed\";\n    }\n    return Success();\n}\n```\n\n此函数的关键点在于调用 `epoll_create1`。`epoll_create1` 是一个系统调用，其新建了一个 epoll 实例并返回该实例文件描述符。\n\n\n\n#### 2.4.1.2 使用 epoll 监听文件描述符\n\n要使用 epoll 监听文件描述符，需要调用 RegisterHandler 函数，将文件描述符注册到 epoll。\n\n函数所在文件的路径为 `system/core/init/epoll.cpp`，此函数的关键点在于系统调用 epoll_ctl：\n\n```c++\nResult<Success> Epoll::RegisterHandler(int fd, std::function<void()> handler, uint32_t events) {\n    ...\n\n    // 关键点\n    if (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &ev) == -1) {\n\n        ...\n\n        return result;\n    }\n    return Success();\n}\n```\n\n首先来看下 epoll_ctl 这个系统调用。\n\n\n\n##### 2.4.1.2.1 系统调用 epoll_ctl\n\n**epoll_ctl** 是一个系统调用，函数原型为 `int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)`，用于对指定的文件描述符 fd 进行添加、修改或者删除操作。\n\n\n\n###### 2.4.1.2.1.1 参数\n\n首先来理解 epoll_ctl 的参数：\n\n- **epfd** 是 epoll 实例的文件描述符。\n\n- **op** 表示要执行的操作，有三种取值：\n\n  - **EPOLL_CTL_ADD**\n\n    添加指定的文件描述符到 epoll 的监控列表。\n\n  - **EPOLL_CTL_MOD**\n\n    修改 epoll 的监控列表中指定的文件描述符。\n\n  - **EPOLL_CTL_DEL**\n\n    从 epoll 的监控列表中删除指定的文件描述符。\n\n- **fd** 表示指定的文件描述符。\n\n- **event** 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，其定义如下：\n\n  ```c++\n  struct epoll_event {\n     uint32_t     events;      /* Epoll events */\n     epoll_data_t data;        /* User data variable */\n  };\n  ```\n\n  结构体成员 `events` 用于表示要监听的事件，可以由零个或者多个事件类型组成，下面列出部分常见的事件类型：\n\n  - \u0015\u0015**EPOLLIN**\n    表示关联的文件描述符可用于读操作。\n\n  - **EPOLLOUT**\n    表示关联的文件描述符可用于写操作。\n\n  - **EPOLLPRI**\n    表示关联的文件描述符出现异常情况。\n\n  - **EPOLLERR**\n    表示关联的文件描述符出现错误。\n\n  - **EPOLLHUP**\n    表示关联的文件描述符被挂断。\n\n  - **EPOLLONESHOT**\n    表示只监听文件描述符的一次事件。当事件触发之后，epoll 就会禁用此文件描述符。\n    如果想要继续监听该文件描述符的事件，需要再次调用 epoll_ctl，并执行 EPOLL_CTL_MOD 操作。\n\n  结构体成员 `data` 的作用是将其数据交给内核保存，当文件描述符就绪后，内核会返回保存的数据 [2.4.1.3]。`epoll_data_t` 是一个共用体，其定义如下：\n\n  ```c++\n  typedef union epoll_data {\n     void        *ptr;\n     int          fd;\n     uint32_t     u32;\n     uint64_t     u64;\n  } epoll_data_t;\n  ```\n\n\n\n###### 2.4.1.2.1.2 返回值\n\n最后来了解 epoll_ctl 的返回值：\n\n- 当操作成功时，返回值为 0。\n\n- 当发生错误时，返回值为 -1。\n\n\n\n##### 2.4.1.2.2 分析 RegisterHandler 函数\n\n在了解过系统调用 epoll_ctl 以后，现在开始分析 RegisterHandler 函数。首先来看函数在头文件中的声明，头文件的路径为 `system/core/init/epoll.h`：\n\n```c++\nclass Epoll {\n  public:\n    Result<Success> RegisterHandler(int fd, std::function<void()> handler,\n                                    uint32_t events = EPOLLIN);\n};\n```\n\n由函数原型可知，函数的第三个参数 `events` 有默认值 `EPOLLIN`，表示监听文件描述符的读操作是否可用。\n\n接下来分析 RegisterHandler 函数：\n\n```c++\nResult<Success> Epoll::RegisterHandler(int fd, std::function<void()> handler, uint32_t events) {\n    ...\n\n    // handler 是事件触发时的回调函数\n    auto [it, inserted] = epoll_handlers_.emplace(fd, std::move(handler));\n\n    ...\n\n    epoll_event ev;\n\n    // 设置要监听的事件类型\n    // 由于 events 有默认值 EPOLLIN, 因此默认监听的事件类型是读操作是否可用\n    ev.events = events;\n  \n    // 设置回调函数, 回调函数会在事件触发后被调用 [2.4.1.3.2]\n    ev.data.ptr = reinterpret_cast<void*>(&it->second);\n\n    // 发起 epoll_ctl 系统调用\n    // 注意到第二个参数传入的是 EPOLL_CTL_ADD, 因此对指定文件描述符执行的是添加操作\n    if (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &ev) == -1) {\n        Result<Success> result = ErrnoError() << \"epoll_ctl failed to add fd\";\n        epoll_handlers_.erase(fd);\n        return result;\n    }\n    return Success();\n}\n```\n\n经过分析，可以知道函数的主要工作是：设置文件描述符需要监听的事件类型 `events` 以及事件触发时的回调函数 `handler`，最后发起 `epoll_ctl` 系统调用，将文件描述符添加到 epoll 监控列表。\n\n\n\n#### 2.4.1.3 等待事件触发\n\n经过 epoll 的初始化以及将文件描述符注册到 epoll 之后，接下来就需要等待事件触发，然后处理事件。\n\n在 init 进程启动的第二阶段，最后一个步骤就是进入死循环，不断地等待事件触发。接下来看下这段逻辑：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n    ...\n\n    while (true) {\n        ...\n\n        // 关键点\n        if (auto result = epoll.Wait(epoll_timeout); !result) {\n            LOG(ERROR) << result.error();\n        }\n    }\n\n    return 0;\n}\n```\n\n这段逻辑的关键点在于 Wait 函数，接下来分析这个函数。\n\n\n\n##### 2.4.1.3.1 系统调用 epoll_wait\n\n在分析 Wait 函数之前，首先要了解系统调用 epoll_wait，这个系统调用是 Wait 函数的关键点。\n\n**epoll_wait** 是一个系统调用，函数原型为 `int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)`，用于等待 epoll 上的事件。\n\n调用 epoll_wait 便会进入阻塞状态，直至满足以下任一条件，调用才会返回：\n\n- 监听的文件描述符传递一个事件；\n- 调用被信号处理程序中断；\n- 等待超出超时时长。\n\n\n\n###### 2.4.1.3.1.1 参数\n\n首先来理解 epoll_wait 的参数：\n\n- **epfd** 是 epoll 实例的文件描述符。\n\n- **events** 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，在 [2.4.1.2.1] 一节已经详细介绍过。\n\n  当事件触发后，调用就会返回，此时可以从 events 中得到已触发事件的集合。集合中每一个事件结构体 epoll_event 的 data 字段和调用 epoll_ctl 为相应的文件描述符设置的 data 字段是相同的。意味着，当事件触发后，之前调用 epoll_ctl 给指定文件描述符设置的 event.data 会通过这个参数返回给 epoll_wait 的调用者。\n\n- **maxevents** 表示在一次调用中返回事件的最大数量。因此，从参数 events 中得到的事件数量不会大于 maxevents。\n\n- **timeout** 是此次调用的超时时长。当 timeout = -1 时，调用将会一直阻塞，直到有事件发生；当 timeout = 0 时，调用会立即返回，即使当前没有事件发生。\n\n\n\n###### 2.4.1.3.1.2 返回值\n\n最后来了解 epoll_wait 的返回值：\n\n- 当调用成功时，返回值为已就绪的文件描述符的数量，此时可以对这些文件描述符进行 I/O 操作。\n\n  需要注意的是，如果该调用是因为超出等待时长而返回的，则返回值为 0，表明没有已就绪的文件描述符。\n\n- 当调用失败时，返回值为 -1，并返回错误信息。\n\n\n\n##### 2.4.1.3.2 分析 Wait 函数\n\n在了解过系统调用 epoll_wait 以后，就可以开始分析 Wait 函数，函数所在文件的路径为 `system/core/init/epoll.cpp`：\n\n```c++\nResult<Success> Epoll::Wait(std::optional<std::chrono::milliseconds> timeout) {\n    // 超时时长默认值为 -1\n    int timeout_ms = -1;\n\n    if (timeout && timeout->count() < INT_MAX) {\n        // 当参数 timeout 满足不等于 0 和数值没有溢出时, 更新超时时长\n        timeout_ms = timeout->count();\n    }\n\n    epoll_event ev;\n\n    // 发起 epoll_wait 系统调用\n    // 注意到第三个参数传入的是 1, 表明每次调用最多返回 1 个事件\n    auto nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd_, &ev, 1, timeout_ms));\n\n    if (nr == -1) {\n        // 调用返回 -1, 表明此次调用失败\n        return ErrnoError() << \"epoll_wait failed\";\n    } else if (nr == 1) {\n        // 调用返回 1, 表明此次调用成功, 有 1 个事件触发\n        // ev.data.ptr 是之前调用 epoll_ctl 给指定文件描述符设置的回调函数, 因此事件最后交给回调函数进行处理\n        std::invoke(*reinterpret_cast<std::function<void()>*>(ev.data.ptr));\n    }\n    return Success();\n}\n```\n\n此函数设置了超时时长，然后发起 `epoll_wait` 系统调用，等待事件触发。当 `epoll_wait` 成功返回时，会从返回的数据里面取出之前通过 epoll_ctl 设置的回调函数，将事件交由回调函数处理。\n\n\n\n### 2.4.2 属性服务\n\n属性服务是 Android 提供的一个用于存取系统属性的服务，属性以 key-value 的形式存储在一块共享内存，所有进程都可以通过这个服务获取和设置属性。\n\n使用 adb，输入命令 `getprop`，可以查看一台设备上的属性，下面列举其中的一些输出：\n\n```\n[ro.product.brand]: [Redmi]\n[ro.product.manufacturer]: [Xiaomi]\n[ro.product.marketname]: [Redmi K30S Ultra]\n[ro.product.model]: [M2007J3SC]\n[ro.product.name]: [apollo]\n\n[ro.product.cpu.abi]: [arm64-v8a]\n[ro.product.cpu.abilist]: [arm64-v8a,armeabi-v7a,armeabi]\n[ro.product.cpu.abilist32]: [armeabi-v7a,armeabi]\n[ro.product.cpu.abilist64]: [arm64-v8a]\n\n[dalvik.vm.heapsize]: [512m]\n[dalvik.vm.heapstartsize]: [8m]\n```\n\n通过列举出的数据，可以看出属性里面包含了很多重要的信息：机型信息，CPU 架构，虚拟机分配的内存大小等等。\n\n在 Java 代码中，可以调用 `SystemProperties.get(String, String)` 方法获取系统属性。例如，在 ActivityManager 中就有这样的代码：\n\n```java\nstatic public int staticGetLargeMemoryClass() {\n    // 通过获取系统属性 dalvik.vm.heapsize, 得出应用可用堆内存的最大值\n    String vmHeapSize = SystemProperties.get(\"dalvik.vm.heapsize\", \"16m\");\n\n    return Integer.parseInt(vmHeapSize.substring(0, vmHeapSize.length() - 1));\n}\n```\n\n类似地，调用 `SystemProperties.set(String, String)` 方法可以设置系统属性。例如，在 ActivityManagerService 中就有这样的代码：\n\n```java\nfinal void finishBooting() {\n    ...\n\n    synchronized (this) {\n\n        ...\n\n        // Tell anyone interested that we are done booting!\n        // 通过设置属性 sys.boot_completed = 1, 标记系统已经启动完成\n        SystemProperties.set(\"sys.boot_completed\", \"1\");\n\n        ...\n    }\n\n    ...\n}\n```\n\n\n\n#### 2.4.2.1 初始化\n\n<!-- TODO: 如何创建内存区域？ -->\n\n<!-- TODO: 进程是怎样获取共享内存中的属性？ -->\n\n<!-- TODO: 进程为什么不能直接设置共享内存中的属性？ -->\n\n<!-- TODO: CreateSerializedPropertyInfo() -->\n\n<!-- TODO: property_info_area.LoadDefaultPath() -->\n\n属性服务初始化时，调用的是 property_init 函数，文件路径为 `system/core/init/property_service.cpp`。\n\n```c++\nvoid property_init() {\n    mkdir(\"/dev/__properties__\", S_IRWXU | S_IXGRP | S_IXOTH);\n    CreateSerializedPropertyInfo();\n\n    // 创建内存区域\n    if (__system_property_area_init()) {\n        LOG(FATAL) << \"Failed to initialize property area\";\n    }\n\n    if (!property_info_area.LoadDefaultPath()) {\n        LOG(FATAL) << \"Failed to load serialized property info file\";\n    }\n}\n```\n\n函数最主要的工作是通过调用 `__system_property_area_init` 函数，创建用于存储属性的内存区域。\n\n\n\n#### 2.4.2.2 启动\n\n<!-- TODO: socket 的创建过程 -->\n\n<!-- TODO: listen(property_set_fd, 8) -->\n\n<!-- TODO: 一个进程是怎样向 init 进程发起属性设置的请求？ -->\n\n属性服务启动时，调用的是 StartPropertyService 函数，文件路径为 `system/core/init/property_service.cpp`：\n\n```c++\nvoid StartPropertyService(Epoll* epoll) {\n\n    ...\n\n    // 创建 socket 并返回其文件描述符, 其中 PROP_SERVICE_NAME = \"property_service\"\n    property_set_fd = CreateSocket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,\n                                   false, 0666, 0, 0, nullptr);\n    if (property_set_fd == -1) {\n        PLOG(FATAL) << \"start_property_service socket creation failed\";\n    }\n\n    listen(property_set_fd, 8);\n\n    // 将 socket 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]\n    // handle_property_set_fd 是可读事件触发时的回调函数 [2.4.2.3]\n    if (auto result = epoll->RegisterHandler(property_set_fd, handle_property_set_fd); !result) {\n        PLOG(FATAL) << result.error();\n    }\n}\n```\n\n此函数首先创建名称为 property_service 的 socket，然后将 socket 文件描述符注册到 epoll，监听其可读事件。\n\n当可读事件触发时，会进入回调函数 `handle_property_set_fd`，接着来分析这个回调函数。\n\n\n\n#### 2.4.2.3 回调函数 handle_property_set_fd\n\n<!-- TODO: ucred cr; socklen_t cr_size = sizeof(cr); -->\n\n<!-- TODO: 设置属性的具体实现 -->\n\n<!-- TODO: 除了通过向 init 进程发出请求设置属性以外, 在其他地方是否也有属性的设置？ -->\n\n<!-- TODO: 属性的同步问题 -->\n\n函数所在文件的路径为 `system/core/init/property_service.cpp`：\n\n```c++\nstatic void handle_property_set_fd() {\n    // 2000ms\n    static constexpr uint32_t kDefaultSocketTimeout = 2000; /* ms */\n\n    ...\n\n    SocketConnection socket(s, cr);\n\n    // 设置 2000ms 的超时时长\n    uint32_t timeout_ms = kDefaultSocketTimeout;\n\n    uint32_t cmd = 0;\n    if (!socket.RecvUint32(&cmd, &timeout_ms)) {\n        PLOG(ERROR) << \"sys_prop: error while reading command from the socket\";\n        socket.SendUint32(PROP_ERROR_READ_CMD);\n        return;\n    }\n\n    switch (cmd) {\n    // 处理 PROP_MSG_SETPROP 命令\n    case PROP_MSG_SETPROP: {\n        // PROP_NAME_MAX = 32\n        char prop_name[PROP_NAME_MAX];\n        char prop_value[PROP_VALUE_MAX];\n\n        // 接收属性名和属性值, 分别存储于字符数组 prop_name 和 prop_value 中\n        if (!socket.RecvChars(prop_name, PROP_NAME_MAX, &timeout_ms) ||\n            !socket.RecvChars(prop_value, PROP_VALUE_MAX, &timeout_ms)) {\n          PLOG(ERROR) << \"sys_prop(PROP_MSG_SETPROP): error while reading name/value from the socket\";\n          return;\n        }\n\n        // 将字符数组中最后的一个元素设置为 0\n        prop_name[PROP_NAME_MAX-1] = 0;\n        prop_value[PROP_VALUE_MAX-1] = 0;\n\n        const auto& cr = socket.cred();\n        std::string error;\n\n        // 设置属性\n        uint32_t result =\n            HandlePropertySet(prop_name, prop_value, socket.source_context(), cr, &error);\n\n        if (result != PROP_SUCCESS) {\n            LOG(ERROR) << \"Unable to set property '\" << prop_name << \"' to '\" << prop_value\n                       << \"' from uid:\" << cr.uid << \" gid:\" << cr.gid << \" pid:\" << cr.pid << \": \"\n                       << error;\n        }\n\n        break;\n      }\n\n    // 处理 PROP_MSG_SETPROP2 命令\n    case PROP_MSG_SETPROP2: {\n        std::string name;\n        std::string value;\n\n        // 接收字符串类型的属性名和属性值\n        if (!socket.RecvString(&name, &timeout_ms) ||\n            !socket.RecvString(&value, &timeout_ms)) {\n          PLOG(ERROR) << \"sys_prop(PROP_MSG_SETPROP2): error while reading name/value from the socket\";\n          socket.SendUint32(PROP_ERROR_READ_DATA);\n          return;\n        }\n\n        const auto& cr = socket.cred();\n        std::string error;\n\n        // 设置属性\n        uint32_t result = HandlePropertySet(name, value, socket.source_context(), cr, &error);\n\n        if (result != PROP_SUCCESS) {\n            LOG(ERROR) << \"Unable to set property '\" << name << \"' to '\" << value\n                       << \"' from uid:\" << cr.uid << \" gid:\" << cr.gid << \" pid:\" << cr.pid << \": \"\n                       << error;\n        }\n        socket.SendUint32(result);\n        break;\n      }\n\n    default:\n        LOG(ERROR) << \"sys_prop: invalid command \" << cmd;\n        socket.SendUint32(PROP_ERROR_INVALID_CMD);\n        break;\n    }\n}\n```\n\n函数初始化了 socket 接收事件的超时时长，然后对接收到的 `cmd` 做相应的操作：\n\n- 对于 `PROP_MSG_SETPROP` 命令，使用两个长度为 `PROP_NAME_MAX` 的字符数组保存接收到的属性名和属性值。值得注意的是，最后会将字符数组中最后的一个元素设为 0，因此接收的属性名和属性值的最大长度不应超过 `PROP_NAME_MAX - 1` 。\n- 对于 `PROP_MSG_SETPROP2` 命令，使用两个 `std::string` 保存接收到的属性名和属性值。\n\n最后，不论是 `PROP_MSG_SETPROP` 命令还是 `PROP_MSG_SETPROP2` 命令，都会调用 `HandlePropertySet` 函数来设置属性。\n\n\n\n### 2.4.3 信号\n\n**信号 (Signals)** 属于 IPC 的一种方式，用于向一个进程或者进程中的特定线程发送事件通知。\n\n信号是一个**异步的**通信机制，一个进程可以不需要等待信号的到达。在信号未产生时，进程会正常执行；当信号产生后，系统可以中断目标进程的任何非原子操作，此时进程的正常执行流程会被中断，进而对信号进行处理。\n\n\n\n#### 2.4.3.1 处理信号\n\n在 Linux，一个子进程终结后，内核依然会为其维护关于此进程的最小信息集 (PID、终结状态、资源使用信息)，以便父进程获取有关子进程的信息。如果父进程没有为该子进程发起 wait、waitpid 或者 waitid 系统调用，那么子进程的信息就会一直占据着内核进程表的空间。在这种情况下，这个子进程就成为了一个**僵尸进程 (Zombie process)**。\n\n一般情况下，对于一个僵尸进程，如果其父进程终结了，那么 init 进程就会自动成为僵尸进程的父进程。此时，为了避免僵尸进程一直占据着系统资源，init 进程需要为僵尸进程释放占据的空间。\n\n而且，在加载启动脚本 [2.4.4] 这一步骤中，init 进程会 fork 得到一些子进程，例如：servicemanager 进程、zygote 进程。这些子进程对 Android 而言非常重要，在这些进程退出后，init 进程需要有相应的动作将其重启。\n\n于是，为了管理这些子进程，init 进程需要接收子进程终结的信号并进行相应的处理。\n\n在 Android，信号处理基于 Linux 的信号机制。\n\n\n\n##### 2.4.3.1.1 信号的处理方式\n\n<!-- 更正: 注册信号处理函数 -->\n\n信号的处理方式有以下三种：\n\n- \u0015\u0015**忽略该信号**\n- **按信号的默认行为处理该信号**\n- **使用自定义的信号处理函数来处理该信号**\n\ninit 进程使用的是第三种处理方式：使用自定义的信号处理函数来处理该信号。进程注册了一个信号处理函数，当目标信号产生时，信号会被捕获，并调用注册的函数进行处理。\n\n接下来分析这个过程。\n\n\n\n##### 2.4.3.1.2 系统调用 sigaction\n\n在分析 init 进程注册函数的过程之前，首先来了解系统调用 sigaction，这个系统调用是此过程的一个关键点。\n\n**sigaction** 是一个系统调用，函数原型为 `int sigaction(int signum, const struct sigaction *restrict act, struct sigaction *restrict oldact)`，用于更改进程在收到指定信号后的行为。\n\n\n\n###### 2.4.3.1.2.1 参数\n\n首先来理解 sigaction 的参数：\n\n- **signum** 是指定信号的编号。\n\n  同一个信号在不同的架构上可能有不同的编号。在 Android，ARM 架构的信号编号定义在 `bionic/libc/kernel/uapi/asm-arm/asm/signal.h` 文件上。\n\n- **act** 是一个 sigaction 类型的指针，而 sigaction 是一个结构体，其定义如下：\n\n  ```c++\n  struct sigaction {\n     void     (*sa_handler)(int);\n     void     (*sa_sigaction)(int, siginfo_t *, void *);\n     sigset_t   sa_mask;\n     int        sa_flags;\n     void     (*sa_restorer)(void);\n  };\n  ```\n\n  关注结构体中两个较为重要的成员 `sa_handler` 和 `sa_flags`。\n\n  成员 `sa_handler` 用于指定信号产生时的行为，可以是以下这些值之一：\n\n  - **SIG_DFL**\n\n    表示执行该信号的默认行为。\n\n  - **SIG_IGN**\n\n    表示忽略该信号。\n\n  - **一个指向信号处理函数的指针**\n\n    信号编号 signum 将作为函数的唯一参数传入。当目标信号产生时，会自动调用此函数进行处理。\n\n  成员 `sa_flags` 是标志位，可以由零个或者多个标志组成。下面列出其中的一些标志：\n\n  - **SA_NOCLDSTOP**\n\n    只有当 signum = SIGCHLD 时才有意义。表示进程不接收子进程停止或者恢复时产生的信号，只接收子进程终结的信号。\n\n  - **SA_RESETHAND**\n\n    当信号已经由信号处理函数处理过后，将信号恢复为使用默认行为进行处理。\n\n  - **SA_SIGINFO**\n\n    不再通过结构体成员 sa_handler 设置信号处理函数，而是使用成员 sa_sigaction。此时，函数的入参有三个。\n\n- **oldact** 同样是一个 sigaction 类型的指针，用于保存上一个 sigaction 调用所传入的参数 act，可以为空。\n\n\n\n###### 2.4.3.1.2.2 返回值\n\n最后来了解 sigaction 的返回值：\n\n- 当操作成功时，返回值为 0。\n\n- 当发生错误时，返回值为 -1。\n\n\n\n##### 2.4.3.1.3 init 进程注册信号处理函数\n\n在了解过系统调用 sigaction 以后，现在可以开始分析 init 进程注册信号处理函数的过程。\n\n\n\n###### 2.4.3.1.3.1 发起系统调用 sigaction\n\ninit 进程通过调用 InstallSignalFdHandler 函数实现注册信号处理函数，函数所在文件的路径为 `system/core/init/init.cpp`，首先来关注函数前半部分所做的工作：\n\n```c++\nstatic void InstallSignalFdHandler(Epoll* epoll) {\n    // 构建结构体 sigaction\n    // 成员 sa_handler 用于指定信号产生时的行为, 令 sa_handler = SIG_DFL 表明当信号产生时按默认行为对信号进行处理\n    // 成员 sa_flags 是标志位, 令 sa_flags = SA_NOCLDSTOP 表明 init 进程不接收子进程被中断或者被中断后恢复时产生的信号, 只接收子进程终结的信号\n    const struct sigaction act { .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDSTOP };\n\n    // sigaction 是一个系统调用, 用于更改进程在收到指定的信号时所执行的操作 [2.4.3.1.2]\n    // 注意到第一个参数传入的是 SIGCHLD, 表明目标信号是 SIGCHLD, 当子进程终结, 被中断, 或者被中断后恢复时, 就会产生此信号\n    sigaction(SIGCHLD, &act, nullptr);\n\n    ...\n\n}\n```\n\n函数前半部分所做的工作是：发起系统调用 sigaction，针对子进程产生的 `SIGCHLD` 信号，当进程在收到信号时，按默认行为对信号进行处理，而 `SIGCHLD` 信号的默认行为就是忽略该信号。\n\n值得注意的是，当子进程终结、被中断或者被中断后恢复时，都会产生 `SIGCHLD` 信号，而添加标志位 `SA_NOCLDSTOP` 可以使得 init 进程只接收子进程终结的信号。\n\n显然，在函数前半部分所做的工作中，并没有实现按自定义行为对信号进行处理。事实上，init 进程是通过监听 signal 文件描述符来实现按自定义行为来处理信号的。接下来分析 InstallSignalFdHandler 函数后半部分所做的工作。\n\n\n\n###### 2.4.3.1.3.2 监听 signal 文件描述符\n\n之前提到，信号是一个异步的通信机制。进程可以注册一个信号处理函数，接着就能继续进行其他的工作，只有当目标信号发送到进程时，才回调处理函数进行处理，这里就体现出异步的性质。\n\n除了异步的方式以外，进程还可以通过同步的方式接收信号。Linux 提供了系统调用 signalfd，用于创建一个接收指定信号的文件描述符。对文件描述符执行读操作会进入阻塞状态，直到目标信号产生并传递给进程。\n\ninit 进程就是通过这种方式来同步接收信号的，接下来分析这个过程：\n\n```c++\nstatic void InstallSignalFdHandler(Epoll* epoll) {\n\n    ...\n\n    // mask 是一个信号集, 用于指定想要接收的信号\n    // 在这里, 目标信号就是 SIGCHLD\n    sigset_t mask;\n    sigemptyset(&mask);\n    sigaddset(&mask, SIGCHLD);\n\n    ...\n\n    // 获取 signal 文件描述符\n    // 注意到, 在发起系统调用 signalfd 时, 传入的第一个参数是 -1, 则调用会创建一个新的文件描述符\n    signal_fd = signalfd(-1, &mask, SFD_CLOEXEC);\n\n    if (signal_fd == -1) {\n        PLOG(FATAL) << \"failed to create signalfd\";\n    }\n\n    // 将 signal 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]\n    // HandleSignalFd 是可读事件触发时的回调函数 [2.4.3.1.4]\n    if (auto result = epoll->RegisterHandler(signal_fd, HandleSignalFd); !result) {\n        LOG(FATAL) << result.error();\n    }\n}\n```\n\n函数后半部分所做的工作是：创建信号集，信号集里面包含了信号 `SIGCHLD`，然后新建一个与信号集关联的 signal 文件描述符，最后将文件描述符注册到 epoll。\n\n当 signal 文件描述符的可读事件触发时，就会调用 HandleSignalFd 函数，接下来分析这个函数。\n\n\n\n##### 2.4.3.1.4 回调函数 HandleSignalFd\n\n函数所在文件的路径为 `system/core/init/init.cpp`：\n\n```c++\nstatic void HandleSignalFd() {\n    signalfd_siginfo siginfo;\n\n    // 从 signal 文件描述符中读取结构体 signalfd_siginfo, 每次读取一个\n    ssize_t bytes_read = TEMP_FAILURE_RETRY(read(signal_fd, &siginfo, sizeof(siginfo)));\n\n    if (bytes_read != sizeof(siginfo)) {\n        PLOG(ERROR) << \"Failed to read siginfo from signal_fd\";\n        return;\n    }\n\n    // 根据信号编号执行相应的操作\n    switch (siginfo.ssi_signo) {\n        case SIGCHLD:\n            ReapAnyOutstandingChildren();\n            break;\n        case SIGTERM:\n            HandleSigtermSignal(siginfo);\n            break;\n        default:\n            PLOG(ERROR) << \"signal_fd: received unexpected signal \" << siginfo.ssi_signo;\n            break;\n    }\n}\n```\n\n当目标信号产生并传递给进程时，signal 文件描述符的可读事件就会触发，返回一个或者多个结构体 signalfd_siginfo。而函数 HandleSignalFd 负责从 signal 文件描述符中读出一个结构体 signalfd_siginfo，并根据信号编号执行相应的操作。\n\n在这里，我们关心的信号是 `SIGCHLD`。当此信号产生后，会调用 ReapAnyOutstandingChildren 函数，接着来分析这个函数。\n\n\n\n###### 2.4.3.1.4.1 分析 ReapAnyOutstandingChildren 函数\n\n函数所在文件的路径为 `system/core/init/sigchld_handler.cpp`：\n\n```c++\nvoid ReapAnyOutstandingChildren() {\n    while (ReapOneProcess()) {\n    }\n}\n```\n\n此函数循环调用 ReapOneProcess 函数，只有当函数 ReapOneProcess 返回 false 时，循环才会停止。接着来看 ReapOneProcess 函数做了什么工作。\n\n\n\n###### 2.4.3.1.4.2 分析 ReapOneProcess 函数\n\n<!-- TODO: 分析 service->flags() -->\n\n<!-- TODO: 分析 ServiceList::GetInstance().RemoveService(*service) -->\n\n函数所在文件的路径为 `system/core/init/sigchld_handler.cpp`：\n\n```c++\nstatic bool ReapOneProcess() {\n    siginfo_t siginfo = {};\n\n    // 发起系统调用 waitid, 此系统调用用于获取子进程状态的变更和相关的信息\n    // 由于 init 进程只接收子进程终结的信号, 因此这里获取到的都是已进入僵尸状态的子进程的相关信息, 信息保存在 siginfo 当中\n    if (TEMP_FAILURE_RETRY(waitid(P_ALL, 0, &siginfo, WEXITED | WNOHANG | WNOWAIT)) != 0) {\n        // 失败, 函数返回 false\n        PLOG(ERROR) << \"waitid failed\";\n        return false;\n    }\n\n    // 获取子进程的 pid\n    auto pid = siginfo.si_pid;\n\n    // 子进程的 pid 不存在, 函数返回 false\n    if (pid == 0) return false;\n\n    ...\n\n    std::string name;\n    std::string wait_string;\n    Service* service = nullptr;\n\n    if (PropertyChildReap(pid)) {\n        name = \"Async property child\";\n    } else if (SubcontextChildReap(pid)) {\n        name = \"Subcontext\";\n    } else {\n        // 根据 pid 查询相应的 service\n        service = ServiceList::GetInstance().FindService(pid, &Service::pid);\n\n        if (service) {\n            name = StringPrintf(\"Service '%s' (pid %d)\", service->name().c_str(), pid);\n\n            ...\n\n        } else {\n            name = StringPrintf(\"Untracked pid %d\", pid);\n        }\n    }\n\n    ...\n\n    // 没有找到对应的 service, 函数返回 true\n    if (!service) return true;\n\n    // 调用 service 的 Reap 函数\n    service->Reap(siginfo);\n\n    ...\n\n    return true;\n}\n```\n\n经分析可知，ReapOneProcess 函数的主要工作是：为每个进入终结状态的子进程发起系统调用 waitid，从而避免已进入僵尸状态的子进程一直占据着系统资源。最后，函数会根据子进程 pid 查找是否存在相应的 service，如果 service 存在，还会调用 service 的 Reap 函数。接着来分析 Reap 函数。\n\n\n\n###### 2.4.3.1.4.3 分析 Reap 函数\n\n函数所在文件的路径为 `system/core/init/service.cpp`：\n\n```c++\nvoid Service::Reap(const siginfo_t& siginfo) {\n    if (!(flags_ & SVC_ONESHOT) || (flags_ & SVC_RESTART)) {\n        // 如果服务的标志位同时不带有 SVC_ONESHOT 和 SVC_RESTART, 则直接杀死服务所在的进程组\n        KillProcessGroup(SIGKILL);\n    }\n\n    ...\n\n    // 如果服务的标志位带有 SVC_TEMPORARY, 则直接返回\n    if (flags_ & SVC_TEMPORARY) return;\n\n    // 重置状态\n    pid_ = 0;\n    flags_ &= (~SVC_RUNNING);\n    start_order_ = 0;\n\n    if ((flags_ & SVC_ONESHOT) && !(flags_ & SVC_RESTART) && !(flags_ & SVC_RESET)) {\n        // 将带有 SVC_ONESHOT 的服务设为不可用状态\n        flags_ |= SVC_DISABLED;\n    }\n\n    if (flags_ & (SVC_DISABLED | SVC_RESET))  {\n        // 如果服务的标志位带有 SVC_DISABLED 或者 SVC_RESET, 则使其进入 stopped 状态, 不会自动重启\n        NotifyStateChange(\"stopped\");\n        return;\n    }\n\n    // 带有标志位 SVC_CRITICAL 的服务会被标记为系统关键服务\n    // 如果服务在 4 分钟之内崩溃 4 次以上, 又或者服务崩溃时系统处于未完全启动状态\n    // 则设备会重启并进入 bootloader 或者设置崩溃相关的属性\n    boot_clock::time_point now = boot_clock::now();\n    if (((flags_ & SVC_CRITICAL) || !pre_apexd_) && !(flags_ & SVC_RESTART)) {\n        bool boot_completed = android::base::GetBoolProperty(\"sys.boot_completed\", false);\n        if (now < time_crashed_ + 4min || !boot_completed) {\n            if (++crash_count_ > 4) {\n                if (flags_ & SVC_CRITICAL) {\n                    // Aborts into bootloader\n                    LOG(FATAL) << \"critical process '\" << name_ << \"' exited 4 times \"\n                               << (boot_completed ? \"in 4 minutes\" : \"before boot completed\");\n                } else {\n                    LOG(ERROR) << \"updatable process '\" << name_ << \"' exited 4 times \"\n                               << (boot_completed ? \"in 4 minutes\" : \"before boot completed\");\n                    // Notifies update_verifier and apexd\n                    property_set(\"ro.init.updatable_crashing\", \"1\");\n                }\n            }\n        } else {\n            time_crashed_ = now;\n            crash_count_ = 1;\n        }\n    }\n\n    // 添加标志位 SVC_RESTARTING, init 进程会重启带有此标志位的服务 [2.4.5.2]\n    flags_ &= (~SVC_RESTART);\n    flags_ |= SVC_RESTARTING;\n\n    // 执行当前 service 中所有 onrestart 命令\n    onrestart_.ExecuteAllCommands();\n\n    // 使服务进入 restarting 状态\n    NotifyStateChange(\"restarting\");\n    return;\n}\n```\n\nReap 函数最主要的工作就是重启有需要的服务。注意到，改变服务状态是通过调用 NotifyStateChange 函数实现的，来看看这个函数。\n\n\n\n###### 2.4.3.1.4.4 分析 NotifyStateChange 函数\n\n函数所在文件的路径为 `system/core/init/service.cpp`：\n\n```c++\nvoid Service::NotifyStateChange(const std::string& new_state) const {\n    if ((flags_ & SVC_TEMPORARY) != 0) {\n        // 如果服务的标志位中带有 SVC_TEMPORARY, 则不会使用属性服务来记录它的状态\n        return;\n    }\n\n    // 使用属性服务来记录服务当前的状态\n    std::string prop_name = \"init.svc.\" + name_;\n    property_set(prop_name, new_state);\n\n    ...\n}\n```\n\n通过分析这个函数，可以知道，系统会使用属性服务以 key-value 的形式存储服务当前的状态，其中 key 的取值为 init.svc.[service_name]，value 是服务当前的状态。因此，可以使用 adb，输入命令 `getprop | grep init.svc.`，查看设备上 service 的运行状态，以下是其中的一些输出：\n\n```\n[init.svc.adbd]: [running]\n[init.svc.alarm-hal-1-0]: [running]\n[init.svc.android.thermal-hal]: [running]\n[init.svc.apexd]: [stopped]\n[init.svc.apexd-bootstrap]: [stopped]\n[init.svc.apexd-snapshotde]: [stopped]\n[init.svc.audioserver]: [running]\n[init.svc.wifidisplayhalservice]: [running]\n[init.svc.wpa_supplicant]: [running]\n[init.svc.zygote]: [running]\n[init.svc.zygote_secondary]: [running]\n```\n\n\n\n### 2.4.4 加载启动脚本\n\n<!-- TODO: 分析函数 CreateParser -->\n\n<!-- TODO: .rc 文件的解析过程 -->\n\n<!-- TODO: 属性的变更如何触发脚本中的属性触发器？ -->\n\n<!-- TODO: /system/etc/init -->\n\n<!-- TODO: /odm/etc/init -->\n\n<!-- TODO: /vendor/etc/init -->\n\n调用 LoadBootScripts 函数加载启动脚本，函数所在文件的路径为 `system/core/init/init.cpp`。\n\n```c++\nstatic void LoadBootScripts(ActionManager& action_manager, ServiceList& service_list) {\n    Parser parser = CreateParser(action_manager, service_list);\n\n    std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\");\n    if (bootscript.empty()) {\n        // 加载 init.rc 脚本文件 [2.4.4.1]\n        parser.ParseConfig(\"/init.rc\");\n\n        // 加载 /system/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/system/etc/init\")) {\n            late_import_paths.emplace_back(\"/system/etc/init\");\n        }\n\n        // 加载 /product/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/product/etc/init\")) {\n            late_import_paths.emplace_back(\"/product/etc/init\");\n        }\n\n        // 加载 /product_services/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/product_services/etc/init\")) {\n            late_import_paths.emplace_back(\"/product_services/etc/init\");\n        }\n\n        // 加载 /odm/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/odm/etc/init\")) {\n            late_import_paths.emplace_back(\"/odm/etc/init\");\n        }\n\n        // 加载 /vendor/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/vendor/etc/init\")) {\n            late_import_paths.emplace_back(\"/vendor/etc/init\");\n        }\n    } else {\n        parser.ParseConfig(bootscript);\n    }\n}\n```\n\n一般情况下，此函数会去加载一些指定的脚本，其中：\n\n- `init.rc` 是主要的 .rc 文件。\n- `/system/etc/init/` 包含了核心的系统项目，例如：SurfaceFlinger, MediaService, logcatd。\n- `/vendor/etc/init/` 包含了 SoC 供应商项目，例如：核心 SoC 功能所需的操作或守护进程。\n- `/odm/etc/init/` 包含了设备制造商项目，例如：运动传感器或其他外围设备所需的操作或守护进程。\n\ninit.rc 是最主要脚本文件，接下来将对这个脚本进行分析。\n\n\n\n#### 2.4.4.1 init.rc 脚本\n\n在 Android，后缀为 .rc 的文件由 Android Init Language 编写，[关于 Android Init Language 的详细说明](https://cs.android.com/android/platform/superproject/+/android-security-10.0.0_r56:system/core/init/README.md) 可以在 AOSP 上找到，路径为 `system/core/init/README.md`。\n\n在分析脚本之前，首先来了解这种语言的语法。\n\n\n\n##### 2.4.4.1.1 Android Init Language\n\nAndroid Init Language 由五大类表达式组成：`Actions`，`Commands`，`Services`，`Options`，`Imports`。\n\n其语法规则有：\n\n- 每一行都是一条语句，一条语句由多个 token 组成，token 之间以空格分开。\n- 如果一个 token 包含了空格，可以跟 c 语言类似，使用反斜杠 `\\` 作为转义字符，又或者使用双引号包裹整个 token。\n- 在行的末尾使用反斜杠 `\\`，可以将语句换行。\n- 以符号 `#` 开头的行是注释行。\n- 系统属性的值可以通过语法 `${property.name}` 获取，例如：`import /init.recovery.${ro.hardware}.rc`。\n- 一个文件可以分为多个 section，必须使用 `Actions` 或者 `Services` 来声明一个新的 section。所有的 `Commands` 和 `Options` 都是属于最近声明的那一个 section。如果在一个 section 之前声明了 `Commands` 或者 `Options` ，则声明会被忽略。\n- `Services` 的名称必须是唯一的，如果存在多个重名的 `Services` ，除了第一个以外，其他的都会被忽略，并且会输出错误日志。\n\n接下来列出一些较为重要的表达式。\n\n\n\n###### 2.4.4.1.1.1 Actions\n\n`Actions` 由 一系列 `Commands` 组成，同时 `Triggers` 决定了 `Actions` 的触发时机，其形式为：\n\n```\non <trigger> [&& <trigger>]*\n   <command>\n   <command>\n   <command>\n```\n\n当一个事件触发后，如果此事件能够匹配上 `Actions` 的  `Triggers`，那么 `Actions` 会被添加到待执行队列的尾部。\n\n之后，待执行队列中的 `Actions` 会按照加入顺序出队，并且执行该 `Actions` 中的 `Commands`。\n\n以启动 Zygote 作为示例：\n\n```\non zygote-start && property:ro.crypto.state=unencrypted\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n```\n\n简单分析这个脚本：\n\n这个 `Actions` 拥有两个 `Triggers`，分别是 `zygote-start` 和 `property:ro.crypto.state=unencrypted`，从第二行开始，每一行都是一个 `Command`。\n\n当事件 `zygote-start` 和 `property:ro.crypto.state=unencrypted` 触发后，`Actions` 会被加入到待执行队列。在执行到该 `Actions` 时，会按照 `Commands` 定义的先后顺序，依次执行 `Actions` 中的 `Commands`。\n\n\n\n###### 2.4.4.1.1.2 Triggers\n\n`Triggers` 是字符串，用于匹配某些类型的事件并触发 `Actions` 中的 `Commands`。\n\nTriggers 可以分为两类：\n\n- **Event triggers**\n\n  事件触发器，这类触发器所匹配的事件由命令 `trigger`  触发，又或者通过调用 `QueueEventTrigger()` 函数触发。\n\n- **Property triggers**\n\n  属性触发器，这类触发器所匹配的事件是：属性是否满足某个值，形式为 `property:<key>=<value>`。这里的属性就是之前提到的属性服务管理的属性。\n\n注意，每一个 `Actions` 可以有多个属性触发器，但只能有一个事件触发器。\n\n例如：\n\n`on init && property:a=b`，`on property:a=b && property:c=d` 是合法的。\n\n`on boot && on init` 是不合法的。\n\n\n\n###### 2.4.4.1.1.3 Commands\n\n下面列举一些常见的 `Commands`：\n\n- **trigger <event>**\n\n  触发一个事件。\n\n- **write <path> <content>**\n\n  按 path 打开文件，往文件中写入内容。\n\n- **chown <owner> <group> <path>**\n\n  更改文件所有者和组。\n\n- **mkdir <path> [mode] [owner] [group]**\n\n  在路径上创建一个目录，可以选择使用给定的权限，所有者，用户组。 \n\n  如果未指定权限，所有者，用户组，则新建的目录默认具有权限 755，并由 root 用户和 root 组拥有。\n\n  当指定权限，所有者，用户组时，如果目录已经存在，则权限，所有者，用户组将被更新。\n\n- **start <service>**\n\n  当指定的服务未在运行时，启动该服务。\n\n- **exec_start <service>**\n\n  启动指定的服务，在该命令返回之前暂停处理其他命令。\n\n- **setprop <name> <value>**\n\n  给系统属性赋值，这里的属性是之前提到的属性服务中的属性。\n\n- **symlink <target> <path>**\n\n  在 path 上创建一个连接到 target 的符号链接。\n\n\n\n###### 2.4.4.1.1.4 Services\n\n`Services` 是由 init 进程启动的程序，一般运行在 init 进程的一个子进程，因此 init 进程在启动一个 `Services` 时会通过 fork 的方式生成子进程。\n\n默认情况下，`Services` 退出后会重启。\n\n`Services` 的形式如下：\n\n```\nservice <name> <pathname> [ <argument> ]*\n   <option>\n   <option>\n   ...\n```\n\n以启动 Zygote 64 位进程的脚本作为示例：\n\n```\nservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server\n    class main\n    priority -20\n    user root\n    group root readproc reserved_disk\n    socket zygote stream 660 root system\n    socket usap_pool_primary stream 660 root system\n    onrestart write /sys/android_power/request_state wake\n    onrestart write /sys/power/state on\n    onrestart restart audioserver\n    onrestart restart cameraserver\n    onrestart restart media\n    onrestart restart netd\n    onrestart restart wificond\n    writepid /dev/cpuset/foreground/tasks\n```\n\n简单分析这个脚本：`zygote` 是 `Services` 的名称，`/system/bin/app_process64` 是可执行文件的路径，`-Xzygote /system/bin --zygote --start-system-server` 是启动参数，从第二行开始，每一行都是一个 `Options`。\n\n\n\n###### 2.4.4.1.1.5 Options\n\n`Options` 是 `Services` 的配置项，用于控制 init 进程运行 `Services` 的方式和时间。\n\n 下面列举一些常见的 `Options`：\n\n- **class <name> [ <name>\\* ]**\n\n  指定 `Services` 的类名。当 `Services` 所属类开启 (退出) 时，`Services` 也会开启 (退出) 。默认值为 default。\n\n- **class_start <serviceclass>**\n\n  启动所有未在运行的，类名被指定为 `serviceclass` 的 `Services`。\n\n- **priority <priority>**\n\n  设置 `Services` 进程的优先级。取值范围是 -20 ~ 19。默认值为 0。\n\n- **user <username>**\n\n  设置执行 `Services` 的用户。一般情况下，默认值为 root。\n\n- **group <groupname> [ <groupname>\\* ]**\n\n  设置执行 `Services` 的用户组。一般情况下，默认值为 root。\n\n- **socket <name> <type> <perm> [ <user> [ <group> [ <seclabel> ] ] ]**\n\n  创建一个 unix 域的 socket，命名为 `/dev/socket/<name>`，并将 socket 的文件描述符传递给创建的进程。\n\n- **onrestart**\n\n  当 `Services` 重启时执行一个 `Commands`。\n\n- **oneshot**\n\n  当 `Services` 退出后不再重启。\n\n- **writepid <file> [ <file>\\* ]**\n\n  在进程 fork 之后，将子进程的 pid 写入指定的文件。\n\n\n\n##### 2.4.4.1.2 加载 init.rc 脚本\n\n脚本文件 init.rc 负责系统的初始设置，文件的路径为 `system/core/rootdir/init.rc`。\n\n在了解到脚本的编写语法之后，可以知道脚本的内容都是由  `Actions` 和 `Services` 构成的，而在 init.rc 脚本中绝大部分都是 `Actions`。在 [2.4.4.1.1.2] 中曾经提到，调用 `QueueEventTrigger()` 函数可以触发一个事件，当事件匹配上  `Actions` 的  `Triggers`，就会开始执行该 `Actions`。 接下来回到进程启动的第二阶段，寻找事件的触发点。\n\n\n\n###### 2.4.4.1.2.1 源码中事件的触发点\n\n回到 init 进程启动的第二阶段，对应源代码 `system/core/init/init.cpp` 的 SecondStageMain 函数：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n\n    ...\n\n    ActionManager& am = ActionManager::GetInstance();\n\n    ...\n\n    // 将触发事件 early-init 的操作加入到 ActionManager\n    am.QueueEventTrigger(\"early-init\");\n\n    ...\n\n    // Trigger all the boot actions to get us started.\n    // 将触发事件 init 的操作加入到 ActionManager\n    am.QueueEventTrigger(\"init\");\n\n    ...\n\n    // Don't mount filesystems or start core system services in charger mode.\n    std::string bootmode = GetProperty(\"ro.bootmode\", \"\");\n    if (bootmode == \"charger\") {\n        // 如果当前处于充电模式, 则将触发事件 charger 的操作加入到 ActionManager\n        // 在充电模式下, 不会挂载文件系统和启动核心系统服务\n        am.QueueEventTrigger(\"charger\");\n    } else {\n        // 如果当前处于非充电模式, 则将触发事件 late-init 的操作加入到 ActionManager\n        am.QueueEventTrigger(\"late-init\");\n    }\n\n    ...\n\n    return 0;\n}\n```\n\nActionManager 会按操作加入的顺序逐一执行 [2.4.5.x]，由此可知事件的触发顺序：\n\n- 非充电模式：early-init -> init -> late-init\n- 充电模式：early-init -> init -> charger\n\n由于在充电模式下，系统可能未完全启动，接下来将选取非充电模式下的流程进行分析。\n\n\n\n###### 2.4.4.1.2.2 init.rc 脚本的执行过程\n\n<!-- TODO: trigger boot -->\n\n现在结合事件的触发顺序，分析脚本执行过程中的一些关键点：\n\n```\non early-init\n    ...\n\n    # 以 start 方式启动 ueventd\n    start ueventd\n\n    # 以 exec_start 方式运行 apexd-bootstrap, 在该命令返回之前暂停处理其他命令, 从而保证后续流程中 APEX 的可用性\n    exec_start apexd-bootstrap\n\non init\n    ...\n\n    # 以 start 方式启动基本服务\n    # 启动 servicemanager [2.4.4.1.2.3]\n    start servicemanager\n    start hwservicemanager\n    start vndservicemanager\n\n# 挂载文件和启动核心系统服务\n# 其中 trigger 用于触发一个事件 [2.4.4.1.1.2]\non late-init\n    trigger early-fs\n    trigger fs\n    trigger post-fs\n    trigger late-fs\n    trigger post-fs-data\n    trigger load_persist_props_action\n\n    # 触发事件 zygote-start, 启动 zygote [2.4.4.1.2.4]\n    trigger zygote-start\n\n    trigger firmware_mounts_complete\n    trigger early-boot\n    trigger boot\n```\n\n经过分析，现在已经大致了解脚本的执行过程，接下来分析 servicemanager 和 zygote 的启动。\n\n\n\n###### 2.4.4.1.2.3 启动 servicemanager\n\nservicemanager 启动脚本的路径为 `frameworks/native/cmds/servicemanager/servicemanager.rc`，分析这个脚本：\n\n```\n# servicemanager 是 Services 的名称\n# /system/bin/servicemanager 是可执行文件的路径\nservice servicemanager /system/bin/servicemanager\n    # 指定类名为 core 和 animation\n    # 当 core 或者 animation 开启 (关闭) 时, servicemanager 也将开启 (关闭)\n    class core animation\n\n    # 设置用户为 system\n    user system\n\n    # 设置用户组为 system 和 readproc\n    group system readproc\n\n    # 将其标记为设备的关键服务\n    # 如果此服务在规定时间内不断重启, 则设备会重启并进入 bootloader\n    critical\n\n    # 设置服务重启后执行的操作\n    # 每一个操作都是一个 Commands\n    onrestart restart healthd\n    onrestart restart zygote\n    onrestart restart audioserver\n    onrestart restart media\n    onrestart restart surfaceflinger\n    onrestart restart inputflinger\n    onrestart restart drm\n    onrestart restart cameraserver\n    onrestart restart keystore\n    onrestart restart gatekeeperd\n    onrestart restart thermalservice\n\n    # 在进程执行 fork 操作之后，将子进程的 pid 写入文件 /dev/cpuset/system-background/tasks\n    writepid /dev/cpuset/system-background/tasks\n\n    # 设置服务的关闭行为\n    # shutdown critical 表示此服务在关闭期间不会被杀死, 当关闭超时后才会被杀死\n    shutdown critical\n```\n\n启动 servicemanager 之后，便会进入 `frameworks/native/cmds/servicemanager/service_manager.c` 的 main 函数。\n\n\n\n###### 2.4.4.1.2.4 启动 zygote\n\n在 init.rc 脚本中，事件 `zygote-start` 有 3 个对应的 `Actions`：\n\n```\non zygote-start && property:ro.crypto.state=unencrypted\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n\non zygote-start && property:ro.crypto.state=unsupported\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n\non zygote-start && property:ro.crypto.state=encrypted && property:ro.crypto.type=file\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n```\n\n其中，zygote 通过以下语句导入：\n\n```\nimport /init.${ro.zygote}.rc\n```\n\n此语句会根据属性 `ro.zygote`，导入相应的文件，其中包括：\n\n```\nsystem/core/rootdir/init.zygote32.rc\nsystem/core/rootdir/init.zygote32_64.rc\nsystem/core/rootdir/init.zygote64.rc\nsystem/core/rootdir/init.zygote64_32.rc\n```\n\nzygote 的启动除了依赖事件 `zygote-start` 以外，还需要某些属性满足特定的值。当上面列出的三个 `Actions` 中的其中一个满足条件后，便会启动 zygote。\n\n这里分析启动 Zygote 64 位进程的脚本，脚本文件的路径为 `system/core/rootdir/init.zygote64.rc`：\n\n```\n# zygote 是 Services 的名称\n# /system/bin/app_process64 是可执行文件的路径\n# -Xzygote /system/bin --zygote --start-system-server 是启动参数\nservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server\n    # 指定类名为 main\n    # 当 main 开启 (关闭) 时, zygote 也将开启 (关闭)\n    class main\n\n    # 进程优先级为 -20\n    # 由于优先级的取值范围是 -20 ~ 19, 数值越小, 优先级越高, 因此 zygote 进程拥有最高的优先级\n    priority -20\n\n    # 用户和用户组都是 root\n    user root\n    group root readproc reserved_disk\n\n    # 创建 socket\n    socket zygote stream 660 root system\n    socket usap_pool_primary stream 660 root system\n\n    # 设置服务重启后执行的操作\n    # 每一个操作都是一个 Commands\n    onrestart write /sys/android_power/request_state wake\n    onrestart write /sys/power/state on\n    onrestart restart audioserver\n    onrestart restart cameraserver\n    onrestart restart media\n    onrestart restart netd\n    onrestart restart wificond\n\n    # 在 zygote 进程执行 fork 操作之后，将子进程的 pid 写入文件 /dev/cpuset/foreground/tasks\n    writepid /dev/cpuset/foreground/tasks\n```\n\n启动 zygote 之后，便会进入 `frameworks/base/cmds/app_process/app_main.cpp` 的 main 函数。\n\n\n\n### 2.4.5 进入无限循环状态\n\ninit 进程启动完成之后，进程就会一直存活，而保持存活的方法就是进入无限循环状态。接下来分析这个过程，源代码的路径为 `system/core/init/init.cpp`：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n\n    ...\n\n    while (true) {\n        // 设置等待 epoll 事件的超时时长\n        // 默认情况下会一直处于阻塞状态, 直到有事件发生, 此时 epoll_timeout 取值为 -1\n        auto epoll_timeout = std::optional<std::chrono::milliseconds>{};\n\n        ...\n\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            // am 是一个引用, 指向 ActionManager 实例\n            // 按顺序执行 ActionManager 中的一个命令 [2.4.5.1]\n            am.ExecuteOneCommand();\n        }\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            if (!shutting_down) {\n                // 获取下一次 HandleProcessActions 的时间点 [2.4.5.2]\n                auto next_process_action_time = HandleProcessActions();\n\n                if (next_process_action_time) {\n                    // 计算出 next_process_action_time 与当前时间的差值\n                    epoll_timeout = std::chrono::ceil<std::chrono::milliseconds>(\n                            *next_process_action_time - boot_clock::now());\n\n                    // 如果差值小于 0, 说明需要立即进行下一次的循环\n                    // 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程\n                    if (*epoll_timeout < 0ms) epoll_timeout = 0ms;\n                }\n            }\n\n            // 如果 ActionManager 中仍有待执行的命令, 那么 init 进程不会进入阻塞状态, 并立即再次唤起\n            // 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程\n            if (am.HasMoreCommands()) epoll_timeout = 0ms;\n        }\n\n        // 调用 Wait 函数, 等待事件触发 [2.4.1.3]\n        if (auto result = epoll.Wait(epoll_timeout); !result) {\n            LOG(ERROR) << result.error();\n        }\n    }\n\n    return 0;\n}\n```\n\n经分析可知，init 进程进入循环状态后主要的工作有 3 个：\n\n- 执行 ActionManager 中的命令。\n- 重启服务。\n- 等待 epoll 事件，当事件触发后，调用相应的函数进行处理。结合前面的分析，可知等待的事件有：一个进程通过请求 init 进程向属性服务写入属性，以及 init 进程接收到 `SIGCHLD` 信号。\n\n\n\n#### 2.4.5.1 ActionManager\n\n<!-- TODO: 什么是 Action? -->\n\n<!-- TODO: Action 和脚本中的 Actions 有没有关系 -->\n\n<!-- TODO: 添加和执行过程 -->\n\nActionManager 是 Action 的管理器，它提供了对 Action 的添加、执行、清空等操作。\n\n\n\n##### 2.4.5.1.1 添加 Action\n\n<!-- TODO: 详细分析 Action 的作用 -->\n\n在 init 进程启动的第二阶段中添加了一些 Action，简单看下其中部分 Action 的作用：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n    ...\n\n    // am 是一个引用, 指向 ActionManager 实例\n    ActionManager& am = ActionManager::GetInstance();\n\n    ...\n\n    am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\");\n\n    // 添加 Action: 触发事件 early-init [2.4.4.1.2.1]\n    am.QueueEventTrigger(\"early-init\");\n\n    // 添加 Action: 等待 coldboot 完成\n    am.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\");\n\n    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\");\n    am.QueueBuiltinAction(SetMmapRndBitsAction, \"SetMmapRndBits\");\n    am.QueueBuiltinAction(SetKptrRestrictAction, \"SetKptrRestrict\");\n    Keychords keychords;\n    am.QueueBuiltinAction(\n        [&epoll, &keychords](const BuiltinArguments& args) -> Result<Success> {\n            for (const auto& svc : ServiceList::GetInstance()) {\n                keychords.Register(svc->keycodes());\n            }\n            keychords.Start(&epoll, HandleKeychord);\n            return Success();\n        },\n        \"KeychordInit\");\n    am.QueueBuiltinAction(console_init_action, \"console_init\");\n\n    // 添加 Action: 触发事件 init [2.4.4.1.2.1]\n    am.QueueEventTrigger(\"init\");\n\n    am.QueueBuiltinAction(StartBoringSslSelfTest, \"StartBoringSslSelfTest\");\n    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\");\n\n    // 添加 Action: 为 init 进程初始化 binder\n    am.QueueBuiltinAction(InitBinder, \"InitBinder\");\n\n    std::string bootmode = GetProperty(\"ro.bootmode\", \"\");\n    if (bootmode == \"charger\") {\n        // 在充电模式下, 添加 Action: 触发事件 charger [2.4.4.1.2.1]\n        am.QueueEventTrigger(\"charger\");\n    } else {\n        // 否则, 添加 Action: 触发事件 late-init [2.4.4.1.2.1]\n        am.QueueEventTrigger(\"late-init\");\n    }\n\n    // 添加 Action: 触发当前所有的属性触发器\n    am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\");\n\n    ...\n\n}\n```\n\n此外，在解析脚本或者属性值改变的时候，也会使用 ActionManager 添加 Action。\n\n\n\n#### 2.4.5.2 HandleProcessActions\n\n<!-- ((s->flags() & SVC_RUNNING) && s->timeout_period()) -->\n\n<!-- 详细分析 service 的重启过程 -->\n\n```c++\nstatic std::optional<boot_clock::time_point> HandleProcessActions() {\n    std::optional<boot_clock::time_point> next_process_action_time;\n\n    // 遍历 ServiceList\n    for (const auto& s : ServiceList::GetInstance()) {\n        // 判断服务是否处于运行中状态, 以及是否有超时时长\n        if ((s->flags() & SVC_RUNNING) && s->timeout_period()) {\n            // 计算出服务启动的超时时间\n            auto timeout_time = s->time_started() + *s->timeout_period();\n\n            if (boot_clock::now() > timeout_time) {\n                // 如果当前时间已大于服务启动的超时时间, 说明服务启动已超时\n                s->Timeout();\n            } else {\n                // 更新 next_process_action_time\n                // 此时, next_process_action_time 表示最近的, 需要检查服务是否启动成功的时间点\n                if (!next_process_action_time || timeout_time < *next_process_action_time) {\n                    next_process_action_time = timeout_time;\n                }\n            }\n        }\n\n        // 如果服务不带有标志位 SVC_RESTARTING, 则不需要重启, 继续 for 循环\n        if (!(s->flags() & SVC_RESTARTING)) continue;\n\n        // 计算出服务启动的超时时间\n        auto restart_time = s->time_started() + s->restart_period();\n\n        // 现在服务需要重启, 接下来重启已满足重启条件的服务\n        if (boot_clock::now() > restart_time) {\n            // 如果当前时间已大于服务的重启时间, 那么立即启动服务\n            if (auto result = s->Start(); !result) {\n                LOG(ERROR) << \"Could not restart process '\" << s->name() << \"': \" << result.error();\n            }\n        } else {\n            // 更新 next_process_action_time\n            // 此时, next_process_action_time 表示最近的, 需要对服务进行重启操作的时间点\n            if (!next_process_action_time || restart_time < *next_process_action_time) {\n                next_process_action_time = restart_time;\n            }\n        }\n    }\n    return next_process_action_time;\n}\n```\n\n此函数的工作有：\n\n1. 检查带有标志位 `SVC_RUNNING` 的服务是否超时，如果服务启动超时，则调用 `Timeout` 函数，否则更新下次检查的时间点。\n2. 当服务带有标志位 `SVC_RESTARTING` 时，说明服务需要重启。如果当前时间已大于服务的重启时间，则立即重启服务；否则，更新下次重启的时间点。 \n\n经分析可知，`next_process_action_time` 可能表示下一次的检查服务是否启动超时的时间点，也可能表示下一次为某个服务重启的时间点。\n\n注意到，在之前的分析信号 [2.4.3.1.4.3] 提到过，当 init 收到子进程终结的信号之后，会为有重启需要的服务添加标志位 `SVC_RESTARTING`。那么现在可以知道，在 init 进程进入无限循环状态后，就会处理这些带有标志位 `SVC_RESTARTING` 的服务，重启满足条件的服务。\n\n\n\n# 参考\n\n[Android系统启动-综述](http://gityuan.com/2016/02/01/android-booting/)\n\n[Android系统启动-Init篇](http://gityuan.com/2016/02/05/android-init/)\n\n[epoll(7)](https://man7.org/linux/man-pages/man7/epoll.7.html)\n\n[Signal](https://en.wikipedia.org/wiki/Signal_(IPC))\n\n[signal(7)](https://man7.org/linux/man-pages/man7/signal.7.html)\n\n[wait(2)](https://man7.org/linux/man-pages/man2/wait.2.html)\n\n[signalfd(2)](https://man7.org/linux/man-pages/man2/signalfd.2.html)\n\n","source":"_drafts/exploring-init-process-startup-process.md","raw":"---\ntitle: 分析 init 进程的启动流程\ncategories:\n- [Android]\n---\n\n\n\n> 本文基于源代码：android-security-10.0.0_r56\n\n\n\n# 1. 前言\n\n<!-- TODO: 关于 init 进程更好的概述 -->\n\nAndroid 基于 Linux 内核，在内核启动过程中会创建出 init 进程。\n\ninit 进程是用户空间的第一个进程，进程的 pid = 1。\n\n<!-- more -->\n\n\n\n# 2. 启动流程\n\n<!-- TODO: 总结 -->\n\n\n\n## 2.1 init 进程的入口\n\n<!-- TODO: 为什么是入口？ -->\n\n<!-- TODO: init 就是一个普通的命令行程序, 位置在 /system/core/init？ -->\n\n在 Android 9，init 进程的入口位于 `system/core/init/init.cpp` 中的 main 函数。\n\n在 Android 10 之后，init 进程的入口改到了 `system/core/init/main.cpp` 中的 main 函数。\n\n```c++\nint main(int argc, char** argv) {\n    ...\n\n    if (!strcmp(basename(argv[0]), \"ueventd\")) {\n        return ueventd_main(argc, argv);\n    }\n\n    if (argc > 1) {\n        if (!strcmp(argv[1], \"subcontext\")) {\n            android::base::InitLogging(argv, &android::base::KernelLogger);\n            const BuiltinFunctionMap& function_map = GetBuiltinFunctionMap();\n\n            return SubcontextMain(argc, argv, &function_map);\n        }\n\n        if (!strcmp(argv[1], \"selinux_setup\")) {\n            return SetupSelinux(argv);\n        }\n\n        if (!strcmp(argv[1], \"second_stage\")) {\n            return SecondStageMain(argc, argv);\n        }\n    }\n\n    return FirstStageMain(argc, argv);\n}\n```\n\n首先来了解其中使用到的两个库函数：`basename` 函数和 `strcmp` 函数。\n\n- `basename` 的函数原型为 `char* basename(char* __path)`，可以根据给定的一个路径，返回文件名。例如：传入参数 \"/system/bin/ueventd\"，函数会返回 \"ueventd\"。\n- `strcmp` 的函数原型为 `int strcmp(const char* __lhs, const char* __rhs)`，是一个字符串比较函数，返回值为整数。当两个字符串相等时，函数返回 0。\n\n再来分析 main 函数：函数的主要工作是根据参数 `argc` 和 `argv`，选择对应的执行方式。如果参数未匹配成功，则默认调用 `FirstStageMain` 函数。\n\n\n\n## 2.2 启动的第一阶段\n\n<!-- TODO: mkdir, mknod, tmpfs -->\n\n<!-- TODO: 所挂载的文件系统的用处 -->\n\n<!-- TODO: KernelLogging(/dev/kmsg) -->\n\n<!-- TODO: InstallRebootSignalHandlers -->\n\n调用 `int FirstStageMain(int argc, char** argv)` 进入启动的第一阶段，函数所在文件的路径为 `system/core/init/first_stage_init.cpp`：\n\n```c++\nint FirstStageMain(int argc, char** argv) {\n    ...\n\n    CHECKCALL(clearenv());\n    CHECKCALL(setenv(\"PATH\", _PATH_DEFPATH, 1));\n    // Get the basic filesystem setup we need put together in the initramdisk\n    // on / and then we'll let the rc file figure out the rest.\n    CHECKCALL(mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"));\n    CHECKCALL(mkdir(\"/dev/pts\", 0755));\n    CHECKCALL(mkdir(\"/dev/socket\", 0755));\n    CHECKCALL(mkdir(\"/dev/dm-user\", 0755));\n    CHECKCALL(mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL));\n#define MAKE_STR(x) __STRING(x)\n    CHECKCALL(mount(\"proc\", \"/proc\", \"proc\", 0, \"hidepid=2,gid=\" MAKE_STR(AID_READPROC)));\n#undef MAKE_STR\n\n    // Don't expose the raw commandline to unprivileged processes.\n    // 设置文件权限 [2.2.1]\n    CHECKCALL(chmod(\"/proc/cmdline\", 0440));\n    std::string cmdline;\n    android::base::ReadFileToString(\"/proc/cmdline\", &cmdline);\n    // Don't expose the raw bootconfig to unprivileged processes.\n    chmod(\"/proc/bootconfig\", 0440);\n    std::string bootconfig;\n    android::base::ReadFileToString(\"/proc/bootconfig\", &bootconfig);\n    gid_t groups[] = {AID_READPROC};\n    CHECKCALL(setgroups(arraysize(groups), groups));\n    CHECKCALL(mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL));\n    CHECKCALL(mount(\"selinuxfs\", \"/sys/fs/selinux\", \"selinuxfs\", 0, NULL));\n\n    CHECKCALL(mknod(\"/dev/kmsg\", S_IFCHR | 0600, makedev(1, 11)));\n\n    if constexpr (WORLD_WRITABLE_KMSG) {\n        CHECKCALL(mknod(\"/dev/kmsg_debug\", S_IFCHR | 0622, makedev(1, 11)));\n    }\n\n    CHECKCALL(mknod(\"/dev/random\", S_IFCHR | 0666, makedev(1, 8)));\n    CHECKCALL(mknod(\"/dev/urandom\", S_IFCHR | 0666, makedev(1, 9)));\n\n    // This is needed for log wrapper, which gets called before ueventd runs.\n    CHECKCALL(mknod(\"/dev/ptmx\", S_IFCHR | 0666, makedev(5, 2)));\n    CHECKCALL(mknod(\"/dev/null\", S_IFCHR | 0666, makedev(1, 3)));\n\n    // These below mounts are done in first stage init so that first stage mount can mount\n    // subdirectories of /mnt/{vendor,product}/.  Other mounts, not required by first stage mount,\n    // should be done in rc files.\n    // Mount staging areas for devices managed by vold\n    // See storage config details at http://source.android.com/devices/storage/\n    CHECKCALL(mount(\"tmpfs\", \"/mnt\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=1000\"));\n    // /mnt/vendor is used to mount vendor-specific partitions that can not be\n    // part of the vendor partition, e.g. because they are mounted read-write.\n    CHECKCALL(mkdir(\"/mnt/vendor\", 0755));\n    // /mnt/product is used to mount product-specific partitions that can not be\n    // part of the product partition, e.g. because they are mounted read-write.\n    CHECKCALL(mkdir(\"/mnt/product\", 0755));\n\n    // /debug_ramdisk is used to preserve additional files from the debug ramdisk\n    CHECKCALL(mount(\"tmpfs\", \"/debug_ramdisk\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=0\"));\n\n    // /second_stage_resources is used to preserve files from first to second\n    // stage init\n    CHECKCALL(mount(\"tmpfs\", kSecondStageRes, \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=0\"))\n#undef CHECKCALL\n\n    SetStdioToDevNull(argv);\n    // Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually\n    // talk to the outside world...\n    InitKernelLogging(argv);\n\n    if (!errors.empty()) {\n        for (const auto& [error_string, error_errno] : errors) {\n            LOG(ERROR) << error_string << \" \" << strerror(error_errno);\n        }\n        LOG(FATAL) << \"Init encountered errors starting first stage, aborting\";\n    }\n\n    LOG(INFO) << \"init first stage started!\";\n\n    ...\n\n    // 执行 /system/bin/init\n    // 注意到传入的参数是 selinux_setup, 因此接下来会调用 SetupSelinux 函数进行 SELinux 的初始化 [2.3]\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"selinux_setup\", nullptr};\n    auto fd = open(\"/dev/kmsg\", O_WRONLY | O_CLOEXEC);\n    dup2(fd, STDOUT_FILENO);\n    dup2(fd, STDERR_FILENO);\n    close(fd);\n    execv(path, const_cast<char**>(args));\n\n    // execv() only returns if an error happened, in which case we\n    // panic and never fall through this conditional.\n    PLOG(FATAL) << \"execv(\\\"\" << path << \"\\\") failed\";\n\n    return 1;\n}\n```\n\n此函数主要工作是挂载一些文件系统，然后执行 `/system/bin/init`，重新进入 main 函数，通过传入参数 `\"selinux_setup\"`，进而调用 SetupSelinux 函数，进行 SELinux 的初始化。\n\n\n\n### 2.2.1 设置文件或目录的权限\n\n在 Linux 系统上，`chmod` 命令用于控制用户对文件或者目录的权限，但只有文件所有者和超级用户可以修改文件或目录的权限。\n\n权限分为三类：读，写，执行。\n\n\n\n#### 2.2.1.1 符号表示法\n\n符号表示法用 10 位字符表示权限，其形式为：\n\n```\n-rwxrwxrwx\n```\n\n其中第一个字符表示文件类型，常见的符号有：\n\n- `-`，表示普通文件。\n- `d`，表示目录。\n- `c`，表示字符特殊文件。\n\n剩余的 9 个字符，每 3 个字符分为一组，分别表示文件所有者，用户组，其他用户的权限。\n\n3 个字符组成的字符串，第 1 位控制读权限，第 2 位控制写权限，第 3 位控制执行权限：\n\n- 如果拥有读权限，第 1 位字符为 `r`，否则为 `-`。\n- 如果拥有写权限，第 2 位字符为 `w`，否则为 `-`。\n- 如果拥有执行权限，第 3 位字符为 `x`，否则为 `-`。\n\n示例：`-rwxrw-r--` 表示一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。\n\n\n\n#### 2.2.1.2 数字表示法\n\n可以用 4 位八进制数字表示权限，第 1 位同样表示文件类型，剩余的 3 位数字，分别表示文件所有者，用户组，其他用户的权限。\n\n读，写，执行，这 3 类权限可以使用 3 位二进制数字表示，不同类型的权限单独对应二进制数字中一个位：\n\n|          数值          | 权限 |\n| :--------------------: | :--: |\n| 二进制：100，八进制：4 |  r   |\n| 二进制：010，八进制：2 |  w   |\n| 二进制：001，八进制：1 |  x   |\n| 二进制：000，八进制：0 |  -   |\n\n在各类权限对应的数值之和，可以代表一组特定的权限。由于和的数值范围为 0~7，因此可以通过一个八进制数字表示。示例：\n\n|          数值          | 权限 |\n| :--------------------: | :--: |\n| 二进制：111，八进制：7 | rwx  |\n| 二进制：110，八进制：6 | rw-  |\n| 二进制：101，八进制：5 | r-x  |\n| 二进制：000，八进制：0 | ---  |\n\n因此，用符号表示法表示的权限，同样可以使用数字表示法来表示，示例：\n\n| 符号表示法 | 数字表示法 |                             说明                             |\n| :--------: | :--------: | :----------------------------------------------------------: |\n| -rwxrwxrwx |    0777    | 一个普通文件，文件所有者，用户组，其他用户都有读，写，执行的权限 |\n| -rwxrw-r-- |    0764    | 一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。 |\n\n\n\n#### 2.2.1.3 分析源码中的权限设置\n\n```c++\n// Don't expose the raw commandline to unprivileged processes.\nCHECKCALL(chmod(\"/proc/cmdline\", 0440));\n\n// Don't expose the raw bootconfig to unprivileged processes.\nchmod(\"/proc/bootconfig\", 0440);\n```\n\n在源码中有两处使用到 `chmod` 命令，分别对文件 `/proc/cmdline`，`/proc/bootconfig` 设置了权限 `0440`，表明 root 用户 (文件所有者) 及其用户组也只有文件的读权限。\n\n\n\n## 2.3 初始化 SELinux\n\n<!-- TODO: 分析 SELinux -->\n\n调用 `int SetupSelinux(char** argv)` 进行 SELinux 的初始化，该函数所在文件的路径为 `system/core/init/selinux.cpp`：\n\n```c++\n// This function initializes SELinux then execs init to run in the init SELinux context.\nint SetupSelinux(char** argv) {\n    ...\n\n    // Set up SELinux, loading the SELinux policy.\n    // 初始化 SELinux\n    SelinuxSetupKernelLogging();\n    SelinuxInitialize();\n\n    ...\n\n    // 执行 /system/bin/init\n    // 注意到传入的参数是 second_stage, 因此接下来会调用 SecondStageMain 函数进入启动的第二阶段 [2.4]\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"second_stage\", nullptr};\n    execv(path, const_cast<char**>(args));\n\n    ...\n\n    return 1;\n}\n```\n\n函数首先初始化了 SELinux，然后执行 `/system/bin/init`，重新进入 main 函数，通过传入参数 `\"second_stage\"`，进而调用 SecondStageMain 函数，进入启动的第二阶段。\n\n\n\n## 2.4 启动的第二阶段\n\n<!-- TODO: property_load_boot_defaults -->\n\n<!-- TODO: 在编译的过程中, android 的各种系统参数会被汇总到 build.prop 文件中？ -->\n\n<!-- TODO: SELinux 相关代码的分析 -->\n\n<!-- TODO: keyctl_get_keyring_ID(KEY_SPEC_SESSION_KEYRING, 1) -->\n\n<!-- TODO: InitializeSubcontext() -->\n\n<!-- TODO: ActionManager 和 ServiceList 的作用 -->\n\n调用 `int SecondStageMain(int argc, char** argv)` 进入启动的第二阶段，函数所在文件的路径为 `system/core/init/init.cpp`：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n    ...\n\n    // Set init and its forked children's oom_adj.\n    // 设置 init 进程以及由其 fork 得到的子进程 oom_score_adj 的值\n    // 数值越小, 进程优先级越高\n    if (auto result = WriteFile(\"/proc/1/oom_score_adj\", \"-1000\"); !result) {\n        LOG(ERROR) << \"Unable to write -1000 to /proc/1/oom_score_adj: \" << result.error();\n    }\n\n    ...\n\n    // 初始化属性服务 [2.4.2.1]\n    property_init();\n\n    ...\n\n    // 初始化 epoll [2.4.1.1]\n    Epoll epoll;\n    if (auto result = epoll.Open(); !result) {\n        PLOG(FATAL) << result.error();\n    }\n\n    // 使用 epoll 对 init 子进程的信号进行监听 [2.4.3.1.3]\n    // 初始化子进程退出的信号处理函数\n    InstallSignalFdHandler(&epoll);\n\n    ...\n\n    // 开启属性服务 [2.4.2.2]\n    StartPropertyService(&epoll);\n\n    ...\n\n    ActionManager& am = ActionManager::GetInstance();\n    ServiceList& sm = ServiceList::GetInstance();\n\n    // 加载启动脚本 [2.4.4]\n    LoadBootScripts(am, sm);\n\n    ...\n\n    // 添加 Action [2.4.5.1]\n    am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\");\n    am.QueueEventTrigger(\"early-init\");\n    am.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\");\n    ...\n    am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\");\n\n    // 进入无限循环状态 [2.4.5]\n    while (true) {\n        auto epoll_timeout = std::optional<std::chrono::milliseconds>{};\n\n        if (do_shutdown && !shutting_down) {\n            do_shutdown = false;\n            if (HandlePowerctlMessage(shutdown_command)) {\n                shutting_down = true;\n            }\n        }\n\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            am.ExecuteOneCommand();\n        }\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            if (!shutting_down) {\n                auto next_process_action_time = HandleProcessActions();\n\n                if (next_process_action_time) {\n                    epoll_timeout = std::chrono::ceil<std::chrono::milliseconds>(\n                            *next_process_action_time - boot_clock::now());\n                    if (*epoll_timeout < 0ms) epoll_timeout = 0ms;\n                }\n            }\n\n            if (am.HasMoreCommands()) epoll_timeout = 0ms;\n        }\n\n        if (auto result = epoll.Wait(epoll_timeout); !result) {\n            LOG(ERROR) << result.error();\n        }\n    }\n\n    return 0;\n}\n```\n\n第二阶段的工作可以大致分为 5 个部分：\n\n- epoll\n\n- 属性服务\n\n- 信号\n\n- 加载启动脚本\n\n- 进入无限循环状态\n\n接下来将分别对这 5 个部分的工作进行分析。\n\n\n\n### 2.4.1 epoll\n\nepoll 是 Linux 提供的 I/O 事件通知机制。epoll 可以监听大量的文件描述符，检查其中某一个文件描述符是否进入就绪状态。\n\n\n\n#### 2.4.1.1 初始化\n\n在 init 进程中，epoll 通过以下代码初始化：\n\n```c++\nEpoll epoll;\nif (auto result = epoll.Open(); !result) {\n    PLOG(FATAL) << result.error();\n}\n```\n\n可以知道，epoll 实例是通过调用 Open 函数创建的，函数所在文件的路径为 `system/core/init/epoll.cpp`，来分析这个函数：\n\n```c++\nResult<Success> Epoll::Open() {\n    if (epoll_fd_ >= 0) return Success();\n\n    // 关键点\n    epoll_fd_.reset(epoll_create1(EPOLL_CLOEXEC));\n\n    if (epoll_fd_ == -1) {\n        return ErrnoError() << \"epoll_create1 failed\";\n    }\n    return Success();\n}\n```\n\n此函数的关键点在于调用 `epoll_create1`。`epoll_create1` 是一个系统调用，其新建了一个 epoll 实例并返回该实例文件描述符。\n\n\n\n#### 2.4.1.2 使用 epoll 监听文件描述符\n\n要使用 epoll 监听文件描述符，需要调用 RegisterHandler 函数，将文件描述符注册到 epoll。\n\n函数所在文件的路径为 `system/core/init/epoll.cpp`，此函数的关键点在于系统调用 epoll_ctl：\n\n```c++\nResult<Success> Epoll::RegisterHandler(int fd, std::function<void()> handler, uint32_t events) {\n    ...\n\n    // 关键点\n    if (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &ev) == -1) {\n\n        ...\n\n        return result;\n    }\n    return Success();\n}\n```\n\n首先来看下 epoll_ctl 这个系统调用。\n\n\n\n##### 2.4.1.2.1 系统调用 epoll_ctl\n\n**epoll_ctl** 是一个系统调用，函数原型为 `int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)`，用于对指定的文件描述符 fd 进行添加、修改或者删除操作。\n\n\n\n###### 2.4.1.2.1.1 参数\n\n首先来理解 epoll_ctl 的参数：\n\n- **epfd** 是 epoll 实例的文件描述符。\n\n- **op** 表示要执行的操作，有三种取值：\n\n  - **EPOLL_CTL_ADD**\n\n    添加指定的文件描述符到 epoll 的监控列表。\n\n  - **EPOLL_CTL_MOD**\n\n    修改 epoll 的监控列表中指定的文件描述符。\n\n  - **EPOLL_CTL_DEL**\n\n    从 epoll 的监控列表中删除指定的文件描述符。\n\n- **fd** 表示指定的文件描述符。\n\n- **event** 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，其定义如下：\n\n  ```c++\n  struct epoll_event {\n     uint32_t     events;      /* Epoll events */\n     epoll_data_t data;        /* User data variable */\n  };\n  ```\n\n  结构体成员 `events` 用于表示要监听的事件，可以由零个或者多个事件类型组成，下面列出部分常见的事件类型：\n\n  - \u0015\u0015**EPOLLIN**\n    表示关联的文件描述符可用于读操作。\n\n  - **EPOLLOUT**\n    表示关联的文件描述符可用于写操作。\n\n  - **EPOLLPRI**\n    表示关联的文件描述符出现异常情况。\n\n  - **EPOLLERR**\n    表示关联的文件描述符出现错误。\n\n  - **EPOLLHUP**\n    表示关联的文件描述符被挂断。\n\n  - **EPOLLONESHOT**\n    表示只监听文件描述符的一次事件。当事件触发之后，epoll 就会禁用此文件描述符。\n    如果想要继续监听该文件描述符的事件，需要再次调用 epoll_ctl，并执行 EPOLL_CTL_MOD 操作。\n\n  结构体成员 `data` 的作用是将其数据交给内核保存，当文件描述符就绪后，内核会返回保存的数据 [2.4.1.3]。`epoll_data_t` 是一个共用体，其定义如下：\n\n  ```c++\n  typedef union epoll_data {\n     void        *ptr;\n     int          fd;\n     uint32_t     u32;\n     uint64_t     u64;\n  } epoll_data_t;\n  ```\n\n\n\n###### 2.4.1.2.1.2 返回值\n\n最后来了解 epoll_ctl 的返回值：\n\n- 当操作成功时，返回值为 0。\n\n- 当发生错误时，返回值为 -1。\n\n\n\n##### 2.4.1.2.2 分析 RegisterHandler 函数\n\n在了解过系统调用 epoll_ctl 以后，现在开始分析 RegisterHandler 函数。首先来看函数在头文件中的声明，头文件的路径为 `system/core/init/epoll.h`：\n\n```c++\nclass Epoll {\n  public:\n    Result<Success> RegisterHandler(int fd, std::function<void()> handler,\n                                    uint32_t events = EPOLLIN);\n};\n```\n\n由函数原型可知，函数的第三个参数 `events` 有默认值 `EPOLLIN`，表示监听文件描述符的读操作是否可用。\n\n接下来分析 RegisterHandler 函数：\n\n```c++\nResult<Success> Epoll::RegisterHandler(int fd, std::function<void()> handler, uint32_t events) {\n    ...\n\n    // handler 是事件触发时的回调函数\n    auto [it, inserted] = epoll_handlers_.emplace(fd, std::move(handler));\n\n    ...\n\n    epoll_event ev;\n\n    // 设置要监听的事件类型\n    // 由于 events 有默认值 EPOLLIN, 因此默认监听的事件类型是读操作是否可用\n    ev.events = events;\n  \n    // 设置回调函数, 回调函数会在事件触发后被调用 [2.4.1.3.2]\n    ev.data.ptr = reinterpret_cast<void*>(&it->second);\n\n    // 发起 epoll_ctl 系统调用\n    // 注意到第二个参数传入的是 EPOLL_CTL_ADD, 因此对指定文件描述符执行的是添加操作\n    if (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &ev) == -1) {\n        Result<Success> result = ErrnoError() << \"epoll_ctl failed to add fd\";\n        epoll_handlers_.erase(fd);\n        return result;\n    }\n    return Success();\n}\n```\n\n经过分析，可以知道函数的主要工作是：设置文件描述符需要监听的事件类型 `events` 以及事件触发时的回调函数 `handler`，最后发起 `epoll_ctl` 系统调用，将文件描述符添加到 epoll 监控列表。\n\n\n\n#### 2.4.1.3 等待事件触发\n\n经过 epoll 的初始化以及将文件描述符注册到 epoll 之后，接下来就需要等待事件触发，然后处理事件。\n\n在 init 进程启动的第二阶段，最后一个步骤就是进入死循环，不断地等待事件触发。接下来看下这段逻辑：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n    ...\n\n    while (true) {\n        ...\n\n        // 关键点\n        if (auto result = epoll.Wait(epoll_timeout); !result) {\n            LOG(ERROR) << result.error();\n        }\n    }\n\n    return 0;\n}\n```\n\n这段逻辑的关键点在于 Wait 函数，接下来分析这个函数。\n\n\n\n##### 2.4.1.3.1 系统调用 epoll_wait\n\n在分析 Wait 函数之前，首先要了解系统调用 epoll_wait，这个系统调用是 Wait 函数的关键点。\n\n**epoll_wait** 是一个系统调用，函数原型为 `int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)`，用于等待 epoll 上的事件。\n\n调用 epoll_wait 便会进入阻塞状态，直至满足以下任一条件，调用才会返回：\n\n- 监听的文件描述符传递一个事件；\n- 调用被信号处理程序中断；\n- 等待超出超时时长。\n\n\n\n###### 2.4.1.3.1.1 参数\n\n首先来理解 epoll_wait 的参数：\n\n- **epfd** 是 epoll 实例的文件描述符。\n\n- **events** 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，在 [2.4.1.2.1] 一节已经详细介绍过。\n\n  当事件触发后，调用就会返回，此时可以从 events 中得到已触发事件的集合。集合中每一个事件结构体 epoll_event 的 data 字段和调用 epoll_ctl 为相应的文件描述符设置的 data 字段是相同的。意味着，当事件触发后，之前调用 epoll_ctl 给指定文件描述符设置的 event.data 会通过这个参数返回给 epoll_wait 的调用者。\n\n- **maxevents** 表示在一次调用中返回事件的最大数量。因此，从参数 events 中得到的事件数量不会大于 maxevents。\n\n- **timeout** 是此次调用的超时时长。当 timeout = -1 时，调用将会一直阻塞，直到有事件发生；当 timeout = 0 时，调用会立即返回，即使当前没有事件发生。\n\n\n\n###### 2.4.1.3.1.2 返回值\n\n最后来了解 epoll_wait 的返回值：\n\n- 当调用成功时，返回值为已就绪的文件描述符的数量，此时可以对这些文件描述符进行 I/O 操作。\n\n  需要注意的是，如果该调用是因为超出等待时长而返回的，则返回值为 0，表明没有已就绪的文件描述符。\n\n- 当调用失败时，返回值为 -1，并返回错误信息。\n\n\n\n##### 2.4.1.3.2 分析 Wait 函数\n\n在了解过系统调用 epoll_wait 以后，就可以开始分析 Wait 函数，函数所在文件的路径为 `system/core/init/epoll.cpp`：\n\n```c++\nResult<Success> Epoll::Wait(std::optional<std::chrono::milliseconds> timeout) {\n    // 超时时长默认值为 -1\n    int timeout_ms = -1;\n\n    if (timeout && timeout->count() < INT_MAX) {\n        // 当参数 timeout 满足不等于 0 和数值没有溢出时, 更新超时时长\n        timeout_ms = timeout->count();\n    }\n\n    epoll_event ev;\n\n    // 发起 epoll_wait 系统调用\n    // 注意到第三个参数传入的是 1, 表明每次调用最多返回 1 个事件\n    auto nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd_, &ev, 1, timeout_ms));\n\n    if (nr == -1) {\n        // 调用返回 -1, 表明此次调用失败\n        return ErrnoError() << \"epoll_wait failed\";\n    } else if (nr == 1) {\n        // 调用返回 1, 表明此次调用成功, 有 1 个事件触发\n        // ev.data.ptr 是之前调用 epoll_ctl 给指定文件描述符设置的回调函数, 因此事件最后交给回调函数进行处理\n        std::invoke(*reinterpret_cast<std::function<void()>*>(ev.data.ptr));\n    }\n    return Success();\n}\n```\n\n此函数设置了超时时长，然后发起 `epoll_wait` 系统调用，等待事件触发。当 `epoll_wait` 成功返回时，会从返回的数据里面取出之前通过 epoll_ctl 设置的回调函数，将事件交由回调函数处理。\n\n\n\n### 2.4.2 属性服务\n\n属性服务是 Android 提供的一个用于存取系统属性的服务，属性以 key-value 的形式存储在一块共享内存，所有进程都可以通过这个服务获取和设置属性。\n\n使用 adb，输入命令 `getprop`，可以查看一台设备上的属性，下面列举其中的一些输出：\n\n```\n[ro.product.brand]: [Redmi]\n[ro.product.manufacturer]: [Xiaomi]\n[ro.product.marketname]: [Redmi K30S Ultra]\n[ro.product.model]: [M2007J3SC]\n[ro.product.name]: [apollo]\n\n[ro.product.cpu.abi]: [arm64-v8a]\n[ro.product.cpu.abilist]: [arm64-v8a,armeabi-v7a,armeabi]\n[ro.product.cpu.abilist32]: [armeabi-v7a,armeabi]\n[ro.product.cpu.abilist64]: [arm64-v8a]\n\n[dalvik.vm.heapsize]: [512m]\n[dalvik.vm.heapstartsize]: [8m]\n```\n\n通过列举出的数据，可以看出属性里面包含了很多重要的信息：机型信息，CPU 架构，虚拟机分配的内存大小等等。\n\n在 Java 代码中，可以调用 `SystemProperties.get(String, String)` 方法获取系统属性。例如，在 ActivityManager 中就有这样的代码：\n\n```java\nstatic public int staticGetLargeMemoryClass() {\n    // 通过获取系统属性 dalvik.vm.heapsize, 得出应用可用堆内存的最大值\n    String vmHeapSize = SystemProperties.get(\"dalvik.vm.heapsize\", \"16m\");\n\n    return Integer.parseInt(vmHeapSize.substring(0, vmHeapSize.length() - 1));\n}\n```\n\n类似地，调用 `SystemProperties.set(String, String)` 方法可以设置系统属性。例如，在 ActivityManagerService 中就有这样的代码：\n\n```java\nfinal void finishBooting() {\n    ...\n\n    synchronized (this) {\n\n        ...\n\n        // Tell anyone interested that we are done booting!\n        // 通过设置属性 sys.boot_completed = 1, 标记系统已经启动完成\n        SystemProperties.set(\"sys.boot_completed\", \"1\");\n\n        ...\n    }\n\n    ...\n}\n```\n\n\n\n#### 2.4.2.1 初始化\n\n<!-- TODO: 如何创建内存区域？ -->\n\n<!-- TODO: 进程是怎样获取共享内存中的属性？ -->\n\n<!-- TODO: 进程为什么不能直接设置共享内存中的属性？ -->\n\n<!-- TODO: CreateSerializedPropertyInfo() -->\n\n<!-- TODO: property_info_area.LoadDefaultPath() -->\n\n属性服务初始化时，调用的是 property_init 函数，文件路径为 `system/core/init/property_service.cpp`。\n\n```c++\nvoid property_init() {\n    mkdir(\"/dev/__properties__\", S_IRWXU | S_IXGRP | S_IXOTH);\n    CreateSerializedPropertyInfo();\n\n    // 创建内存区域\n    if (__system_property_area_init()) {\n        LOG(FATAL) << \"Failed to initialize property area\";\n    }\n\n    if (!property_info_area.LoadDefaultPath()) {\n        LOG(FATAL) << \"Failed to load serialized property info file\";\n    }\n}\n```\n\n函数最主要的工作是通过调用 `__system_property_area_init` 函数，创建用于存储属性的内存区域。\n\n\n\n#### 2.4.2.2 启动\n\n<!-- TODO: socket 的创建过程 -->\n\n<!-- TODO: listen(property_set_fd, 8) -->\n\n<!-- TODO: 一个进程是怎样向 init 进程发起属性设置的请求？ -->\n\n属性服务启动时，调用的是 StartPropertyService 函数，文件路径为 `system/core/init/property_service.cpp`：\n\n```c++\nvoid StartPropertyService(Epoll* epoll) {\n\n    ...\n\n    // 创建 socket 并返回其文件描述符, 其中 PROP_SERVICE_NAME = \"property_service\"\n    property_set_fd = CreateSocket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,\n                                   false, 0666, 0, 0, nullptr);\n    if (property_set_fd == -1) {\n        PLOG(FATAL) << \"start_property_service socket creation failed\";\n    }\n\n    listen(property_set_fd, 8);\n\n    // 将 socket 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]\n    // handle_property_set_fd 是可读事件触发时的回调函数 [2.4.2.3]\n    if (auto result = epoll->RegisterHandler(property_set_fd, handle_property_set_fd); !result) {\n        PLOG(FATAL) << result.error();\n    }\n}\n```\n\n此函数首先创建名称为 property_service 的 socket，然后将 socket 文件描述符注册到 epoll，监听其可读事件。\n\n当可读事件触发时，会进入回调函数 `handle_property_set_fd`，接着来分析这个回调函数。\n\n\n\n#### 2.4.2.3 回调函数 handle_property_set_fd\n\n<!-- TODO: ucred cr; socklen_t cr_size = sizeof(cr); -->\n\n<!-- TODO: 设置属性的具体实现 -->\n\n<!-- TODO: 除了通过向 init 进程发出请求设置属性以外, 在其他地方是否也有属性的设置？ -->\n\n<!-- TODO: 属性的同步问题 -->\n\n函数所在文件的路径为 `system/core/init/property_service.cpp`：\n\n```c++\nstatic void handle_property_set_fd() {\n    // 2000ms\n    static constexpr uint32_t kDefaultSocketTimeout = 2000; /* ms */\n\n    ...\n\n    SocketConnection socket(s, cr);\n\n    // 设置 2000ms 的超时时长\n    uint32_t timeout_ms = kDefaultSocketTimeout;\n\n    uint32_t cmd = 0;\n    if (!socket.RecvUint32(&cmd, &timeout_ms)) {\n        PLOG(ERROR) << \"sys_prop: error while reading command from the socket\";\n        socket.SendUint32(PROP_ERROR_READ_CMD);\n        return;\n    }\n\n    switch (cmd) {\n    // 处理 PROP_MSG_SETPROP 命令\n    case PROP_MSG_SETPROP: {\n        // PROP_NAME_MAX = 32\n        char prop_name[PROP_NAME_MAX];\n        char prop_value[PROP_VALUE_MAX];\n\n        // 接收属性名和属性值, 分别存储于字符数组 prop_name 和 prop_value 中\n        if (!socket.RecvChars(prop_name, PROP_NAME_MAX, &timeout_ms) ||\n            !socket.RecvChars(prop_value, PROP_VALUE_MAX, &timeout_ms)) {\n          PLOG(ERROR) << \"sys_prop(PROP_MSG_SETPROP): error while reading name/value from the socket\";\n          return;\n        }\n\n        // 将字符数组中最后的一个元素设置为 0\n        prop_name[PROP_NAME_MAX-1] = 0;\n        prop_value[PROP_VALUE_MAX-1] = 0;\n\n        const auto& cr = socket.cred();\n        std::string error;\n\n        // 设置属性\n        uint32_t result =\n            HandlePropertySet(prop_name, prop_value, socket.source_context(), cr, &error);\n\n        if (result != PROP_SUCCESS) {\n            LOG(ERROR) << \"Unable to set property '\" << prop_name << \"' to '\" << prop_value\n                       << \"' from uid:\" << cr.uid << \" gid:\" << cr.gid << \" pid:\" << cr.pid << \": \"\n                       << error;\n        }\n\n        break;\n      }\n\n    // 处理 PROP_MSG_SETPROP2 命令\n    case PROP_MSG_SETPROP2: {\n        std::string name;\n        std::string value;\n\n        // 接收字符串类型的属性名和属性值\n        if (!socket.RecvString(&name, &timeout_ms) ||\n            !socket.RecvString(&value, &timeout_ms)) {\n          PLOG(ERROR) << \"sys_prop(PROP_MSG_SETPROP2): error while reading name/value from the socket\";\n          socket.SendUint32(PROP_ERROR_READ_DATA);\n          return;\n        }\n\n        const auto& cr = socket.cred();\n        std::string error;\n\n        // 设置属性\n        uint32_t result = HandlePropertySet(name, value, socket.source_context(), cr, &error);\n\n        if (result != PROP_SUCCESS) {\n            LOG(ERROR) << \"Unable to set property '\" << name << \"' to '\" << value\n                       << \"' from uid:\" << cr.uid << \" gid:\" << cr.gid << \" pid:\" << cr.pid << \": \"\n                       << error;\n        }\n        socket.SendUint32(result);\n        break;\n      }\n\n    default:\n        LOG(ERROR) << \"sys_prop: invalid command \" << cmd;\n        socket.SendUint32(PROP_ERROR_INVALID_CMD);\n        break;\n    }\n}\n```\n\n函数初始化了 socket 接收事件的超时时长，然后对接收到的 `cmd` 做相应的操作：\n\n- 对于 `PROP_MSG_SETPROP` 命令，使用两个长度为 `PROP_NAME_MAX` 的字符数组保存接收到的属性名和属性值。值得注意的是，最后会将字符数组中最后的一个元素设为 0，因此接收的属性名和属性值的最大长度不应超过 `PROP_NAME_MAX - 1` 。\n- 对于 `PROP_MSG_SETPROP2` 命令，使用两个 `std::string` 保存接收到的属性名和属性值。\n\n最后，不论是 `PROP_MSG_SETPROP` 命令还是 `PROP_MSG_SETPROP2` 命令，都会调用 `HandlePropertySet` 函数来设置属性。\n\n\n\n### 2.4.3 信号\n\n**信号 (Signals)** 属于 IPC 的一种方式，用于向一个进程或者进程中的特定线程发送事件通知。\n\n信号是一个**异步的**通信机制，一个进程可以不需要等待信号的到达。在信号未产生时，进程会正常执行；当信号产生后，系统可以中断目标进程的任何非原子操作，此时进程的正常执行流程会被中断，进而对信号进行处理。\n\n\n\n#### 2.4.3.1 处理信号\n\n在 Linux，一个子进程终结后，内核依然会为其维护关于此进程的最小信息集 (PID、终结状态、资源使用信息)，以便父进程获取有关子进程的信息。如果父进程没有为该子进程发起 wait、waitpid 或者 waitid 系统调用，那么子进程的信息就会一直占据着内核进程表的空间。在这种情况下，这个子进程就成为了一个**僵尸进程 (Zombie process)**。\n\n一般情况下，对于一个僵尸进程，如果其父进程终结了，那么 init 进程就会自动成为僵尸进程的父进程。此时，为了避免僵尸进程一直占据着系统资源，init 进程需要为僵尸进程释放占据的空间。\n\n而且，在加载启动脚本 [2.4.4] 这一步骤中，init 进程会 fork 得到一些子进程，例如：servicemanager 进程、zygote 进程。这些子进程对 Android 而言非常重要，在这些进程退出后，init 进程需要有相应的动作将其重启。\n\n于是，为了管理这些子进程，init 进程需要接收子进程终结的信号并进行相应的处理。\n\n在 Android，信号处理基于 Linux 的信号机制。\n\n\n\n##### 2.4.3.1.1 信号的处理方式\n\n<!-- 更正: 注册信号处理函数 -->\n\n信号的处理方式有以下三种：\n\n- \u0015\u0015**忽略该信号**\n- **按信号的默认行为处理该信号**\n- **使用自定义的信号处理函数来处理该信号**\n\ninit 进程使用的是第三种处理方式：使用自定义的信号处理函数来处理该信号。进程注册了一个信号处理函数，当目标信号产生时，信号会被捕获，并调用注册的函数进行处理。\n\n接下来分析这个过程。\n\n\n\n##### 2.4.3.1.2 系统调用 sigaction\n\n在分析 init 进程注册函数的过程之前，首先来了解系统调用 sigaction，这个系统调用是此过程的一个关键点。\n\n**sigaction** 是一个系统调用，函数原型为 `int sigaction(int signum, const struct sigaction *restrict act, struct sigaction *restrict oldact)`，用于更改进程在收到指定信号后的行为。\n\n\n\n###### 2.4.3.1.2.1 参数\n\n首先来理解 sigaction 的参数：\n\n- **signum** 是指定信号的编号。\n\n  同一个信号在不同的架构上可能有不同的编号。在 Android，ARM 架构的信号编号定义在 `bionic/libc/kernel/uapi/asm-arm/asm/signal.h` 文件上。\n\n- **act** 是一个 sigaction 类型的指针，而 sigaction 是一个结构体，其定义如下：\n\n  ```c++\n  struct sigaction {\n     void     (*sa_handler)(int);\n     void     (*sa_sigaction)(int, siginfo_t *, void *);\n     sigset_t   sa_mask;\n     int        sa_flags;\n     void     (*sa_restorer)(void);\n  };\n  ```\n\n  关注结构体中两个较为重要的成员 `sa_handler` 和 `sa_flags`。\n\n  成员 `sa_handler` 用于指定信号产生时的行为，可以是以下这些值之一：\n\n  - **SIG_DFL**\n\n    表示执行该信号的默认行为。\n\n  - **SIG_IGN**\n\n    表示忽略该信号。\n\n  - **一个指向信号处理函数的指针**\n\n    信号编号 signum 将作为函数的唯一参数传入。当目标信号产生时，会自动调用此函数进行处理。\n\n  成员 `sa_flags` 是标志位，可以由零个或者多个标志组成。下面列出其中的一些标志：\n\n  - **SA_NOCLDSTOP**\n\n    只有当 signum = SIGCHLD 时才有意义。表示进程不接收子进程停止或者恢复时产生的信号，只接收子进程终结的信号。\n\n  - **SA_RESETHAND**\n\n    当信号已经由信号处理函数处理过后，将信号恢复为使用默认行为进行处理。\n\n  - **SA_SIGINFO**\n\n    不再通过结构体成员 sa_handler 设置信号处理函数，而是使用成员 sa_sigaction。此时，函数的入参有三个。\n\n- **oldact** 同样是一个 sigaction 类型的指针，用于保存上一个 sigaction 调用所传入的参数 act，可以为空。\n\n\n\n###### 2.4.3.1.2.2 返回值\n\n最后来了解 sigaction 的返回值：\n\n- 当操作成功时，返回值为 0。\n\n- 当发生错误时，返回值为 -1。\n\n\n\n##### 2.4.3.1.3 init 进程注册信号处理函数\n\n在了解过系统调用 sigaction 以后，现在可以开始分析 init 进程注册信号处理函数的过程。\n\n\n\n###### 2.4.3.1.3.1 发起系统调用 sigaction\n\ninit 进程通过调用 InstallSignalFdHandler 函数实现注册信号处理函数，函数所在文件的路径为 `system/core/init/init.cpp`，首先来关注函数前半部分所做的工作：\n\n```c++\nstatic void InstallSignalFdHandler(Epoll* epoll) {\n    // 构建结构体 sigaction\n    // 成员 sa_handler 用于指定信号产生时的行为, 令 sa_handler = SIG_DFL 表明当信号产生时按默认行为对信号进行处理\n    // 成员 sa_flags 是标志位, 令 sa_flags = SA_NOCLDSTOP 表明 init 进程不接收子进程被中断或者被中断后恢复时产生的信号, 只接收子进程终结的信号\n    const struct sigaction act { .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDSTOP };\n\n    // sigaction 是一个系统调用, 用于更改进程在收到指定的信号时所执行的操作 [2.4.3.1.2]\n    // 注意到第一个参数传入的是 SIGCHLD, 表明目标信号是 SIGCHLD, 当子进程终结, 被中断, 或者被中断后恢复时, 就会产生此信号\n    sigaction(SIGCHLD, &act, nullptr);\n\n    ...\n\n}\n```\n\n函数前半部分所做的工作是：发起系统调用 sigaction，针对子进程产生的 `SIGCHLD` 信号，当进程在收到信号时，按默认行为对信号进行处理，而 `SIGCHLD` 信号的默认行为就是忽略该信号。\n\n值得注意的是，当子进程终结、被中断或者被中断后恢复时，都会产生 `SIGCHLD` 信号，而添加标志位 `SA_NOCLDSTOP` 可以使得 init 进程只接收子进程终结的信号。\n\n显然，在函数前半部分所做的工作中，并没有实现按自定义行为对信号进行处理。事实上，init 进程是通过监听 signal 文件描述符来实现按自定义行为来处理信号的。接下来分析 InstallSignalFdHandler 函数后半部分所做的工作。\n\n\n\n###### 2.4.3.1.3.2 监听 signal 文件描述符\n\n之前提到，信号是一个异步的通信机制。进程可以注册一个信号处理函数，接着就能继续进行其他的工作，只有当目标信号发送到进程时，才回调处理函数进行处理，这里就体现出异步的性质。\n\n除了异步的方式以外，进程还可以通过同步的方式接收信号。Linux 提供了系统调用 signalfd，用于创建一个接收指定信号的文件描述符。对文件描述符执行读操作会进入阻塞状态，直到目标信号产生并传递给进程。\n\ninit 进程就是通过这种方式来同步接收信号的，接下来分析这个过程：\n\n```c++\nstatic void InstallSignalFdHandler(Epoll* epoll) {\n\n    ...\n\n    // mask 是一个信号集, 用于指定想要接收的信号\n    // 在这里, 目标信号就是 SIGCHLD\n    sigset_t mask;\n    sigemptyset(&mask);\n    sigaddset(&mask, SIGCHLD);\n\n    ...\n\n    // 获取 signal 文件描述符\n    // 注意到, 在发起系统调用 signalfd 时, 传入的第一个参数是 -1, 则调用会创建一个新的文件描述符\n    signal_fd = signalfd(-1, &mask, SFD_CLOEXEC);\n\n    if (signal_fd == -1) {\n        PLOG(FATAL) << \"failed to create signalfd\";\n    }\n\n    // 将 signal 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]\n    // HandleSignalFd 是可读事件触发时的回调函数 [2.4.3.1.4]\n    if (auto result = epoll->RegisterHandler(signal_fd, HandleSignalFd); !result) {\n        LOG(FATAL) << result.error();\n    }\n}\n```\n\n函数后半部分所做的工作是：创建信号集，信号集里面包含了信号 `SIGCHLD`，然后新建一个与信号集关联的 signal 文件描述符，最后将文件描述符注册到 epoll。\n\n当 signal 文件描述符的可读事件触发时，就会调用 HandleSignalFd 函数，接下来分析这个函数。\n\n\n\n##### 2.4.3.1.4 回调函数 HandleSignalFd\n\n函数所在文件的路径为 `system/core/init/init.cpp`：\n\n```c++\nstatic void HandleSignalFd() {\n    signalfd_siginfo siginfo;\n\n    // 从 signal 文件描述符中读取结构体 signalfd_siginfo, 每次读取一个\n    ssize_t bytes_read = TEMP_FAILURE_RETRY(read(signal_fd, &siginfo, sizeof(siginfo)));\n\n    if (bytes_read != sizeof(siginfo)) {\n        PLOG(ERROR) << \"Failed to read siginfo from signal_fd\";\n        return;\n    }\n\n    // 根据信号编号执行相应的操作\n    switch (siginfo.ssi_signo) {\n        case SIGCHLD:\n            ReapAnyOutstandingChildren();\n            break;\n        case SIGTERM:\n            HandleSigtermSignal(siginfo);\n            break;\n        default:\n            PLOG(ERROR) << \"signal_fd: received unexpected signal \" << siginfo.ssi_signo;\n            break;\n    }\n}\n```\n\n当目标信号产生并传递给进程时，signal 文件描述符的可读事件就会触发，返回一个或者多个结构体 signalfd_siginfo。而函数 HandleSignalFd 负责从 signal 文件描述符中读出一个结构体 signalfd_siginfo，并根据信号编号执行相应的操作。\n\n在这里，我们关心的信号是 `SIGCHLD`。当此信号产生后，会调用 ReapAnyOutstandingChildren 函数，接着来分析这个函数。\n\n\n\n###### 2.4.3.1.4.1 分析 ReapAnyOutstandingChildren 函数\n\n函数所在文件的路径为 `system/core/init/sigchld_handler.cpp`：\n\n```c++\nvoid ReapAnyOutstandingChildren() {\n    while (ReapOneProcess()) {\n    }\n}\n```\n\n此函数循环调用 ReapOneProcess 函数，只有当函数 ReapOneProcess 返回 false 时，循环才会停止。接着来看 ReapOneProcess 函数做了什么工作。\n\n\n\n###### 2.4.3.1.4.2 分析 ReapOneProcess 函数\n\n<!-- TODO: 分析 service->flags() -->\n\n<!-- TODO: 分析 ServiceList::GetInstance().RemoveService(*service) -->\n\n函数所在文件的路径为 `system/core/init/sigchld_handler.cpp`：\n\n```c++\nstatic bool ReapOneProcess() {\n    siginfo_t siginfo = {};\n\n    // 发起系统调用 waitid, 此系统调用用于获取子进程状态的变更和相关的信息\n    // 由于 init 进程只接收子进程终结的信号, 因此这里获取到的都是已进入僵尸状态的子进程的相关信息, 信息保存在 siginfo 当中\n    if (TEMP_FAILURE_RETRY(waitid(P_ALL, 0, &siginfo, WEXITED | WNOHANG | WNOWAIT)) != 0) {\n        // 失败, 函数返回 false\n        PLOG(ERROR) << \"waitid failed\";\n        return false;\n    }\n\n    // 获取子进程的 pid\n    auto pid = siginfo.si_pid;\n\n    // 子进程的 pid 不存在, 函数返回 false\n    if (pid == 0) return false;\n\n    ...\n\n    std::string name;\n    std::string wait_string;\n    Service* service = nullptr;\n\n    if (PropertyChildReap(pid)) {\n        name = \"Async property child\";\n    } else if (SubcontextChildReap(pid)) {\n        name = \"Subcontext\";\n    } else {\n        // 根据 pid 查询相应的 service\n        service = ServiceList::GetInstance().FindService(pid, &Service::pid);\n\n        if (service) {\n            name = StringPrintf(\"Service '%s' (pid %d)\", service->name().c_str(), pid);\n\n            ...\n\n        } else {\n            name = StringPrintf(\"Untracked pid %d\", pid);\n        }\n    }\n\n    ...\n\n    // 没有找到对应的 service, 函数返回 true\n    if (!service) return true;\n\n    // 调用 service 的 Reap 函数\n    service->Reap(siginfo);\n\n    ...\n\n    return true;\n}\n```\n\n经分析可知，ReapOneProcess 函数的主要工作是：为每个进入终结状态的子进程发起系统调用 waitid，从而避免已进入僵尸状态的子进程一直占据着系统资源。最后，函数会根据子进程 pid 查找是否存在相应的 service，如果 service 存在，还会调用 service 的 Reap 函数。接着来分析 Reap 函数。\n\n\n\n###### 2.4.3.1.4.3 分析 Reap 函数\n\n函数所在文件的路径为 `system/core/init/service.cpp`：\n\n```c++\nvoid Service::Reap(const siginfo_t& siginfo) {\n    if (!(flags_ & SVC_ONESHOT) || (flags_ & SVC_RESTART)) {\n        // 如果服务的标志位同时不带有 SVC_ONESHOT 和 SVC_RESTART, 则直接杀死服务所在的进程组\n        KillProcessGroup(SIGKILL);\n    }\n\n    ...\n\n    // 如果服务的标志位带有 SVC_TEMPORARY, 则直接返回\n    if (flags_ & SVC_TEMPORARY) return;\n\n    // 重置状态\n    pid_ = 0;\n    flags_ &= (~SVC_RUNNING);\n    start_order_ = 0;\n\n    if ((flags_ & SVC_ONESHOT) && !(flags_ & SVC_RESTART) && !(flags_ & SVC_RESET)) {\n        // 将带有 SVC_ONESHOT 的服务设为不可用状态\n        flags_ |= SVC_DISABLED;\n    }\n\n    if (flags_ & (SVC_DISABLED | SVC_RESET))  {\n        // 如果服务的标志位带有 SVC_DISABLED 或者 SVC_RESET, 则使其进入 stopped 状态, 不会自动重启\n        NotifyStateChange(\"stopped\");\n        return;\n    }\n\n    // 带有标志位 SVC_CRITICAL 的服务会被标记为系统关键服务\n    // 如果服务在 4 分钟之内崩溃 4 次以上, 又或者服务崩溃时系统处于未完全启动状态\n    // 则设备会重启并进入 bootloader 或者设置崩溃相关的属性\n    boot_clock::time_point now = boot_clock::now();\n    if (((flags_ & SVC_CRITICAL) || !pre_apexd_) && !(flags_ & SVC_RESTART)) {\n        bool boot_completed = android::base::GetBoolProperty(\"sys.boot_completed\", false);\n        if (now < time_crashed_ + 4min || !boot_completed) {\n            if (++crash_count_ > 4) {\n                if (flags_ & SVC_CRITICAL) {\n                    // Aborts into bootloader\n                    LOG(FATAL) << \"critical process '\" << name_ << \"' exited 4 times \"\n                               << (boot_completed ? \"in 4 minutes\" : \"before boot completed\");\n                } else {\n                    LOG(ERROR) << \"updatable process '\" << name_ << \"' exited 4 times \"\n                               << (boot_completed ? \"in 4 minutes\" : \"before boot completed\");\n                    // Notifies update_verifier and apexd\n                    property_set(\"ro.init.updatable_crashing\", \"1\");\n                }\n            }\n        } else {\n            time_crashed_ = now;\n            crash_count_ = 1;\n        }\n    }\n\n    // 添加标志位 SVC_RESTARTING, init 进程会重启带有此标志位的服务 [2.4.5.2]\n    flags_ &= (~SVC_RESTART);\n    flags_ |= SVC_RESTARTING;\n\n    // 执行当前 service 中所有 onrestart 命令\n    onrestart_.ExecuteAllCommands();\n\n    // 使服务进入 restarting 状态\n    NotifyStateChange(\"restarting\");\n    return;\n}\n```\n\nReap 函数最主要的工作就是重启有需要的服务。注意到，改变服务状态是通过调用 NotifyStateChange 函数实现的，来看看这个函数。\n\n\n\n###### 2.4.3.1.4.4 分析 NotifyStateChange 函数\n\n函数所在文件的路径为 `system/core/init/service.cpp`：\n\n```c++\nvoid Service::NotifyStateChange(const std::string& new_state) const {\n    if ((flags_ & SVC_TEMPORARY) != 0) {\n        // 如果服务的标志位中带有 SVC_TEMPORARY, 则不会使用属性服务来记录它的状态\n        return;\n    }\n\n    // 使用属性服务来记录服务当前的状态\n    std::string prop_name = \"init.svc.\" + name_;\n    property_set(prop_name, new_state);\n\n    ...\n}\n```\n\n通过分析这个函数，可以知道，系统会使用属性服务以 key-value 的形式存储服务当前的状态，其中 key 的取值为 init.svc.[service_name]，value 是服务当前的状态。因此，可以使用 adb，输入命令 `getprop | grep init.svc.`，查看设备上 service 的运行状态，以下是其中的一些输出：\n\n```\n[init.svc.adbd]: [running]\n[init.svc.alarm-hal-1-0]: [running]\n[init.svc.android.thermal-hal]: [running]\n[init.svc.apexd]: [stopped]\n[init.svc.apexd-bootstrap]: [stopped]\n[init.svc.apexd-snapshotde]: [stopped]\n[init.svc.audioserver]: [running]\n[init.svc.wifidisplayhalservice]: [running]\n[init.svc.wpa_supplicant]: [running]\n[init.svc.zygote]: [running]\n[init.svc.zygote_secondary]: [running]\n```\n\n\n\n### 2.4.4 加载启动脚本\n\n<!-- TODO: 分析函数 CreateParser -->\n\n<!-- TODO: .rc 文件的解析过程 -->\n\n<!-- TODO: 属性的变更如何触发脚本中的属性触发器？ -->\n\n<!-- TODO: /system/etc/init -->\n\n<!-- TODO: /odm/etc/init -->\n\n<!-- TODO: /vendor/etc/init -->\n\n调用 LoadBootScripts 函数加载启动脚本，函数所在文件的路径为 `system/core/init/init.cpp`。\n\n```c++\nstatic void LoadBootScripts(ActionManager& action_manager, ServiceList& service_list) {\n    Parser parser = CreateParser(action_manager, service_list);\n\n    std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\");\n    if (bootscript.empty()) {\n        // 加载 init.rc 脚本文件 [2.4.4.1]\n        parser.ParseConfig(\"/init.rc\");\n\n        // 加载 /system/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/system/etc/init\")) {\n            late_import_paths.emplace_back(\"/system/etc/init\");\n        }\n\n        // 加载 /product/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/product/etc/init\")) {\n            late_import_paths.emplace_back(\"/product/etc/init\");\n        }\n\n        // 加载 /product_services/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/product_services/etc/init\")) {\n            late_import_paths.emplace_back(\"/product_services/etc/init\");\n        }\n\n        // 加载 /odm/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/odm/etc/init\")) {\n            late_import_paths.emplace_back(\"/odm/etc/init\");\n        }\n\n        // 加载 /vendor/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/vendor/etc/init\")) {\n            late_import_paths.emplace_back(\"/vendor/etc/init\");\n        }\n    } else {\n        parser.ParseConfig(bootscript);\n    }\n}\n```\n\n一般情况下，此函数会去加载一些指定的脚本，其中：\n\n- `init.rc` 是主要的 .rc 文件。\n- `/system/etc/init/` 包含了核心的系统项目，例如：SurfaceFlinger, MediaService, logcatd。\n- `/vendor/etc/init/` 包含了 SoC 供应商项目，例如：核心 SoC 功能所需的操作或守护进程。\n- `/odm/etc/init/` 包含了设备制造商项目，例如：运动传感器或其他外围设备所需的操作或守护进程。\n\ninit.rc 是最主要脚本文件，接下来将对这个脚本进行分析。\n\n\n\n#### 2.4.4.1 init.rc 脚本\n\n在 Android，后缀为 .rc 的文件由 Android Init Language 编写，[关于 Android Init Language 的详细说明](https://cs.android.com/android/platform/superproject/+/android-security-10.0.0_r56:system/core/init/README.md) 可以在 AOSP 上找到，路径为 `system/core/init/README.md`。\n\n在分析脚本之前，首先来了解这种语言的语法。\n\n\n\n##### 2.4.4.1.1 Android Init Language\n\nAndroid Init Language 由五大类表达式组成：`Actions`，`Commands`，`Services`，`Options`，`Imports`。\n\n其语法规则有：\n\n- 每一行都是一条语句，一条语句由多个 token 组成，token 之间以空格分开。\n- 如果一个 token 包含了空格，可以跟 c 语言类似，使用反斜杠 `\\` 作为转义字符，又或者使用双引号包裹整个 token。\n- 在行的末尾使用反斜杠 `\\`，可以将语句换行。\n- 以符号 `#` 开头的行是注释行。\n- 系统属性的值可以通过语法 `${property.name}` 获取，例如：`import /init.recovery.${ro.hardware}.rc`。\n- 一个文件可以分为多个 section，必须使用 `Actions` 或者 `Services` 来声明一个新的 section。所有的 `Commands` 和 `Options` 都是属于最近声明的那一个 section。如果在一个 section 之前声明了 `Commands` 或者 `Options` ，则声明会被忽略。\n- `Services` 的名称必须是唯一的，如果存在多个重名的 `Services` ，除了第一个以外，其他的都会被忽略，并且会输出错误日志。\n\n接下来列出一些较为重要的表达式。\n\n\n\n###### 2.4.4.1.1.1 Actions\n\n`Actions` 由 一系列 `Commands` 组成，同时 `Triggers` 决定了 `Actions` 的触发时机，其形式为：\n\n```\non <trigger> [&& <trigger>]*\n   <command>\n   <command>\n   <command>\n```\n\n当一个事件触发后，如果此事件能够匹配上 `Actions` 的  `Triggers`，那么 `Actions` 会被添加到待执行队列的尾部。\n\n之后，待执行队列中的 `Actions` 会按照加入顺序出队，并且执行该 `Actions` 中的 `Commands`。\n\n以启动 Zygote 作为示例：\n\n```\non zygote-start && property:ro.crypto.state=unencrypted\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n```\n\n简单分析这个脚本：\n\n这个 `Actions` 拥有两个 `Triggers`，分别是 `zygote-start` 和 `property:ro.crypto.state=unencrypted`，从第二行开始，每一行都是一个 `Command`。\n\n当事件 `zygote-start` 和 `property:ro.crypto.state=unencrypted` 触发后，`Actions` 会被加入到待执行队列。在执行到该 `Actions` 时，会按照 `Commands` 定义的先后顺序，依次执行 `Actions` 中的 `Commands`。\n\n\n\n###### 2.4.4.1.1.2 Triggers\n\n`Triggers` 是字符串，用于匹配某些类型的事件并触发 `Actions` 中的 `Commands`。\n\nTriggers 可以分为两类：\n\n- **Event triggers**\n\n  事件触发器，这类触发器所匹配的事件由命令 `trigger`  触发，又或者通过调用 `QueueEventTrigger()` 函数触发。\n\n- **Property triggers**\n\n  属性触发器，这类触发器所匹配的事件是：属性是否满足某个值，形式为 `property:<key>=<value>`。这里的属性就是之前提到的属性服务管理的属性。\n\n注意，每一个 `Actions` 可以有多个属性触发器，但只能有一个事件触发器。\n\n例如：\n\n`on init && property:a=b`，`on property:a=b && property:c=d` 是合法的。\n\n`on boot && on init` 是不合法的。\n\n\n\n###### 2.4.4.1.1.3 Commands\n\n下面列举一些常见的 `Commands`：\n\n- **trigger <event>**\n\n  触发一个事件。\n\n- **write <path> <content>**\n\n  按 path 打开文件，往文件中写入内容。\n\n- **chown <owner> <group> <path>**\n\n  更改文件所有者和组。\n\n- **mkdir <path> [mode] [owner] [group]**\n\n  在路径上创建一个目录，可以选择使用给定的权限，所有者，用户组。 \n\n  如果未指定权限，所有者，用户组，则新建的目录默认具有权限 755，并由 root 用户和 root 组拥有。\n\n  当指定权限，所有者，用户组时，如果目录已经存在，则权限，所有者，用户组将被更新。\n\n- **start <service>**\n\n  当指定的服务未在运行时，启动该服务。\n\n- **exec_start <service>**\n\n  启动指定的服务，在该命令返回之前暂停处理其他命令。\n\n- **setprop <name> <value>**\n\n  给系统属性赋值，这里的属性是之前提到的属性服务中的属性。\n\n- **symlink <target> <path>**\n\n  在 path 上创建一个连接到 target 的符号链接。\n\n\n\n###### 2.4.4.1.1.4 Services\n\n`Services` 是由 init 进程启动的程序，一般运行在 init 进程的一个子进程，因此 init 进程在启动一个 `Services` 时会通过 fork 的方式生成子进程。\n\n默认情况下，`Services` 退出后会重启。\n\n`Services` 的形式如下：\n\n```\nservice <name> <pathname> [ <argument> ]*\n   <option>\n   <option>\n   ...\n```\n\n以启动 Zygote 64 位进程的脚本作为示例：\n\n```\nservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server\n    class main\n    priority -20\n    user root\n    group root readproc reserved_disk\n    socket zygote stream 660 root system\n    socket usap_pool_primary stream 660 root system\n    onrestart write /sys/android_power/request_state wake\n    onrestart write /sys/power/state on\n    onrestart restart audioserver\n    onrestart restart cameraserver\n    onrestart restart media\n    onrestart restart netd\n    onrestart restart wificond\n    writepid /dev/cpuset/foreground/tasks\n```\n\n简单分析这个脚本：`zygote` 是 `Services` 的名称，`/system/bin/app_process64` 是可执行文件的路径，`-Xzygote /system/bin --zygote --start-system-server` 是启动参数，从第二行开始，每一行都是一个 `Options`。\n\n\n\n###### 2.4.4.1.1.5 Options\n\n`Options` 是 `Services` 的配置项，用于控制 init 进程运行 `Services` 的方式和时间。\n\n 下面列举一些常见的 `Options`：\n\n- **class <name> [ <name>\\* ]**\n\n  指定 `Services` 的类名。当 `Services` 所属类开启 (退出) 时，`Services` 也会开启 (退出) 。默认值为 default。\n\n- **class_start <serviceclass>**\n\n  启动所有未在运行的，类名被指定为 `serviceclass` 的 `Services`。\n\n- **priority <priority>**\n\n  设置 `Services` 进程的优先级。取值范围是 -20 ~ 19。默认值为 0。\n\n- **user <username>**\n\n  设置执行 `Services` 的用户。一般情况下，默认值为 root。\n\n- **group <groupname> [ <groupname>\\* ]**\n\n  设置执行 `Services` 的用户组。一般情况下，默认值为 root。\n\n- **socket <name> <type> <perm> [ <user> [ <group> [ <seclabel> ] ] ]**\n\n  创建一个 unix 域的 socket，命名为 `/dev/socket/<name>`，并将 socket 的文件描述符传递给创建的进程。\n\n- **onrestart**\n\n  当 `Services` 重启时执行一个 `Commands`。\n\n- **oneshot**\n\n  当 `Services` 退出后不再重启。\n\n- **writepid <file> [ <file>\\* ]**\n\n  在进程 fork 之后，将子进程的 pid 写入指定的文件。\n\n\n\n##### 2.4.4.1.2 加载 init.rc 脚本\n\n脚本文件 init.rc 负责系统的初始设置，文件的路径为 `system/core/rootdir/init.rc`。\n\n在了解到脚本的编写语法之后，可以知道脚本的内容都是由  `Actions` 和 `Services` 构成的，而在 init.rc 脚本中绝大部分都是 `Actions`。在 [2.4.4.1.1.2] 中曾经提到，调用 `QueueEventTrigger()` 函数可以触发一个事件，当事件匹配上  `Actions` 的  `Triggers`，就会开始执行该 `Actions`。 接下来回到进程启动的第二阶段，寻找事件的触发点。\n\n\n\n###### 2.4.4.1.2.1 源码中事件的触发点\n\n回到 init 进程启动的第二阶段，对应源代码 `system/core/init/init.cpp` 的 SecondStageMain 函数：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n\n    ...\n\n    ActionManager& am = ActionManager::GetInstance();\n\n    ...\n\n    // 将触发事件 early-init 的操作加入到 ActionManager\n    am.QueueEventTrigger(\"early-init\");\n\n    ...\n\n    // Trigger all the boot actions to get us started.\n    // 将触发事件 init 的操作加入到 ActionManager\n    am.QueueEventTrigger(\"init\");\n\n    ...\n\n    // Don't mount filesystems or start core system services in charger mode.\n    std::string bootmode = GetProperty(\"ro.bootmode\", \"\");\n    if (bootmode == \"charger\") {\n        // 如果当前处于充电模式, 则将触发事件 charger 的操作加入到 ActionManager\n        // 在充电模式下, 不会挂载文件系统和启动核心系统服务\n        am.QueueEventTrigger(\"charger\");\n    } else {\n        // 如果当前处于非充电模式, 则将触发事件 late-init 的操作加入到 ActionManager\n        am.QueueEventTrigger(\"late-init\");\n    }\n\n    ...\n\n    return 0;\n}\n```\n\nActionManager 会按操作加入的顺序逐一执行 [2.4.5.x]，由此可知事件的触发顺序：\n\n- 非充电模式：early-init -> init -> late-init\n- 充电模式：early-init -> init -> charger\n\n由于在充电模式下，系统可能未完全启动，接下来将选取非充电模式下的流程进行分析。\n\n\n\n###### 2.4.4.1.2.2 init.rc 脚本的执行过程\n\n<!-- TODO: trigger boot -->\n\n现在结合事件的触发顺序，分析脚本执行过程中的一些关键点：\n\n```\non early-init\n    ...\n\n    # 以 start 方式启动 ueventd\n    start ueventd\n\n    # 以 exec_start 方式运行 apexd-bootstrap, 在该命令返回之前暂停处理其他命令, 从而保证后续流程中 APEX 的可用性\n    exec_start apexd-bootstrap\n\non init\n    ...\n\n    # 以 start 方式启动基本服务\n    # 启动 servicemanager [2.4.4.1.2.3]\n    start servicemanager\n    start hwservicemanager\n    start vndservicemanager\n\n# 挂载文件和启动核心系统服务\n# 其中 trigger 用于触发一个事件 [2.4.4.1.1.2]\non late-init\n    trigger early-fs\n    trigger fs\n    trigger post-fs\n    trigger late-fs\n    trigger post-fs-data\n    trigger load_persist_props_action\n\n    # 触发事件 zygote-start, 启动 zygote [2.4.4.1.2.4]\n    trigger zygote-start\n\n    trigger firmware_mounts_complete\n    trigger early-boot\n    trigger boot\n```\n\n经过分析，现在已经大致了解脚本的执行过程，接下来分析 servicemanager 和 zygote 的启动。\n\n\n\n###### 2.4.4.1.2.3 启动 servicemanager\n\nservicemanager 启动脚本的路径为 `frameworks/native/cmds/servicemanager/servicemanager.rc`，分析这个脚本：\n\n```\n# servicemanager 是 Services 的名称\n# /system/bin/servicemanager 是可执行文件的路径\nservice servicemanager /system/bin/servicemanager\n    # 指定类名为 core 和 animation\n    # 当 core 或者 animation 开启 (关闭) 时, servicemanager 也将开启 (关闭)\n    class core animation\n\n    # 设置用户为 system\n    user system\n\n    # 设置用户组为 system 和 readproc\n    group system readproc\n\n    # 将其标记为设备的关键服务\n    # 如果此服务在规定时间内不断重启, 则设备会重启并进入 bootloader\n    critical\n\n    # 设置服务重启后执行的操作\n    # 每一个操作都是一个 Commands\n    onrestart restart healthd\n    onrestart restart zygote\n    onrestart restart audioserver\n    onrestart restart media\n    onrestart restart surfaceflinger\n    onrestart restart inputflinger\n    onrestart restart drm\n    onrestart restart cameraserver\n    onrestart restart keystore\n    onrestart restart gatekeeperd\n    onrestart restart thermalservice\n\n    # 在进程执行 fork 操作之后，将子进程的 pid 写入文件 /dev/cpuset/system-background/tasks\n    writepid /dev/cpuset/system-background/tasks\n\n    # 设置服务的关闭行为\n    # shutdown critical 表示此服务在关闭期间不会被杀死, 当关闭超时后才会被杀死\n    shutdown critical\n```\n\n启动 servicemanager 之后，便会进入 `frameworks/native/cmds/servicemanager/service_manager.c` 的 main 函数。\n\n\n\n###### 2.4.4.1.2.4 启动 zygote\n\n在 init.rc 脚本中，事件 `zygote-start` 有 3 个对应的 `Actions`：\n\n```\non zygote-start && property:ro.crypto.state=unencrypted\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n\non zygote-start && property:ro.crypto.state=unsupported\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n\non zygote-start && property:ro.crypto.state=encrypted && property:ro.crypto.type=file\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n```\n\n其中，zygote 通过以下语句导入：\n\n```\nimport /init.${ro.zygote}.rc\n```\n\n此语句会根据属性 `ro.zygote`，导入相应的文件，其中包括：\n\n```\nsystem/core/rootdir/init.zygote32.rc\nsystem/core/rootdir/init.zygote32_64.rc\nsystem/core/rootdir/init.zygote64.rc\nsystem/core/rootdir/init.zygote64_32.rc\n```\n\nzygote 的启动除了依赖事件 `zygote-start` 以外，还需要某些属性满足特定的值。当上面列出的三个 `Actions` 中的其中一个满足条件后，便会启动 zygote。\n\n这里分析启动 Zygote 64 位进程的脚本，脚本文件的路径为 `system/core/rootdir/init.zygote64.rc`：\n\n```\n# zygote 是 Services 的名称\n# /system/bin/app_process64 是可执行文件的路径\n# -Xzygote /system/bin --zygote --start-system-server 是启动参数\nservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server\n    # 指定类名为 main\n    # 当 main 开启 (关闭) 时, zygote 也将开启 (关闭)\n    class main\n\n    # 进程优先级为 -20\n    # 由于优先级的取值范围是 -20 ~ 19, 数值越小, 优先级越高, 因此 zygote 进程拥有最高的优先级\n    priority -20\n\n    # 用户和用户组都是 root\n    user root\n    group root readproc reserved_disk\n\n    # 创建 socket\n    socket zygote stream 660 root system\n    socket usap_pool_primary stream 660 root system\n\n    # 设置服务重启后执行的操作\n    # 每一个操作都是一个 Commands\n    onrestart write /sys/android_power/request_state wake\n    onrestart write /sys/power/state on\n    onrestart restart audioserver\n    onrestart restart cameraserver\n    onrestart restart media\n    onrestart restart netd\n    onrestart restart wificond\n\n    # 在 zygote 进程执行 fork 操作之后，将子进程的 pid 写入文件 /dev/cpuset/foreground/tasks\n    writepid /dev/cpuset/foreground/tasks\n```\n\n启动 zygote 之后，便会进入 `frameworks/base/cmds/app_process/app_main.cpp` 的 main 函数。\n\n\n\n### 2.4.5 进入无限循环状态\n\ninit 进程启动完成之后，进程就会一直存活，而保持存活的方法就是进入无限循环状态。接下来分析这个过程，源代码的路径为 `system/core/init/init.cpp`：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n\n    ...\n\n    while (true) {\n        // 设置等待 epoll 事件的超时时长\n        // 默认情况下会一直处于阻塞状态, 直到有事件发生, 此时 epoll_timeout 取值为 -1\n        auto epoll_timeout = std::optional<std::chrono::milliseconds>{};\n\n        ...\n\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            // am 是一个引用, 指向 ActionManager 实例\n            // 按顺序执行 ActionManager 中的一个命令 [2.4.5.1]\n            am.ExecuteOneCommand();\n        }\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            if (!shutting_down) {\n                // 获取下一次 HandleProcessActions 的时间点 [2.4.5.2]\n                auto next_process_action_time = HandleProcessActions();\n\n                if (next_process_action_time) {\n                    // 计算出 next_process_action_time 与当前时间的差值\n                    epoll_timeout = std::chrono::ceil<std::chrono::milliseconds>(\n                            *next_process_action_time - boot_clock::now());\n\n                    // 如果差值小于 0, 说明需要立即进行下一次的循环\n                    // 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程\n                    if (*epoll_timeout < 0ms) epoll_timeout = 0ms;\n                }\n            }\n\n            // 如果 ActionManager 中仍有待执行的命令, 那么 init 进程不会进入阻塞状态, 并立即再次唤起\n            // 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程\n            if (am.HasMoreCommands()) epoll_timeout = 0ms;\n        }\n\n        // 调用 Wait 函数, 等待事件触发 [2.4.1.3]\n        if (auto result = epoll.Wait(epoll_timeout); !result) {\n            LOG(ERROR) << result.error();\n        }\n    }\n\n    return 0;\n}\n```\n\n经分析可知，init 进程进入循环状态后主要的工作有 3 个：\n\n- 执行 ActionManager 中的命令。\n- 重启服务。\n- 等待 epoll 事件，当事件触发后，调用相应的函数进行处理。结合前面的分析，可知等待的事件有：一个进程通过请求 init 进程向属性服务写入属性，以及 init 进程接收到 `SIGCHLD` 信号。\n\n\n\n#### 2.4.5.1 ActionManager\n\n<!-- TODO: 什么是 Action? -->\n\n<!-- TODO: Action 和脚本中的 Actions 有没有关系 -->\n\n<!-- TODO: 添加和执行过程 -->\n\nActionManager 是 Action 的管理器，它提供了对 Action 的添加、执行、清空等操作。\n\n\n\n##### 2.4.5.1.1 添加 Action\n\n<!-- TODO: 详细分析 Action 的作用 -->\n\n在 init 进程启动的第二阶段中添加了一些 Action，简单看下其中部分 Action 的作用：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n    ...\n\n    // am 是一个引用, 指向 ActionManager 实例\n    ActionManager& am = ActionManager::GetInstance();\n\n    ...\n\n    am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\");\n\n    // 添加 Action: 触发事件 early-init [2.4.4.1.2.1]\n    am.QueueEventTrigger(\"early-init\");\n\n    // 添加 Action: 等待 coldboot 完成\n    am.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\");\n\n    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\");\n    am.QueueBuiltinAction(SetMmapRndBitsAction, \"SetMmapRndBits\");\n    am.QueueBuiltinAction(SetKptrRestrictAction, \"SetKptrRestrict\");\n    Keychords keychords;\n    am.QueueBuiltinAction(\n        [&epoll, &keychords](const BuiltinArguments& args) -> Result<Success> {\n            for (const auto& svc : ServiceList::GetInstance()) {\n                keychords.Register(svc->keycodes());\n            }\n            keychords.Start(&epoll, HandleKeychord);\n            return Success();\n        },\n        \"KeychordInit\");\n    am.QueueBuiltinAction(console_init_action, \"console_init\");\n\n    // 添加 Action: 触发事件 init [2.4.4.1.2.1]\n    am.QueueEventTrigger(\"init\");\n\n    am.QueueBuiltinAction(StartBoringSslSelfTest, \"StartBoringSslSelfTest\");\n    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\");\n\n    // 添加 Action: 为 init 进程初始化 binder\n    am.QueueBuiltinAction(InitBinder, \"InitBinder\");\n\n    std::string bootmode = GetProperty(\"ro.bootmode\", \"\");\n    if (bootmode == \"charger\") {\n        // 在充电模式下, 添加 Action: 触发事件 charger [2.4.4.1.2.1]\n        am.QueueEventTrigger(\"charger\");\n    } else {\n        // 否则, 添加 Action: 触发事件 late-init [2.4.4.1.2.1]\n        am.QueueEventTrigger(\"late-init\");\n    }\n\n    // 添加 Action: 触发当前所有的属性触发器\n    am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\");\n\n    ...\n\n}\n```\n\n此外，在解析脚本或者属性值改变的时候，也会使用 ActionManager 添加 Action。\n\n\n\n#### 2.4.5.2 HandleProcessActions\n\n<!-- ((s->flags() & SVC_RUNNING) && s->timeout_period()) -->\n\n<!-- 详细分析 service 的重启过程 -->\n\n```c++\nstatic std::optional<boot_clock::time_point> HandleProcessActions() {\n    std::optional<boot_clock::time_point> next_process_action_time;\n\n    // 遍历 ServiceList\n    for (const auto& s : ServiceList::GetInstance()) {\n        // 判断服务是否处于运行中状态, 以及是否有超时时长\n        if ((s->flags() & SVC_RUNNING) && s->timeout_period()) {\n            // 计算出服务启动的超时时间\n            auto timeout_time = s->time_started() + *s->timeout_period();\n\n            if (boot_clock::now() > timeout_time) {\n                // 如果当前时间已大于服务启动的超时时间, 说明服务启动已超时\n                s->Timeout();\n            } else {\n                // 更新 next_process_action_time\n                // 此时, next_process_action_time 表示最近的, 需要检查服务是否启动成功的时间点\n                if (!next_process_action_time || timeout_time < *next_process_action_time) {\n                    next_process_action_time = timeout_time;\n                }\n            }\n        }\n\n        // 如果服务不带有标志位 SVC_RESTARTING, 则不需要重启, 继续 for 循环\n        if (!(s->flags() & SVC_RESTARTING)) continue;\n\n        // 计算出服务启动的超时时间\n        auto restart_time = s->time_started() + s->restart_period();\n\n        // 现在服务需要重启, 接下来重启已满足重启条件的服务\n        if (boot_clock::now() > restart_time) {\n            // 如果当前时间已大于服务的重启时间, 那么立即启动服务\n            if (auto result = s->Start(); !result) {\n                LOG(ERROR) << \"Could not restart process '\" << s->name() << \"': \" << result.error();\n            }\n        } else {\n            // 更新 next_process_action_time\n            // 此时, next_process_action_time 表示最近的, 需要对服务进行重启操作的时间点\n            if (!next_process_action_time || restart_time < *next_process_action_time) {\n                next_process_action_time = restart_time;\n            }\n        }\n    }\n    return next_process_action_time;\n}\n```\n\n此函数的工作有：\n\n1. 检查带有标志位 `SVC_RUNNING` 的服务是否超时，如果服务启动超时，则调用 `Timeout` 函数，否则更新下次检查的时间点。\n2. 当服务带有标志位 `SVC_RESTARTING` 时，说明服务需要重启。如果当前时间已大于服务的重启时间，则立即重启服务；否则，更新下次重启的时间点。 \n\n经分析可知，`next_process_action_time` 可能表示下一次的检查服务是否启动超时的时间点，也可能表示下一次为某个服务重启的时间点。\n\n注意到，在之前的分析信号 [2.4.3.1.4.3] 提到过，当 init 收到子进程终结的信号之后，会为有重启需要的服务添加标志位 `SVC_RESTARTING`。那么现在可以知道，在 init 进程进入无限循环状态后，就会处理这些带有标志位 `SVC_RESTARTING` 的服务，重启满足条件的服务。\n\n\n\n# 参考\n\n[Android系统启动-综述](http://gityuan.com/2016/02/01/android-booting/)\n\n[Android系统启动-Init篇](http://gityuan.com/2016/02/05/android-init/)\n\n[epoll(7)](https://man7.org/linux/man-pages/man7/epoll.7.html)\n\n[Signal](https://en.wikipedia.org/wiki/Signal_(IPC))\n\n[signal(7)](https://man7.org/linux/man-pages/man7/signal.7.html)\n\n[wait(2)](https://man7.org/linux/man-pages/man2/wait.2.html)\n\n[signalfd(2)](https://man7.org/linux/man-pages/man2/signalfd.2.html)\n\n","slug":"exploring-init-process-startup-process","published":0,"date":"2021-11-05T08:35:16.619Z","updated":"2021-11-09T11:56:14.735Z","_id":"cksol4flf00000cprd5ks579o","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>本文基于源代码：android-security-10.0.0_r56</p>\n</blockquote>\n<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><!-- TODO: 关于 init 进程更好的概述 -->\n\n<p>Android 基于 Linux 内核，在内核启动过程中会创建出 init 进程。</p>\n<p>init 进程是用户空间的第一个进程，进程的 pid = 1。</p>\n<a id=\"more\"></a>\n\n\n\n<h1 id=\"2-启动流程\"><a href=\"#2-启动流程\" class=\"headerlink\" title=\"2. 启动流程\"></a>2. 启动流程</h1><!-- TODO: 总结 -->\n\n\n\n<h2 id=\"2-1-init-进程的入口\"><a href=\"#2-1-init-进程的入口\" class=\"headerlink\" title=\"2.1 init 进程的入口\"></a>2.1 init 进程的入口</h2><!-- TODO: 为什么是入口？ -->\n\n<!-- TODO: init 就是一个普通的命令行程序, 位置在 /system/core/init？ -->\n\n<p>在 Android 9，init 进程的入口位于 <code>system/core/init/init.cpp</code> 中的 main 函数。</p>\n<p>在 Android 10 之后，init 进程的入口改到了 <code>system/core/init/main.cpp</code> 中的 main 函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(basename(argv[<span class=\"number\">0</span>]), <span class=\"string\">&quot;ueventd&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ueventd_main(argc, argv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;subcontext&quot;</span>)) &#123;</span><br><span class=\"line\">            android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class=\"line\">            <span class=\"keyword\">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> SubcontextMain(argc, argv, &amp;function_map);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;selinux_setup&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SetupSelinux(argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;second_stage&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SecondStageMain(argc, argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> FirstStageMain(argc, argv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先来了解其中使用到的两个库函数：<code>basename</code> 函数和 <code>strcmp</code> 函数。</p>\n<ul>\n<li><code>basename</code> 的函数原型为 <code>char* basename(char* __path)</code>，可以根据给定的一个路径，返回文件名。例如：传入参数 “/system/bin/ueventd”，函数会返回 “ueventd”。</li>\n<li><code>strcmp</code> 的函数原型为 <code>int strcmp(const char* __lhs, const char* __rhs)</code>，是一个字符串比较函数，返回值为整数。当两个字符串相等时，函数返回 0。</li>\n</ul>\n<p>再来分析 main 函数：函数的主要工作是根据参数 <code>argc</code> 和 <code>argv</code>，选择对应的执行方式。如果参数未匹配成功，则默认调用 <code>FirstStageMain</code> 函数。</p>\n<h2 id=\"2-2-启动的第一阶段\"><a href=\"#2-2-启动的第一阶段\" class=\"headerlink\" title=\"2.2 启动的第一阶段\"></a>2.2 启动的第一阶段</h2><!-- TODO: mkdir, mknod, tmpfs -->\n\n<!-- TODO: 所挂载的文件系统的用处 -->\n\n<!-- TODO: KernelLogging(/dev/kmsg) -->\n\n<!-- TODO: InstallRebootSignalHandlers -->\n\n<p>调用 <code>int FirstStageMain(int argc, char** argv)</code> 进入启动的第一阶段，函数所在文件的路径为 <code>system/core/init/first_stage_init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FirstStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(clearenv());</span><br><span class=\"line\">    CHECKCALL(setenv(<span class=\"string\">&quot;PATH&quot;</span>, _PATH_DEFPATH, <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"comment\">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class=\"line\">    <span class=\"comment\">// on / and then we&#x27;ll let the rc file figure out the rest.</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/dev&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class=\"string\">&quot;mode=0755&quot;</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/pts&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/socket&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/dm-user&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;devpts&quot;</span>, <span class=\"string\">&quot;/dev/pts&quot;</span>, <span class=\"string\">&quot;devpts&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;proc&quot;</span>, <span class=\"string\">&quot;/proc&quot;</span>, <span class=\"string\">&quot;proc&quot;</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;hidepid=2,gid=&quot;</span> MAKE_STR(AID_READPROC)));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> MAKE_STR</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t expose the raw commandline to unprivileged processes.</span></span><br><span class=\"line\">    <span class=\"comment\">// 设置文件权限 [2.2.1]</span></span><br><span class=\"line\">    CHECKCALL(chmod(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, <span class=\"number\">0440</span>));</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> cmdline;</span><br><span class=\"line\">    android::base::ReadFileToString(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, &amp;cmdline);</span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t expose the raw bootconfig to unprivileged processes.</span></span><br><span class=\"line\">    chmod(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, <span class=\"number\">0440</span>);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootconfig;</span><br><span class=\"line\">    android::base::ReadFileToString(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, &amp;bootconfig);</span><br><span class=\"line\">    <span class=\"keyword\">gid_t</span> groups[] = &#123;AID_READPROC&#125;;</span><br><span class=\"line\">    CHECKCALL(setgroups(arraysize(groups), groups));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;sysfs&quot;</span>, <span class=\"string\">&quot;/sys&quot;</span>, <span class=\"string\">&quot;sysfs&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;selinuxfs&quot;</span>, <span class=\"string\">&quot;/sys/fs/selinux&quot;</span>, <span class=\"string\">&quot;selinuxfs&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/kmsg&quot;</span>, S_IFCHR | <span class=\"number\">0600</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">11</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">if</span> <span class=\"title\">constexpr</span> <span class=\"params\">(WORLD_WRITABLE_KMSG)</span> </span>&#123;</span><br><span class=\"line\">        CHECKCALL(mknod(<span class=\"string\">&quot;/dev/kmsg_debug&quot;</span>, S_IFCHR | <span class=\"number\">0622</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">11</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/random&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">8</span>)));</span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/urandom&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">9</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This is needed for log wrapper, which gets called before ueventd runs.</span></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/ptmx&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">5</span>, <span class=\"number\">2</span>)));</span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/null&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">3</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// These below mounts are done in first stage init so that first stage mount can mount</span></span><br><span class=\"line\">    <span class=\"comment\">// subdirectories of /mnt/&#123;vendor,product&#125;/.  Other mounts, not required by first stage mount,</span></span><br><span class=\"line\">    <span class=\"comment\">// should be done in rc files.</span></span><br><span class=\"line\">    <span class=\"comment\">// Mount staging areas for devices managed by vold</span></span><br><span class=\"line\">    <span class=\"comment\">// See storage config details at http://source.android.com/devices/storage/</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/mnt&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=1000&quot;</span>));</span><br><span class=\"line\">    <span class=\"comment\">// /mnt/vendor is used to mount vendor-specific partitions that can not be</span></span><br><span class=\"line\">    <span class=\"comment\">// part of the vendor partition, e.g. because they are mounted read-write.</span></span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/mnt/vendor&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    <span class=\"comment\">// /mnt/product is used to mount product-specific partitions that can not be</span></span><br><span class=\"line\">    <span class=\"comment\">// part of the product partition, e.g. because they are mounted read-write.</span></span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/mnt/product&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /debug_ramdisk is used to preserve additional files from the debug ramdisk</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/debug_ramdisk&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=0&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /second_stage_resources is used to preserve files from first to second</span></span><br><span class=\"line\">    <span class=\"comment\">// stage init</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, kSecondStageRes, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=0&quot;</span>))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> CHECKCALL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    SetStdioToDevNull(argv);</span><br><span class=\"line\">    <span class=\"comment\">// Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually</span></span><br><span class=\"line\">    <span class=\"comment\">// talk to the outside world...</span></span><br><span class=\"line\">    InitKernelLogging(argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!errors.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; [error_string, error_errno] : errors) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; error_string &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; strerror(error_errno);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;Init encountered errors starting first stage, aborting&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG(INFO) &lt;&lt; <span class=\"string\">&quot;init first stage started!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 /system/bin/init</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到传入的参数是 selinux_setup, 因此接下来会调用 SetupSelinux 函数进行 SELinux 的初始化 [2.3]</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;selinux_setup&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> fd = open(<span class=\"string\">&quot;/dev/kmsg&quot;</span>, O_WRONLY | O_CLOEXEC);</span><br><span class=\"line\">    dup2(fd, STDOUT_FILENO);</span><br><span class=\"line\">    dup2(fd, STDERR_FILENO);</span><br><span class=\"line\">    close(fd);</span><br><span class=\"line\">    execv(path, <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">char</span>**&gt;(args));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// execv() only returns if an error happened, in which case we</span></span><br><span class=\"line\">    <span class=\"comment\">// panic and never fall through this conditional.</span></span><br><span class=\"line\">    PLOG(FATAL) &lt;&lt; <span class=\"string\">&quot;execv(\\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class=\"string\">&quot;\\&quot;) failed&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数主要工作是挂载一些文件系统，然后执行 <code>/system/bin/init</code>，重新进入 main 函数，通过传入参数 <code>&quot;selinux_setup&quot;</code>，进而调用 SetupSelinux 函数，进行 SELinux 的初始化。</p>\n<h3 id=\"2-2-1-设置文件或目录的权限\"><a href=\"#2-2-1-设置文件或目录的权限\" class=\"headerlink\" title=\"2.2.1 设置文件或目录的权限\"></a>2.2.1 设置文件或目录的权限</h3><p>在 Linux 系统上，<code>chmod</code> 命令用于控制用户对文件或者目录的权限，但只有文件所有者和超级用户可以修改文件或目录的权限。</p>\n<p>权限分为三类：读，写，执行。</p>\n<h4 id=\"2-2-1-1-符号表示法\"><a href=\"#2-2-1-1-符号表示法\" class=\"headerlink\" title=\"2.2.1.1 符号表示法\"></a>2.2.1.1 符号表示法</h4><p>符号表示法用 10 位字符表示权限，其形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rwxrwxrwx</span><br></pre></td></tr></table></figure>\n<p>其中第一个字符表示文件类型，常见的符号有：</p>\n<ul>\n<li><code>-</code>，表示普通文件。</li>\n<li><code>d</code>，表示目录。</li>\n<li><code>c</code>，表示字符特殊文件。</li>\n</ul>\n<p>剩余的 9 个字符，每 3 个字符分为一组，分别表示文件所有者，用户组，其他用户的权限。</p>\n<p>3 个字符组成的字符串，第 1 位控制读权限，第 2 位控制写权限，第 3 位控制执行权限：</p>\n<ul>\n<li>如果拥有读权限，第 1 位字符为 <code>r</code>，否则为 <code>-</code>。</li>\n<li>如果拥有写权限，第 2 位字符为 <code>w</code>，否则为 <code>-</code>。</li>\n<li>如果拥有执行权限，第 3 位字符为 <code>x</code>，否则为 <code>-</code>。</li>\n</ul>\n<p>示例：<code>-rwxrw-r--</code> 表示一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。</p>\n<h4 id=\"2-2-1-2-数字表示法\"><a href=\"#2-2-1-2-数字表示法\" class=\"headerlink\" title=\"2.2.1.2 数字表示法\"></a>2.2.1.2 数字表示法</h4><p>可以用 4 位八进制数字表示权限，第 1 位同样表示文件类型，剩余的 3 位数字，分别表示文件所有者，用户组，其他用户的权限。</p>\n<p>读，写，执行，这 3 类权限可以使用 3 位二进制数字表示，不同类型的权限单独对应二进制数字中一个位：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数值</th>\n<th align=\"center\">权限</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">二进制：100，八进制：4</td>\n<td align=\"center\">r</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：010，八进制：2</td>\n<td align=\"center\">w</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：001，八进制：1</td>\n<td align=\"center\">x</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：000，八进制：0</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p>在各类权限对应的数值之和，可以代表一组特定的权限。由于和的数值范围为 0~7，因此可以通过一个八进制数字表示。示例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数值</th>\n<th align=\"center\">权限</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">二进制：111，八进制：7</td>\n<td align=\"center\">rwx</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：110，八进制：6</td>\n<td align=\"center\">rw-</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：101，八进制：5</td>\n<td align=\"center\">r-x</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：000，八进制：0</td>\n<td align=\"center\">—</td>\n</tr>\n</tbody></table>\n<p>因此，用符号表示法表示的权限，同样可以使用数字表示法来表示，示例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号表示法</th>\n<th align=\"center\">数字表示法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-rwxrwxrwx</td>\n<td align=\"center\">0777</td>\n<td align=\"center\">一个普通文件，文件所有者，用户组，其他用户都有读，写，执行的权限</td>\n</tr>\n<tr>\n<td align=\"center\">-rwxrw-r–</td>\n<td align=\"center\">0764</td>\n<td align=\"center\">一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-2-1-3-分析源码中的权限设置\"><a href=\"#2-2-1-3-分析源码中的权限设置\" class=\"headerlink\" title=\"2.2.1.3 分析源码中的权限设置\"></a>2.2.1.3 分析源码中的权限设置</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Don&#x27;t expose the raw commandline to unprivileged processes.</span></span><br><span class=\"line\">CHECKCALL(chmod(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, <span class=\"number\">0440</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Don&#x27;t expose the raw bootconfig to unprivileged processes.</span></span><br><span class=\"line\">chmod(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, <span class=\"number\">0440</span>);</span><br></pre></td></tr></table></figure>\n<p>在源码中有两处使用到 <code>chmod</code> 命令，分别对文件 <code>/proc/cmdline</code>，<code>/proc/bootconfig</code> 设置了权限 <code>0440</code>，表明 root 用户 (文件所有者) 及其用户组也只有文件的读权限。</p>\n<h2 id=\"2-3-初始化-SELinux\"><a href=\"#2-3-初始化-SELinux\" class=\"headerlink\" title=\"2.3 初始化 SELinux\"></a>2.3 初始化 SELinux</h2><!-- TODO: 分析 SELinux -->\n\n<p>调用 <code>int SetupSelinux(char** argv)</code> 进行 SELinux 的初始化，该函数所在文件的路径为 <code>system/core/init/selinux.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This function initializes SELinux then execs init to run in the init SELinux context.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SetupSelinux</span><span class=\"params\">(<span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set up SELinux, loading the SELinux policy.</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 SELinux</span></span><br><span class=\"line\">    SelinuxSetupKernelLogging();</span><br><span class=\"line\">    SelinuxInitialize();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 /system/bin/init</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到传入的参数是 second_stage, 因此接下来会调用 SecondStageMain 函数进入启动的第二阶段 [2.4]</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;second_stage&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    execv(path, <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">char</span>**&gt;(args));</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数首先初始化了 SELinux，然后执行 <code>/system/bin/init</code>，重新进入 main 函数，通过传入参数 <code>&quot;second_stage&quot;</code>，进而调用 SecondStageMain 函数，进入启动的第二阶段。</p>\n<h2 id=\"2-4-启动的第二阶段\"><a href=\"#2-4-启动的第二阶段\" class=\"headerlink\" title=\"2.4 启动的第二阶段\"></a>2.4 启动的第二阶段</h2><!-- TODO: property_load_boot_defaults -->\n\n<!-- TODO: 在编译的过程中, android 的各种系统参数会被汇总到 build.prop 文件中？ -->\n\n<!-- TODO: SELinux 相关代码的分析 -->\n\n<!-- TODO: keyctl_get_keyring_ID(KEY_SPEC_SESSION_KEYRING, 1) -->\n\n<!-- TODO: InitializeSubcontext() -->\n\n<!-- TODO: ActionManager 和 ServiceList 的作用 -->\n\n<p>调用 <code>int SecondStageMain(int argc, char** argv)</code> 进入启动的第二阶段，函数所在文件的路径为 <code>system/core/init/init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set init and its forked children&#x27;s oom_adj.</span></span><br><span class=\"line\">    <span class=\"comment\">// 设置 init 进程以及由其 fork 得到的子进程 oom_score_adj 的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 数值越小, 进程优先级越高</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = WriteFile(<span class=\"string\">&quot;/proc/1/oom_score_adj&quot;</span>, <span class=\"string\">&quot;-1000&quot;</span>); !result) &#123;</span><br><span class=\"line\">        LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Unable to write -1000 to /proc/1/oom_score_adj: &quot;</span> &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化属性服务 [2.4.2.1]</span></span><br><span class=\"line\">    property_init();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 epoll [2.4.1.1]</span></span><br><span class=\"line\">    Epoll epoll;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Open(); !result) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用 epoll 对 init 子进程的信号进行监听 [2.4.3.1.3]</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化子进程退出的信号处理函数</span></span><br><span class=\"line\">    InstallSignalFdHandler(&amp;epoll);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 开启属性服务 [2.4.2.2]</span></span><br><span class=\"line\">    StartPropertyService(&amp;epoll);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class=\"line\">    ServiceList&amp; sm = ServiceList::GetInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 加载启动脚本 [2.4.4]</span></span><br><span class=\"line\">    LoadBootScripts(am, sm);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action [2.4.5.1]</span></span><br><span class=\"line\">    am.QueueBuiltinAction(SetupCgroupsAction, <span class=\"string\">&quot;SetupCgroups&quot;</span>);</span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;early-init&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class=\"string\">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    am.QueueBuiltinAction(queue_property_triggers_action, <span class=\"string\">&quot;queue_property_triggers&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进入无限循环状态 [2.4.5]</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> epoll_timeout = <span class=\"built_in\">std</span>::optional&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (do_shutdown &amp;&amp; !shutting_down) &#123;</span><br><span class=\"line\">            do_shutdown = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (HandlePowerctlMessage(shutdown_command)) &#123;</span><br><span class=\"line\">                shutting_down = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            am.ExecuteOneCommand();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!shutting_down) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> next_process_action_time = HandleProcessActions();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next_process_action_time) &#123;</span><br><span class=\"line\">                    epoll_timeout = <span class=\"built_in\">std</span>::chrono::<span class=\"built_in\">ceil</span>&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;(</span><br><span class=\"line\">                            *next_process_action_time - boot_clock::now());</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (*epoll_timeout &lt; <span class=\"number\">0</span>ms) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (am.HasMoreCommands()) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Wait(epoll_timeout); !result) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; result.error();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二阶段的工作可以大致分为 5 个部分：</p>\n<ul>\n<li><p>epoll</p>\n</li>\n<li><p>属性服务</p>\n</li>\n<li><p>信号</p>\n</li>\n<li><p>加载启动脚本</p>\n</li>\n<li><p>进入无限循环状态</p>\n</li>\n</ul>\n<p>接下来将分别对这 5 个部分的工作进行分析。</p>\n<h3 id=\"2-4-1-epoll\"><a href=\"#2-4-1-epoll\" class=\"headerlink\" title=\"2.4.1 epoll\"></a>2.4.1 epoll</h3><p>epoll 是 Linux 提供的 I/O 事件通知机制。epoll 可以监听大量的文件描述符，检查其中某一个文件描述符是否进入就绪状态。</p>\n<h4 id=\"2-4-1-1-初始化\"><a href=\"#2-4-1-1-初始化\" class=\"headerlink\" title=\"2.4.1.1 初始化\"></a>2.4.1.1 初始化</h4><p>在 init 进程中，epoll 通过以下代码初始化：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Epoll epoll;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Open(); !result) &#123;</span><br><span class=\"line\">    PLOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以知道，epoll 实例是通过调用 Open 函数创建的，函数所在文件的路径为 <code>system/core/init/epoll.cpp</code>，来分析这个函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::Open</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_fd_ &gt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关键点</span></span><br><span class=\"line\">    epoll_fd_.reset(epoll_create1(EPOLL_CLOEXEC));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_fd_ == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ErrnoError() &lt;&lt; <span class=\"string\">&quot;epoll_create1 failed&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数的关键点在于调用 <code>epoll_create1</code>。<code>epoll_create1</code> 是一个系统调用，其新建了一个 epoll 实例并返回该实例文件描述符。</p>\n<h4 id=\"2-4-1-2-使用-epoll-监听文件描述符\"><a href=\"#2-4-1-2-使用-epoll-监听文件描述符\" class=\"headerlink\" title=\"2.4.1.2 使用 epoll 监听文件描述符\"></a>2.4.1.2 使用 epoll 监听文件描述符</h4><p>要使用 epoll 监听文件描述符，需要调用 RegisterHandler 函数，将文件描述符注册到 epoll。</p>\n<p>函数所在文件的路径为 <code>system/core/init/epoll.cpp</code>，此函数的关键点在于系统调用 epoll_ctl：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::RegisterHandler</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; handler, <span class=\"keyword\">uint32_t</span> events)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关键点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &amp;ev) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先来看下 epoll_ctl 这个系统调用。</p>\n<h5 id=\"2-4-1-2-1-系统调用-epoll-ctl\"><a href=\"#2-4-1-2-1-系统调用-epoll-ctl\" class=\"headerlink\" title=\"2.4.1.2.1 系统调用 epoll_ctl\"></a>2.4.1.2.1 系统调用 epoll_ctl</h5><p><strong>epoll_ctl</strong> 是一个系统调用，函数原型为 <code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code>，用于对指定的文件描述符 fd 进行添加、修改或者删除操作。</p>\n<h6 id=\"2-4-1-2-1-1-参数\"><a href=\"#2-4-1-2-1-1-参数\" class=\"headerlink\" title=\"2.4.1.2.1.1 参数\"></a>2.4.1.2.1.1 参数</h6><p>首先来理解 epoll_ctl 的参数：</p>\n<ul>\n<li><p><strong>epfd</strong> 是 epoll 实例的文件描述符。</p>\n</li>\n<li><p><strong>op</strong> 表示要执行的操作，有三种取值：</p>\n<ul>\n<li><p><strong>EPOLL_CTL_ADD</strong></p>\n<p>添加指定的文件描述符到 epoll 的监控列表。</p>\n</li>\n<li><p><strong>EPOLL_CTL_MOD</strong></p>\n<p>修改 epoll 的监控列表中指定的文件描述符。</p>\n</li>\n<li><p><strong>EPOLL_CTL_DEL</strong></p>\n<p>从 epoll 的监控列表中删除指定的文件描述符。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>fd</strong> 表示指定的文件描述符。</p>\n</li>\n<li><p><strong>event</strong> 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，其定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">uint32_t</span>     events;      <span class=\"comment\">/* Epoll events */</span></span><br><span class=\"line\">   <span class=\"keyword\">epoll_data_t</span> data;        <span class=\"comment\">/* User data variable */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>结构体成员 <code>events</code> 用于表示要监听的事件，可以由零个或者多个事件类型组成，下面列出部分常见的事件类型：</p>\n<ul>\n<li><p>\u0015\u0015<strong>EPOLLIN</strong><br>表示关联的文件描述符可用于读操作。</p>\n</li>\n<li><p><strong>EPOLLOUT</strong><br>表示关联的文件描述符可用于写操作。</p>\n</li>\n<li><p><strong>EPOLLPRI</strong><br>表示关联的文件描述符出现异常情况。</p>\n</li>\n<li><p><strong>EPOLLERR</strong><br>表示关联的文件描述符出现错误。</p>\n</li>\n<li><p><strong>EPOLLHUP</strong><br>表示关联的文件描述符被挂断。</p>\n</li>\n<li><p><strong>EPOLLONESHOT</strong><br>表示只监听文件描述符的一次事件。当事件触发之后，epoll 就会禁用此文件描述符。<br>如果想要继续监听该文件描述符的事件，需要再次调用 epoll_ctl，并执行 EPOLL_CTL_MOD 操作。</p>\n</li>\n</ul>\n<p>结构体成员 <code>data</code> 的作用是将其数据交给内核保存，当文件描述符就绪后，内核会返回保存的数据 [2.4.1.3]。<code>epoll_data_t</code> 是一个共用体，其定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">epoll_data</span> &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span>        *ptr;</span><br><span class=\"line\">   <span class=\"keyword\">int</span>          fd;</span><br><span class=\"line\">   <span class=\"keyword\">uint32_t</span>     u32;</span><br><span class=\"line\">   <span class=\"keyword\">uint64_t</span>     u64;</span><br><span class=\"line\">&#125; <span class=\"keyword\">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h6 id=\"2-4-1-2-1-2-返回值\"><a href=\"#2-4-1-2-1-2-返回值\" class=\"headerlink\" title=\"2.4.1.2.1.2 返回值\"></a>2.4.1.2.1.2 返回值</h6><p>最后来了解 epoll_ctl 的返回值：</p>\n<ul>\n<li><p>当操作成功时，返回值为 0。</p>\n</li>\n<li><p>当发生错误时，返回值为 -1。</p>\n</li>\n</ul>\n<h5 id=\"2-4-1-2-2-分析-RegisterHandler-函数\"><a href=\"#2-4-1-2-2-分析-RegisterHandler-函数\" class=\"headerlink\" title=\"2.4.1.2.2 分析 RegisterHandler 函数\"></a>2.4.1.2.2 分析 RegisterHandler 函数</h5><p>在了解过系统调用 epoll_ctl 以后，现在开始分析 RegisterHandler 函数。首先来看函数在头文件中的声明，头文件的路径为 <code>system/core/init/epoll.h</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Epoll</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Result&lt;Success&gt; <span class=\"title\">RegisterHandler</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; handler,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                    <span class=\"keyword\">uint32_t</span> events = EPOLLIN)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>由函数原型可知，函数的第三个参数 <code>events</code> 有默认值 <code>EPOLLIN</code>，表示监听文件描述符的读操作是否可用。</p>\n<p>接下来分析 RegisterHandler 函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::RegisterHandler</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; handler, <span class=\"keyword\">uint32_t</span> events)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// handler 是事件触发时的回调函数</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> [it, inserted] = epoll_handlers_.emplace(fd, <span class=\"built_in\">std</span>::move(handler));</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    epoll_event ev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置要监听的事件类型</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于 events 有默认值 EPOLLIN, 因此默认监听的事件类型是读操作是否可用</span></span><br><span class=\"line\">    ev.events = events;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 设置回调函数, 回调函数会在事件触发后被调用 [2.4.1.3.2]</span></span><br><span class=\"line\">    ev.data.ptr = <span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"keyword\">void</span>*&gt;(&amp;it-&gt;second);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发起 epoll_ctl 系统调用</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到第二个参数传入的是 EPOLL_CTL_ADD, 因此对指定文件描述符执行的是添加操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &amp;ev) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        Result&lt;Success&gt; result = ErrnoError() &lt;&lt; <span class=\"string\">&quot;epoll_ctl failed to add fd&quot;</span>;</span><br><span class=\"line\">        epoll_handlers_.erase(fd);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过分析，可以知道函数的主要工作是：设置文件描述符需要监听的事件类型 <code>events</code> 以及事件触发时的回调函数 <code>handler</code>，最后发起 <code>epoll_ctl</code> 系统调用，将文件描述符添加到 epoll 监控列表。</p>\n<h4 id=\"2-4-1-3-等待事件触发\"><a href=\"#2-4-1-3-等待事件触发\" class=\"headerlink\" title=\"2.4.1.3 等待事件触发\"></a>2.4.1.3 等待事件触发</h4><p>经过 epoll 的初始化以及将文件描述符注册到 epoll 之后，接下来就需要等待事件触发，然后处理事件。</p>\n<p>在 init 进程启动的第二阶段，最后一个步骤就是进入死循环，不断地等待事件触发。接下来看下这段逻辑：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 关键点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Wait(epoll_timeout); !result) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; result.error();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段逻辑的关键点在于 Wait 函数，接下来分析这个函数。</p>\n<h5 id=\"2-4-1-3-1-系统调用-epoll-wait\"><a href=\"#2-4-1-3-1-系统调用-epoll-wait\" class=\"headerlink\" title=\"2.4.1.3.1 系统调用 epoll_wait\"></a>2.4.1.3.1 系统调用 epoll_wait</h5><p>在分析 Wait 函数之前，首先要了解系统调用 epoll_wait，这个系统调用是 Wait 函数的关键点。</p>\n<p><strong>epoll_wait</strong> 是一个系统调用，函数原型为 <code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code>，用于等待 epoll 上的事件。</p>\n<p>调用 epoll_wait 便会进入阻塞状态，直至满足以下任一条件，调用才会返回：</p>\n<ul>\n<li>监听的文件描述符传递一个事件；</li>\n<li>调用被信号处理程序中断；</li>\n<li>等待超出超时时长。</li>\n</ul>\n<h6 id=\"2-4-1-3-1-1-参数\"><a href=\"#2-4-1-3-1-1-参数\" class=\"headerlink\" title=\"2.4.1.3.1.1 参数\"></a>2.4.1.3.1.1 参数</h6><p>首先来理解 epoll_wait 的参数：</p>\n<ul>\n<li><p><strong>epfd</strong> 是 epoll 实例的文件描述符。</p>\n</li>\n<li><p><strong>events</strong> 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，在 [2.4.1.2.1] 一节已经详细介绍过。</p>\n<p>当事件触发后，调用就会返回，此时可以从 events 中得到已触发事件的集合。集合中每一个事件结构体 epoll_event 的 data 字段和调用 epoll_ctl 为相应的文件描述符设置的 data 字段是相同的。意味着，当事件触发后，之前调用 epoll_ctl 给指定文件描述符设置的 event.data 会通过这个参数返回给 epoll_wait 的调用者。</p>\n</li>\n<li><p><strong>maxevents</strong> 表示在一次调用中返回事件的最大数量。因此，从参数 events 中得到的事件数量不会大于 maxevents。</p>\n</li>\n<li><p><strong>timeout</strong> 是此次调用的超时时长。当 timeout = -1 时，调用将会一直阻塞，直到有事件发生；当 timeout = 0 时，调用会立即返回，即使当前没有事件发生。</p>\n</li>\n</ul>\n<h6 id=\"2-4-1-3-1-2-返回值\"><a href=\"#2-4-1-3-1-2-返回值\" class=\"headerlink\" title=\"2.4.1.3.1.2 返回值\"></a>2.4.1.3.1.2 返回值</h6><p>最后来了解 epoll_wait 的返回值：</p>\n<ul>\n<li><p>当调用成功时，返回值为已就绪的文件描述符的数量，此时可以对这些文件描述符进行 I/O 操作。</p>\n<p>需要注意的是，如果该调用是因为超出等待时长而返回的，则返回值为 0，表明没有已就绪的文件描述符。</p>\n</li>\n<li><p>当调用失败时，返回值为 -1，并返回错误信息。</p>\n</li>\n</ul>\n<h5 id=\"2-4-1-3-2-分析-Wait-函数\"><a href=\"#2-4-1-3-2-分析-Wait-函数\" class=\"headerlink\" title=\"2.4.1.3.2 分析 Wait 函数\"></a>2.4.1.3.2 分析 Wait 函数</h5><p>在了解过系统调用 epoll_wait 以后，就可以开始分析 Wait 函数，函数所在文件的路径为 <code>system/core/init/epoll.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::Wait</span><span class=\"params\">(<span class=\"built_in\">std</span>::optional&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt; timeout)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 超时时长默认值为 -1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> timeout_ms = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeout &amp;&amp; timeout-&gt;count() &lt; INT_MAX) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当参数 timeout 满足不等于 0 和数值没有溢出时, 更新超时时长</span></span><br><span class=\"line\">        timeout_ms = timeout-&gt;count();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    epoll_event ev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发起 epoll_wait 系统调用</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到第三个参数传入的是 1, 表明每次调用最多返回 1 个事件</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd_, &amp;ev, <span class=\"number\">1</span>, timeout_ms));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nr == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用返回 -1, 表明此次调用失败</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ErrnoError() &lt;&lt; <span class=\"string\">&quot;epoll_wait failed&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nr == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用返回 1, 表明此次调用成功, 有 1 个事件触发</span></span><br><span class=\"line\">        <span class=\"comment\">// ev.data.ptr 是之前调用 epoll_ctl 给指定文件描述符设置的回调函数, 因此事件最后交给回调函数进行处理</span></span><br><span class=\"line\">        <span class=\"built_in\">std</span>::invoke(*<span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt;*&gt;(ev.data.ptr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数设置了超时时长，然后发起 <code>epoll_wait</code> 系统调用，等待事件触发。当 <code>epoll_wait</code> 成功返回时，会从返回的数据里面取出之前通过 epoll_ctl 设置的回调函数，将事件交由回调函数处理。</p>\n<h3 id=\"2-4-2-属性服务\"><a href=\"#2-4-2-属性服务\" class=\"headerlink\" title=\"2.4.2 属性服务\"></a>2.4.2 属性服务</h3><p>属性服务是 Android 提供的一个用于存取系统属性的服务，属性以 key-value 的形式存储在一块共享内存，所有进程都可以通过这个服务获取和设置属性。</p>\n<p>使用 adb，输入命令 <code>getprop</code>，可以查看一台设备上的属性，下面列举其中的一些输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ro.product.brand]: [Redmi]</span><br><span class=\"line\">[ro.product.manufacturer]: [Xiaomi]</span><br><span class=\"line\">[ro.product.marketname]: [Redmi K30S Ultra]</span><br><span class=\"line\">[ro.product.model]: [M2007J3SC]</span><br><span class=\"line\">[ro.product.name]: [apollo]</span><br><span class=\"line\"></span><br><span class=\"line\">[ro.product.cpu.abi]: [arm64-v8a]</span><br><span class=\"line\">[ro.product.cpu.abilist]: [arm64-v8a,armeabi-v7a,armeabi]</span><br><span class=\"line\">[ro.product.cpu.abilist32]: [armeabi-v7a,armeabi]</span><br><span class=\"line\">[ro.product.cpu.abilist64]: [arm64-v8a]</span><br><span class=\"line\"></span><br><span class=\"line\">[dalvik.vm.heapsize]: [512m]</span><br><span class=\"line\">[dalvik.vm.heapstartsize]: [8m]</span><br></pre></td></tr></table></figure>\n<p>通过列举出的数据，可以看出属性里面包含了很多重要的信息：机型信息，CPU 架构，虚拟机分配的内存大小等等。</p>\n<p>在 Java 代码中，可以调用 <code>SystemProperties.get(String, String)</code> 方法获取系统属性。例如，在 ActivityManager 中就有这样的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">staticGetLargeMemoryClass</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过获取系统属性 dalvik.vm.heapsize, 得出应用可用堆内存的最大值</span></span><br><span class=\"line\">    String vmHeapSize = SystemProperties.get(<span class=\"string\">&quot;dalvik.vm.heapsize&quot;</span>, <span class=\"string\">&quot;16m&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.parseInt(vmHeapSize.substring(<span class=\"number\">0</span>, vmHeapSize.length() - <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似地，调用 <code>SystemProperties.set(String, String)</code> 方法可以设置系统属性。例如，在 ActivityManagerService 中就有这样的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">finishBooting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Tell anyone interested that we are done booting!</span></span><br><span class=\"line\">        <span class=\"comment\">// 通过设置属性 sys.boot_completed = 1, 标记系统已经启动完成</span></span><br><span class=\"line\">        SystemProperties.set(<span class=\"string\">&quot;sys.boot_completed&quot;</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"2-4-2-1-初始化\"><a href=\"#2-4-2-1-初始化\" class=\"headerlink\" title=\"2.4.2.1 初始化\"></a>2.4.2.1 初始化</h4><!-- TODO: 如何创建内存区域？ -->\n\n<!-- TODO: 进程是怎样获取共享内存中的属性？ -->\n\n<!-- TODO: 进程为什么不能直接设置共享内存中的属性？ -->\n\n<!-- TODO: CreateSerializedPropertyInfo() -->\n\n<!-- TODO: property_info_area.LoadDefaultPath() -->\n\n<p>属性服务初始化时，调用的是 property_init 函数，文件路径为 <code>system/core/init/property_service.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">property_init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mkdir(<span class=\"string\">&quot;/dev/__properties__&quot;</span>, S_IRWXU | S_IXGRP | S_IXOTH);</span><br><span class=\"line\">    CreateSerializedPropertyInfo();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建内存区域</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__system_property_area_init()) &#123;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;Failed to initialize property area&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!property_info_area.LoadDefaultPath()) &#123;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;Failed to load serialized property info file&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数最主要的工作是通过调用 <code>__system_property_area_init</code> 函数，创建用于存储属性的内存区域。</p>\n<h4 id=\"2-4-2-2-启动\"><a href=\"#2-4-2-2-启动\" class=\"headerlink\" title=\"2.4.2.2 启动\"></a>2.4.2.2 启动</h4><!-- TODO: socket 的创建过程 -->\n\n<!-- TODO: listen(property_set_fd, 8) -->\n\n<!-- TODO: 一个进程是怎样向 init 进程发起属性设置的请求？ -->\n\n<p>属性服务启动时，调用的是 StartPropertyService 函数，文件路径为 <code>system/core/init/property_service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StartPropertyService</span><span class=\"params\">(Epoll* epoll)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建 socket 并返回其文件描述符, 其中 PROP_SERVICE_NAME = &quot;property_service&quot;</span></span><br><span class=\"line\">    property_set_fd = CreateSocket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,</span><br><span class=\"line\">                                   <span class=\"literal\">false</span>, <span class=\"number\">0666</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (property_set_fd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; <span class=\"string\">&quot;start_property_service socket creation failed&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listen(property_set_fd, <span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将 socket 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]</span></span><br><span class=\"line\">    <span class=\"comment\">// handle_property_set_fd 是可读事件触发时的回调函数 [2.4.2.3]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll-&gt;RegisterHandler(property_set_fd, handle_property_set_fd); !result) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数首先创建名称为 property_service 的 socket，然后将 socket 文件描述符注册到 epoll，监听其可读事件。</p>\n<p>当可读事件触发时，会进入回调函数 <code>handle_property_set_fd</code>，接着来分析这个回调函数。</p>\n<h4 id=\"2-4-2-3-回调函数-handle-property-set-fd\"><a href=\"#2-4-2-3-回调函数-handle-property-set-fd\" class=\"headerlink\" title=\"2.4.2.3 回调函数 handle_property_set_fd\"></a>2.4.2.3 回调函数 handle_property_set_fd</h4><!-- TODO: ucred cr; socklen_t cr_size = sizeof(cr); -->\n\n<!-- TODO: 设置属性的具体实现 -->\n\n<!-- TODO: 除了通过向 init 进程发出请求设置属性以外, 在其他地方是否也有属性的设置？ -->\n\n<!-- TODO: 属性的同步问题 -->\n\n<p>函数所在文件的路径为 <code>system/core/init/property_service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handle_property_set_fd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2000ms</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">constexpr</span> <span class=\"keyword\">uint32_t</span> kDefaultSocketTimeout = <span class=\"number\">2000</span>; <span class=\"comment\">/* ms */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">SocketConnection <span class=\"title\">socket</span><span class=\"params\">(s, cr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置 2000ms 的超时时长</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> timeout_ms = kDefaultSocketTimeout;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> cmd = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!socket.RecvUint32(&amp;cmd, &amp;timeout_ms)) &#123;</span><br><span class=\"line\">        PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop: error while reading command from the socket&quot;</span>;</span><br><span class=\"line\">        socket.SendUint32(PROP_ERROR_READ_CMD);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (cmd) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理 PROP_MSG_SETPROP 命令</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> PROP_MSG_SETPROP: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// PROP_NAME_MAX = 32</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> prop_name[PROP_NAME_MAX];</span><br><span class=\"line\">        <span class=\"keyword\">char</span> prop_value[PROP_VALUE_MAX];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收属性名和属性值, 分别存储于字符数组 prop_name 和 prop_value 中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!socket.RecvChars(prop_name, PROP_NAME_MAX, &amp;timeout_ms) ||</span><br><span class=\"line\">            !socket.RecvChars(prop_value, PROP_VALUE_MAX, &amp;timeout_ms)) &#123;</span><br><span class=\"line\">          PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop(PROP_MSG_SETPROP): error while reading name/value from the socket&quot;</span>;</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将字符数组中最后的一个元素设置为 0</span></span><br><span class=\"line\">        prop_name[PROP_NAME_MAX<span class=\"number\">-1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        prop_value[PROP_VALUE_MAX<span class=\"number\">-1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; cr = socket.cred();</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> error;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置属性</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> result =</span><br><span class=\"line\">            HandlePropertySet(prop_name, prop_value, socket.source_context(), cr, &amp;error);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != PROP_SUCCESS) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Unable to set property &#x27;&quot;</span> &lt;&lt; prop_name &lt;&lt; <span class=\"string\">&quot;&#x27; to &#x27;&quot;</span> &lt;&lt; prop_value</span><br><span class=\"line\">                       &lt;&lt; <span class=\"string\">&quot;&#x27; from uid:&quot;</span> &lt;&lt; cr.uid &lt;&lt; <span class=\"string\">&quot; gid:&quot;</span> &lt;&lt; cr.gid &lt;&lt; <span class=\"string\">&quot; pid:&quot;</span> &lt;&lt; cr.pid &lt;&lt; <span class=\"string\">&quot;: &quot;</span></span><br><span class=\"line\">                       &lt;&lt; error;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 处理 PROP_MSG_SETPROP2 命令</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> PROP_MSG_SETPROP2: &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收字符串类型的属性名和属性值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!socket.RecvString(&amp;name, &amp;timeout_ms) ||</span><br><span class=\"line\">            !socket.RecvString(&amp;value, &amp;timeout_ms)) &#123;</span><br><span class=\"line\">          PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop(PROP_MSG_SETPROP2): error while reading name/value from the socket&quot;</span>;</span><br><span class=\"line\">          socket.SendUint32(PROP_ERROR_READ_DATA);</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; cr = socket.cred();</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> error;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置属性</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> result = HandlePropertySet(name, value, socket.source_context(), cr, &amp;error);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != PROP_SUCCESS) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Unable to set property &#x27;&quot;</span> &lt;&lt; name &lt;&lt; <span class=\"string\">&quot;&#x27; to &#x27;&quot;</span> &lt;&lt; value</span><br><span class=\"line\">                       &lt;&lt; <span class=\"string\">&quot;&#x27; from uid:&quot;</span> &lt;&lt; cr.uid &lt;&lt; <span class=\"string\">&quot; gid:&quot;</span> &lt;&lt; cr.gid &lt;&lt; <span class=\"string\">&quot; pid:&quot;</span> &lt;&lt; cr.pid &lt;&lt; <span class=\"string\">&quot;: &quot;</span></span><br><span class=\"line\">                       &lt;&lt; error;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        socket.SendUint32(result);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop: invalid command &quot;</span> &lt;&lt; cmd;</span><br><span class=\"line\">        socket.SendUint32(PROP_ERROR_INVALID_CMD);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数初始化了 socket 接收事件的超时时长，然后对接收到的 <code>cmd</code> 做相应的操作：</p>\n<ul>\n<li>对于 <code>PROP_MSG_SETPROP</code> 命令，使用两个长度为 <code>PROP_NAME_MAX</code> 的字符数组保存接收到的属性名和属性值。值得注意的是，最后会将字符数组中最后的一个元素设为 0，因此接收的属性名和属性值的最大长度不应超过 <code>PROP_NAME_MAX - 1</code> 。</li>\n<li>对于 <code>PROP_MSG_SETPROP2</code> 命令，使用两个 <code>std::string</code> 保存接收到的属性名和属性值。</li>\n</ul>\n<p>最后，不论是 <code>PROP_MSG_SETPROP</code> 命令还是 <code>PROP_MSG_SETPROP2</code> 命令，都会调用 <code>HandlePropertySet</code> 函数来设置属性。</p>\n<h3 id=\"2-4-3-信号\"><a href=\"#2-4-3-信号\" class=\"headerlink\" title=\"2.4.3 信号\"></a>2.4.3 信号</h3><p><strong>信号 (Signals)</strong> 属于 IPC 的一种方式，用于向一个进程或者进程中的特定线程发送事件通知。</p>\n<p>信号是一个<strong>异步的</strong>通信机制，一个进程可以不需要等待信号的到达。在信号未产生时，进程会正常执行；当信号产生后，系统可以中断目标进程的任何非原子操作，此时进程的正常执行流程会被中断，进而对信号进行处理。</p>\n<h4 id=\"2-4-3-1-处理信号\"><a href=\"#2-4-3-1-处理信号\" class=\"headerlink\" title=\"2.4.3.1 处理信号\"></a>2.4.3.1 处理信号</h4><p>在 Linux，一个子进程终结后，内核依然会为其维护关于此进程的最小信息集 (PID、终结状态、资源使用信息)，以便父进程获取有关子进程的信息。如果父进程没有为该子进程发起 wait、waitpid 或者 waitid 系统调用，那么子进程的信息就会一直占据着内核进程表的空间。在这种情况下，这个子进程就成为了一个**僵尸进程 (Zombie process)**。</p>\n<p>一般情况下，对于一个僵尸进程，如果其父进程终结了，那么 init 进程就会自动成为僵尸进程的父进程。此时，为了避免僵尸进程一直占据着系统资源，init 进程需要为僵尸进程释放占据的空间。</p>\n<p>而且，在加载启动脚本 [2.4.4] 这一步骤中，init 进程会 fork 得到一些子进程，例如：servicemanager 进程、zygote 进程。这些子进程对 Android 而言非常重要，在这些进程退出后，init 进程需要有相应的动作将其重启。</p>\n<p>于是，为了管理这些子进程，init 进程需要接收子进程终结的信号并进行相应的处理。</p>\n<p>在 Android，信号处理基于 Linux 的信号机制。</p>\n<h5 id=\"2-4-3-1-1-信号的处理方式\"><a href=\"#2-4-3-1-1-信号的处理方式\" class=\"headerlink\" title=\"2.4.3.1.1 信号的处理方式\"></a>2.4.3.1.1 信号的处理方式</h5><!-- 更正: 注册信号处理函数 -->\n\n<p>信号的处理方式有以下三种：</p>\n<ul>\n<li>\u0015\u0015<strong>忽略该信号</strong></li>\n<li><strong>按信号的默认行为处理该信号</strong></li>\n<li><strong>使用自定义的信号处理函数来处理该信号</strong></li>\n</ul>\n<p>init 进程使用的是第三种处理方式：使用自定义的信号处理函数来处理该信号。进程注册了一个信号处理函数，当目标信号产生时，信号会被捕获，并调用注册的函数进行处理。</p>\n<p>接下来分析这个过程。</p>\n<h5 id=\"2-4-3-1-2-系统调用-sigaction\"><a href=\"#2-4-3-1-2-系统调用-sigaction\" class=\"headerlink\" title=\"2.4.3.1.2 系统调用 sigaction\"></a>2.4.3.1.2 系统调用 sigaction</h5><p>在分析 init 进程注册函数的过程之前，首先来了解系统调用 sigaction，这个系统调用是此过程的一个关键点。</p>\n<p><strong>sigaction</strong> 是一个系统调用，函数原型为 <code>int sigaction(int signum, const struct sigaction *restrict act, struct sigaction *restrict oldact)</code>，用于更改进程在收到指定信号后的行为。</p>\n<h6 id=\"2-4-3-1-2-1-参数\"><a href=\"#2-4-3-1-2-1-参数\" class=\"headerlink\" title=\"2.4.3.1.2.1 参数\"></a>2.4.3.1.2.1 参数</h6><p>首先来理解 sigaction 的参数：</p>\n<ul>\n<li><p><strong>signum</strong> 是指定信号的编号。</p>\n<p>同一个信号在不同的架构上可能有不同的编号。在 Android，ARM 架构的信号编号定义在 <code>bionic/libc/kernel/uapi/asm-arm/asm/signal.h</code> 文件上。</p>\n</li>\n<li><p><strong>act</strong> 是一个 sigaction 类型的指针，而 sigaction 是一个结构体，其定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span>     (*sa_handler)(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">   <span class=\"keyword\">void</span>     (*sa_sigaction)(<span class=\"keyword\">int</span>, <span class=\"keyword\">siginfo_t</span> *, <span class=\"keyword\">void</span> *);</span><br><span class=\"line\">   <span class=\"keyword\">sigset_t</span>   sa_mask;</span><br><span class=\"line\">   <span class=\"keyword\">int</span>        sa_flags;</span><br><span class=\"line\">   <span class=\"keyword\">void</span>     (*sa_restorer)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>关注结构体中两个较为重要的成员 <code>sa_handler</code> 和 <code>sa_flags</code>。</p>\n<p>成员 <code>sa_handler</code> 用于指定信号产生时的行为，可以是以下这些值之一：</p>\n<ul>\n<li><p><strong>SIG_DFL</strong></p>\n<p>表示执行该信号的默认行为。</p>\n</li>\n<li><p><strong>SIG_IGN</strong></p>\n<p>表示忽略该信号。</p>\n</li>\n<li><p><strong>一个指向信号处理函数的指针</strong></p>\n<p>信号编号 signum 将作为函数的唯一参数传入。当目标信号产生时，会自动调用此函数进行处理。</p>\n</li>\n</ul>\n<p>成员 <code>sa_flags</code> 是标志位，可以由零个或者多个标志组成。下面列出其中的一些标志：</p>\n<ul>\n<li><p><strong>SA_NOCLDSTOP</strong></p>\n<p>只有当 signum = SIGCHLD 时才有意义。表示进程不接收子进程停止或者恢复时产生的信号，只接收子进程终结的信号。</p>\n</li>\n<li><p><strong>SA_RESETHAND</strong></p>\n<p>当信号已经由信号处理函数处理过后，将信号恢复为使用默认行为进行处理。</p>\n</li>\n<li><p><strong>SA_SIGINFO</strong></p>\n<p>不再通过结构体成员 sa_handler 设置信号处理函数，而是使用成员 sa_sigaction。此时，函数的入参有三个。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>oldact</strong> 同样是一个 sigaction 类型的指针，用于保存上一个 sigaction 调用所传入的参数 act，可以为空。</p>\n</li>\n</ul>\n<h6 id=\"2-4-3-1-2-2-返回值\"><a href=\"#2-4-3-1-2-2-返回值\" class=\"headerlink\" title=\"2.4.3.1.2.2 返回值\"></a>2.4.3.1.2.2 返回值</h6><p>最后来了解 sigaction 的返回值：</p>\n<ul>\n<li><p>当操作成功时，返回值为 0。</p>\n</li>\n<li><p>当发生错误时，返回值为 -1。</p>\n</li>\n</ul>\n<h5 id=\"2-4-3-1-3-init-进程注册信号处理函数\"><a href=\"#2-4-3-1-3-init-进程注册信号处理函数\" class=\"headerlink\" title=\"2.4.3.1.3 init 进程注册信号处理函数\"></a>2.4.3.1.3 init 进程注册信号处理函数</h5><p>在了解过系统调用 sigaction 以后，现在可以开始分析 init 进程注册信号处理函数的过程。</p>\n<h6 id=\"2-4-3-1-3-1-发起系统调用-sigaction\"><a href=\"#2-4-3-1-3-1-发起系统调用-sigaction\" class=\"headerlink\" title=\"2.4.3.1.3.1 发起系统调用 sigaction\"></a>2.4.3.1.3.1 发起系统调用 sigaction</h6><p>init 进程通过调用 InstallSignalFdHandler 函数实现注册信号处理函数，函数所在文件的路径为 <code>system/core/init/init.cpp</code>，首先来关注函数前半部分所做的工作：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">InstallSignalFdHandler</span><span class=\"params\">(Epoll* epoll)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建结构体 sigaction</span></span><br><span class=\"line\">    <span class=\"comment\">// 成员 sa_handler 用于指定信号产生时的行为, 令 sa_handler = SIG_DFL 表明当信号产生时按默认行为对信号进行处理</span></span><br><span class=\"line\">    <span class=\"comment\">// 成员 sa_flags 是标志位, 令 sa_flags = SA_NOCLDSTOP 表明 init 进程不接收子进程被中断或者被中断后恢复时产生的信号, 只接收子进程终结的信号</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> <span class=\"title\">act</span> &#123;</span> .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDSTOP &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// sigaction 是一个系统调用, 用于更改进程在收到指定的信号时所执行的操作 [2.4.3.1.2]</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到第一个参数传入的是 SIGCHLD, 表明目标信号是 SIGCHLD, 当子进程终结, 被中断, 或者被中断后恢复时, 就会产生此信号</span></span><br><span class=\"line\">    sigaction(SIGCHLD, &amp;act, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数前半部分所做的工作是：发起系统调用 sigaction，针对子进程产生的 <code>SIGCHLD</code> 信号，当进程在收到信号时，按默认行为对信号进行处理，而 <code>SIGCHLD</code> 信号的默认行为就是忽略该信号。</p>\n<p>值得注意的是，当子进程终结、被中断或者被中断后恢复时，都会产生 <code>SIGCHLD</code> 信号，而添加标志位 <code>SA_NOCLDSTOP</code> 可以使得 init 进程只接收子进程终结的信号。</p>\n<p>显然，在函数前半部分所做的工作中，并没有实现按自定义行为对信号进行处理。事实上，init 进程是通过监听 signal 文件描述符来实现按自定义行为来处理信号的。接下来分析 InstallSignalFdHandler 函数后半部分所做的工作。</p>\n<h6 id=\"2-4-3-1-3-2-监听-signal-文件描述符\"><a href=\"#2-4-3-1-3-2-监听-signal-文件描述符\" class=\"headerlink\" title=\"2.4.3.1.3.2 监听 signal 文件描述符\"></a>2.4.3.1.3.2 监听 signal 文件描述符</h6><p>之前提到，信号是一个异步的通信机制。进程可以注册一个信号处理函数，接着就能继续进行其他的工作，只有当目标信号发送到进程时，才回调处理函数进行处理，这里就体现出异步的性质。</p>\n<p>除了异步的方式以外，进程还可以通过同步的方式接收信号。Linux 提供了系统调用 signalfd，用于创建一个接收指定信号的文件描述符。对文件描述符执行读操作会进入阻塞状态，直到目标信号产生并传递给进程。</p>\n<p>init 进程就是通过这种方式来同步接收信号的，接下来分析这个过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">InstallSignalFdHandler</span><span class=\"params\">(Epoll* epoll)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// mask 是一个信号集, 用于指定想要接收的信号</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这里, 目标信号就是 SIGCHLD</span></span><br><span class=\"line\">    <span class=\"keyword\">sigset_t</span> mask;</span><br><span class=\"line\">    sigemptyset(&amp;mask);</span><br><span class=\"line\">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 signal 文件描述符</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到, 在发起系统调用 signalfd 时, 传入的第一个参数是 -1, 则调用会创建一个新的文件描述符</span></span><br><span class=\"line\">    signal_fd = signalfd(<span class=\"number\">-1</span>, &amp;mask, SFD_CLOEXEC);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (signal_fd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; <span class=\"string\">&quot;failed to create signalfd&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将 signal 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]</span></span><br><span class=\"line\">    <span class=\"comment\">// HandleSignalFd 是可读事件触发时的回调函数 [2.4.3.1.4]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll-&gt;RegisterHandler(signal_fd, HandleSignalFd); !result) &#123;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数后半部分所做的工作是：创建信号集，信号集里面包含了信号 <code>SIGCHLD</code>，然后新建一个与信号集关联的 signal 文件描述符，最后将文件描述符注册到 epoll。</p>\n<p>当 signal 文件描述符的可读事件触发时，就会调用 HandleSignalFd 函数，接下来分析这个函数。</p>\n<h5 id=\"2-4-3-1-4-回调函数-HandleSignalFd\"><a href=\"#2-4-3-1-4-回调函数-HandleSignalFd\" class=\"headerlink\" title=\"2.4.3.1.4 回调函数 HandleSignalFd\"></a>2.4.3.1.4 回调函数 HandleSignalFd</h5><p>函数所在文件的路径为 <code>system/core/init/init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">HandleSignalFd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    signalfd_siginfo siginfo;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从 signal 文件描述符中读取结构体 signalfd_siginfo, 每次读取一个</span></span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> bytes_read = TEMP_FAILURE_RETRY(read(signal_fd, &amp;siginfo, <span class=\"keyword\">sizeof</span>(siginfo)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bytes_read != <span class=\"keyword\">sizeof</span>(siginfo)) &#123;</span><br><span class=\"line\">        PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Failed to read siginfo from signal_fd&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据信号编号执行相应的操作</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (siginfo.ssi_signo) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SIGCHLD:</span><br><span class=\"line\">            ReapAnyOutstandingChildren();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SIGTERM:</span><br><span class=\"line\">            HandleSigtermSignal(siginfo);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;signal_fd: received unexpected signal &quot;</span> &lt;&lt; siginfo.ssi_signo;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当目标信号产生并传递给进程时，signal 文件描述符的可读事件就会触发，返回一个或者多个结构体 signalfd_siginfo。而函数 HandleSignalFd 负责从 signal 文件描述符中读出一个结构体 signalfd_siginfo，并根据信号编号执行相应的操作。</p>\n<p>在这里，我们关心的信号是 <code>SIGCHLD</code>。当此信号产生后，会调用 ReapAnyOutstandingChildren 函数，接着来分析这个函数。</p>\n<h6 id=\"2-4-3-1-4-1-分析-ReapAnyOutstandingChildren-函数\"><a href=\"#2-4-3-1-4-1-分析-ReapAnyOutstandingChildren-函数\" class=\"headerlink\" title=\"2.4.3.1.4.1 分析 ReapAnyOutstandingChildren 函数\"></a>2.4.3.1.4.1 分析 ReapAnyOutstandingChildren 函数</h6><p>函数所在文件的路径为 <code>system/core/init/sigchld_handler.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ReapAnyOutstandingChildren</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ReapOneProcess()) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数循环调用 ReapOneProcess 函数，只有当函数 ReapOneProcess 返回 false 时，循环才会停止。接着来看 ReapOneProcess 函数做了什么工作。</p>\n<h6 id=\"2-4-3-1-4-2-分析-ReapOneProcess-函数\"><a href=\"#2-4-3-1-4-2-分析-ReapOneProcess-函数\" class=\"headerlink\" title=\"2.4.3.1.4.2 分析 ReapOneProcess 函数\"></a>2.4.3.1.4.2 分析 ReapOneProcess 函数</h6><!-- TODO: 分析 service->flags() -->\n\n<!-- TODO: 分析 ServiceList::GetInstance().RemoveService(*service) -->\n\n<p>函数所在文件的路径为 <code>system/core/init/sigchld_handler.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">ReapOneProcess</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">siginfo_t</span> siginfo = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发起系统调用 waitid, 此系统调用用于获取子进程状态的变更和相关的信息</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于 init 进程只接收子进程终结的信号, 因此这里获取到的都是已进入僵尸状态的子进程的相关信息, 信息保存在 siginfo 当中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TEMP_FAILURE_RETRY(waitid(P_ALL, <span class=\"number\">0</span>, &amp;siginfo, WEXITED | WNOHANG | WNOWAIT)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 失败, 函数返回 false</span></span><br><span class=\"line\">        PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;waitid failed&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取子进程的 pid</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> pid = siginfo.si_pid;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 子进程的 pid 不存在, 函数返回 false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> wait_string;</span><br><span class=\"line\">    Service* service = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PropertyChildReap(pid)) &#123;</span><br><span class=\"line\">        name = <span class=\"string\">&quot;Async property child&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (SubcontextChildReap(pid)) &#123;</span><br><span class=\"line\">        name = <span class=\"string\">&quot;Subcontext&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据 pid 查询相应的 service</span></span><br><span class=\"line\">        service = ServiceList::GetInstance().FindService(pid, &amp;Service::pid);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (service) &#123;</span><br><span class=\"line\">            name = StringPrintf(<span class=\"string\">&quot;Service &#x27;%s&#x27; (pid %d)&quot;</span>, service-&gt;name().c_str(), pid);</span><br><span class=\"line\"></span><br><span class=\"line\">            ...</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            name = StringPrintf(<span class=\"string\">&quot;Untracked pid %d&quot;</span>, pid);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 没有找到对应的 service, 函数返回 true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!service) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用 service 的 Reap 函数</span></span><br><span class=\"line\">    service-&gt;Reap(siginfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经分析可知，ReapOneProcess 函数的主要工作是：为每个进入终结状态的子进程发起系统调用 waitid，从而避免已进入僵尸状态的子进程一直占据着系统资源。最后，函数会根据子进程 pid 查找是否存在相应的 service，如果 service 存在，还会调用 service 的 Reap 函数。接着来分析 Reap 函数。</p>\n<h6 id=\"2-4-3-1-4-3-分析-Reap-函数\"><a href=\"#2-4-3-1-4-3-分析-Reap-函数\" class=\"headerlink\" title=\"2.4.3.1.4.3 分析 Reap 函数\"></a>2.4.3.1.4.3 分析 Reap 函数</h6><p>函数所在文件的路径为 <code>system/core/init/service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Service::Reap</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">siginfo_t</span>&amp; siginfo)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(flags_ &amp; SVC_ONESHOT) || (flags_ &amp; SVC_RESTART)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果服务的标志位同时不带有 SVC_ONESHOT 和 SVC_RESTART, 则直接杀死服务所在的进程组</span></span><br><span class=\"line\">        KillProcessGroup(SIGKILL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果服务的标志位带有 SVC_TEMPORARY, 则直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags_ &amp; SVC_TEMPORARY) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重置状态</span></span><br><span class=\"line\">    pid_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    flags_ &amp;= (~SVC_RUNNING);</span><br><span class=\"line\">    start_order_ = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((flags_ &amp; SVC_ONESHOT) &amp;&amp; !(flags_ &amp; SVC_RESTART) &amp;&amp; !(flags_ &amp; SVC_RESET)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将带有 SVC_ONESHOT 的服务设为不可用状态</span></span><br><span class=\"line\">        flags_ |= SVC_DISABLED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags_ &amp; (SVC_DISABLED | SVC_RESET))  &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果服务的标志位带有 SVC_DISABLED 或者 SVC_RESET, 则使其进入 stopped 状态, 不会自动重启</span></span><br><span class=\"line\">        NotifyStateChange(<span class=\"string\">&quot;stopped&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 带有标志位 SVC_CRITICAL 的服务会被标记为系统关键服务</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果服务在 4 分钟之内崩溃 4 次以上, 又或者服务崩溃时系统处于未完全启动状态</span></span><br><span class=\"line\">    <span class=\"comment\">// 则设备会重启并进入 bootloader 或者设置崩溃相关的属性</span></span><br><span class=\"line\">    boot_clock::time_point now = boot_clock::now();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (((flags_ &amp; SVC_CRITICAL) || !pre_apexd_) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> boot_completed = android::base::GetBoolProperty(<span class=\"string\">&quot;sys.boot_completed&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now &lt; time_crashed_ + <span class=\"number\">4</span>min || !boot_completed) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++crash_count_ &gt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (flags_ &amp; SVC_CRITICAL) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Aborts into bootloader</span></span><br><span class=\"line\">                    LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;critical process &#x27;&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;&#x27; exited 4 times &quot;</span></span><br><span class=\"line\">                               &lt;&lt; (boot_completed ? <span class=\"string\">&quot;in 4 minutes&quot;</span> : <span class=\"string\">&quot;before boot completed&quot;</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;updatable process &#x27;&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;&#x27; exited 4 times &quot;</span></span><br><span class=\"line\">                               &lt;&lt; (boot_completed ? <span class=\"string\">&quot;in 4 minutes&quot;</span> : <span class=\"string\">&quot;before boot completed&quot;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// Notifies update_verifier and apexd</span></span><br><span class=\"line\">                    property_set(<span class=\"string\">&quot;ro.init.updatable_crashing&quot;</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            time_crashed_ = now;</span><br><span class=\"line\">            crash_count_ = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加标志位 SVC_RESTARTING, init 进程会重启带有此标志位的服务 [2.4.5.2]</span></span><br><span class=\"line\">    flags_ &amp;= (~SVC_RESTART);</span><br><span class=\"line\">    flags_ |= SVC_RESTARTING;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行当前 service 中所有 onrestart 命令</span></span><br><span class=\"line\">    onrestart_.ExecuteAllCommands();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使服务进入 restarting 状态</span></span><br><span class=\"line\">    NotifyStateChange(<span class=\"string\">&quot;restarting&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Reap 函数最主要的工作就是重启有需要的服务。注意到，改变服务状态是通过调用 NotifyStateChange 函数实现的，来看看这个函数。</p>\n<h6 id=\"2-4-3-1-4-4-分析-NotifyStateChange-函数\"><a href=\"#2-4-3-1-4-4-分析-NotifyStateChange-函数\" class=\"headerlink\" title=\"2.4.3.1.4.4 分析 NotifyStateChange 函数\"></a>2.4.3.1.4.4 分析 NotifyStateChange 函数</h6><p>函数所在文件的路径为 <code>system/core/init/service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Service::NotifyStateChange</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; new_state)</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((flags_ &amp; SVC_TEMPORARY) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果服务的标志位中带有 SVC_TEMPORARY, 则不会使用属性服务来记录它的状态</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用属性服务来记录服务当前的状态</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> prop_name = <span class=\"string\">&quot;init.svc.&quot;</span> + name_;</span><br><span class=\"line\">    property_set(prop_name, new_state);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过分析这个函数，可以知道，系统会使用属性服务以 key-value 的形式存储服务当前的状态，其中 key 的取值为 init.svc.[service_name]，value 是服务当前的状态。因此，可以使用 adb，输入命令 <code>getprop | grep init.svc.</code>，查看设备上 service 的运行状态，以下是其中的一些输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[init.svc.adbd]: [running]</span><br><span class=\"line\">[init.svc.alarm-hal-1-0]: [running]</span><br><span class=\"line\">[init.svc.android.thermal-hal]: [running]</span><br><span class=\"line\">[init.svc.apexd]: [stopped]</span><br><span class=\"line\">[init.svc.apexd-bootstrap]: [stopped]</span><br><span class=\"line\">[init.svc.apexd-snapshotde]: [stopped]</span><br><span class=\"line\">[init.svc.audioserver]: [running]</span><br><span class=\"line\">[init.svc.wifidisplayhalservice]: [running]</span><br><span class=\"line\">[init.svc.wpa_supplicant]: [running]</span><br><span class=\"line\">[init.svc.zygote]: [running]</span><br><span class=\"line\">[init.svc.zygote_secondary]: [running]</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-4-4-加载启动脚本\"><a href=\"#2-4-4-加载启动脚本\" class=\"headerlink\" title=\"2.4.4 加载启动脚本\"></a>2.4.4 加载启动脚本</h3><!-- TODO: 分析函数 CreateParser -->\n\n<!-- TODO: .rc 文件的解析过程 -->\n\n<!-- TODO: 属性的变更如何触发脚本中的属性触发器？ -->\n\n<!-- TODO: /system/etc/init -->\n\n<!-- TODO: /odm/etc/init -->\n\n<!-- TODO: /vendor/etc/init -->\n\n<p>调用 LoadBootScripts 函数加载启动脚本，函数所在文件的路径为 <code>system/core/init/init.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">LoadBootScripts</span><span class=\"params\">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class=\"line\">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootscript = GetProperty(<span class=\"string\">&quot;ro.boot.init_rc&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootscript.empty()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 加载 init.rc 脚本文件 [2.4.4.1]</span></span><br><span class=\"line\">        parser.ParseConfig(<span class=\"string\">&quot;/init.rc&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /system/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/system/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/system/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /product/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /product_services/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /odm/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/odm/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/odm/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /vendor/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        parser.ParseConfig(bootscript);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般情况下，此函数会去加载一些指定的脚本，其中：</p>\n<ul>\n<li><code>init.rc</code> 是主要的 .rc 文件。</li>\n<li><code>/system/etc/init/</code> 包含了核心的系统项目，例如：SurfaceFlinger, MediaService, logcatd。</li>\n<li><code>/vendor/etc/init/</code> 包含了 SoC 供应商项目，例如：核心 SoC 功能所需的操作或守护进程。</li>\n<li><code>/odm/etc/init/</code> 包含了设备制造商项目，例如：运动传感器或其他外围设备所需的操作或守护进程。</li>\n</ul>\n<p>init.rc 是最主要脚本文件，接下来将对这个脚本进行分析。</p>\n<h4 id=\"2-4-4-1-init-rc-脚本\"><a href=\"#2-4-4-1-init-rc-脚本\" class=\"headerlink\" title=\"2.4.4.1 init.rc 脚本\"></a>2.4.4.1 init.rc 脚本</h4><p>在 Android，后缀为 .rc 的文件由 Android Init Language 编写，<a href=\"https://cs.android.com/android/platform/superproject/+/android-security-10.0.0_r56:system/core/init/README.md\">关于 Android Init Language 的详细说明</a> 可以在 AOSP 上找到，路径为 <code>system/core/init/README.md</code>。</p>\n<p>在分析脚本之前，首先来了解这种语言的语法。</p>\n<h5 id=\"2-4-4-1-1-Android-Init-Language\"><a href=\"#2-4-4-1-1-Android-Init-Language\" class=\"headerlink\" title=\"2.4.4.1.1 Android Init Language\"></a>2.4.4.1.1 Android Init Language</h5><p>Android Init Language 由五大类表达式组成：<code>Actions</code>，<code>Commands</code>，<code>Services</code>，<code>Options</code>，<code>Imports</code>。</p>\n<p>其语法规则有：</p>\n<ul>\n<li>每一行都是一条语句，一条语句由多个 token 组成，token 之间以空格分开。</li>\n<li>如果一个 token 包含了空格，可以跟 c 语言类似，使用反斜杠 <code>\\</code> 作为转义字符，又或者使用双引号包裹整个 token。</li>\n<li>在行的末尾使用反斜杠 <code>\\</code>，可以将语句换行。</li>\n<li>以符号 <code>#</code> 开头的行是注释行。</li>\n<li>系统属性的值可以通过语法 <code>$&#123;property.name&#125;</code> 获取，例如：<code>import /init.recovery.$&#123;ro.hardware&#125;.rc</code>。</li>\n<li>一个文件可以分为多个 section，必须使用 <code>Actions</code> 或者 <code>Services</code> 来声明一个新的 section。所有的 <code>Commands</code> 和 <code>Options</code> 都是属于最近声明的那一个 section。如果在一个 section 之前声明了 <code>Commands</code> 或者 <code>Options</code> ，则声明会被忽略。</li>\n<li><code>Services</code> 的名称必须是唯一的，如果存在多个重名的 <code>Services</code> ，除了第一个以外，其他的都会被忽略，并且会输出错误日志。</li>\n</ul>\n<p>接下来列出一些较为重要的表达式。</p>\n<h6 id=\"2-4-4-1-1-1-Actions\"><a href=\"#2-4-4-1-1-1-Actions\" class=\"headerlink\" title=\"2.4.4.1.1.1 Actions\"></a>2.4.4.1.1.1 Actions</h6><p><code>Actions</code> 由 一系列 <code>Commands</code> 组成，同时 <code>Triggers</code> 决定了 <code>Actions</code> 的触发时机，其形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]*</span><br><span class=\"line\">   &lt;command&gt;</span><br><span class=\"line\">   &lt;command&gt;</span><br><span class=\"line\">   &lt;command&gt;</span><br></pre></td></tr></table></figure>\n<p>当一个事件触发后，如果此事件能够匹配上 <code>Actions</code> 的  <code>Triggers</code>，那么 <code>Actions</code> 会被添加到待执行队列的尾部。</p>\n<p>之后，待执行队列中的 <code>Actions</code> 会按照加入顺序出队，并且执行该 <code>Actions</code> 中的 <code>Commands</code>。</p>\n<p>以启动 Zygote 作为示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br></pre></td></tr></table></figure>\n<p>简单分析这个脚本：</p>\n<p>这个 <code>Actions</code> 拥有两个 <code>Triggers</code>，分别是 <code>zygote-start</code> 和 <code>property:ro.crypto.state=unencrypted</code>，从第二行开始，每一行都是一个 <code>Command</code>。</p>\n<p>当事件 <code>zygote-start</code> 和 <code>property:ro.crypto.state=unencrypted</code> 触发后，<code>Actions</code> 会被加入到待执行队列。在执行到该 <code>Actions</code> 时，会按照 <code>Commands</code> 定义的先后顺序，依次执行 <code>Actions</code> 中的 <code>Commands</code>。</p>\n<h6 id=\"2-4-4-1-1-2-Triggers\"><a href=\"#2-4-4-1-1-2-Triggers\" class=\"headerlink\" title=\"2.4.4.1.1.2 Triggers\"></a>2.4.4.1.1.2 Triggers</h6><p><code>Triggers</code> 是字符串，用于匹配某些类型的事件并触发 <code>Actions</code> 中的 <code>Commands</code>。</p>\n<p>Triggers 可以分为两类：</p>\n<ul>\n<li><p><strong>Event triggers</strong></p>\n<p>事件触发器，这类触发器所匹配的事件由命令 <code>trigger</code>  触发，又或者通过调用 <code>QueueEventTrigger()</code> 函数触发。</p>\n</li>\n<li><p><strong>Property triggers</strong></p>\n<p>属性触发器，这类触发器所匹配的事件是：属性是否满足某个值，形式为 <code>property:&lt;key&gt;=&lt;value&gt;</code>。这里的属性就是之前提到的属性服务管理的属性。</p>\n</li>\n</ul>\n<p>注意，每一个 <code>Actions</code> 可以有多个属性触发器，但只能有一个事件触发器。</p>\n<p>例如：</p>\n<p><code>on init &amp;&amp; property:a=b</code>，<code>on property:a=b &amp;&amp; property:c=d</code> 是合法的。</p>\n<p><code>on boot &amp;&amp; on init</code> 是不合法的。</p>\n<h6 id=\"2-4-4-1-1-3-Commands\"><a href=\"#2-4-4-1-1-3-Commands\" class=\"headerlink\" title=\"2.4.4.1.1.3 Commands\"></a>2.4.4.1.1.3 Commands</h6><p>下面列举一些常见的 <code>Commands</code>：</p>\n<ul>\n<li><p><strong>trigger <event></strong></p>\n<p>触发一个事件。</p>\n</li>\n<li><p><strong>write <path> <content></strong></p>\n<p>按 path 打开文件，往文件中写入内容。</p>\n</li>\n<li><p><strong>chown <owner> <group> <path></strong></p>\n<p>更改文件所有者和组。</p>\n</li>\n<li><p><strong>mkdir <path> [mode] [owner] [group]</strong></p>\n<p>在路径上创建一个目录，可以选择使用给定的权限，所有者，用户组。 </p>\n<p>如果未指定权限，所有者，用户组，则新建的目录默认具有权限 755，并由 root 用户和 root 组拥有。</p>\n<p>当指定权限，所有者，用户组时，如果目录已经存在，则权限，所有者，用户组将被更新。</p>\n</li>\n<li><p><strong>start <service></strong></p>\n<p>当指定的服务未在运行时，启动该服务。</p>\n</li>\n<li><p><strong>exec_start <service></strong></p>\n<p>启动指定的服务，在该命令返回之前暂停处理其他命令。</p>\n</li>\n<li><p><strong>setprop <name> <value></strong></p>\n<p>给系统属性赋值，这里的属性是之前提到的属性服务中的属性。</p>\n</li>\n<li><p><strong>symlink <target> <path></strong></p>\n<p>在 path 上创建一个连接到 target 的符号链接。</p>\n</li>\n</ul>\n<h6 id=\"2-4-4-1-1-4-Services\"><a href=\"#2-4-4-1-1-4-Services\" class=\"headerlink\" title=\"2.4.4.1.1.4 Services\"></a>2.4.4.1.1.4 Services</h6><p><code>Services</code> 是由 init 进程启动的程序，一般运行在 init 进程的一个子进程，因此 init 进程在启动一个 <code>Services</code> 时会通过 fork 的方式生成子进程。</p>\n<p>默认情况下，<code>Services</code> 退出后会重启。</p>\n<p><code>Services</code> 的形式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class=\"line\">   &lt;option&gt;</span><br><span class=\"line\">   &lt;option&gt;</span><br><span class=\"line\">   ...</span><br></pre></td></tr></table></figure>\n<p>以启动 Zygote 64 位进程的脚本作为示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class=\"line\">    class main</span><br><span class=\"line\">    priority -20</span><br><span class=\"line\">    user root</span><br><span class=\"line\">    group root readproc reserved_disk</span><br><span class=\"line\">    socket zygote stream 660 root system</span><br><span class=\"line\">    socket usap_pool_primary stream 660 root system</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class=\"line\">    onrestart restart audioserver</span><br><span class=\"line\">    onrestart restart cameraserver</span><br><span class=\"line\">    onrestart restart media</span><br><span class=\"line\">    onrestart restart netd</span><br><span class=\"line\">    onrestart restart wificond</span><br><span class=\"line\">    writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br></pre></td></tr></table></figure>\n<p>简单分析这个脚本：<code>zygote</code> 是 <code>Services</code> 的名称，<code>/system/bin/app_process64</code> 是可执行文件的路径，<code>-Xzygote /system/bin --zygote --start-system-server</code> 是启动参数，从第二行开始，每一行都是一个 <code>Options</code>。</p>\n<h6 id=\"2-4-4-1-1-5-Options\"><a href=\"#2-4-4-1-1-5-Options\" class=\"headerlink\" title=\"2.4.4.1.1.5 Options\"></a>2.4.4.1.1.5 Options</h6><p><code>Options</code> 是 <code>Services</code> 的配置项，用于控制 init 进程运行 <code>Services</code> 的方式和时间。</p>\n<p> 下面列举一些常见的 <code>Options</code>：</p>\n<ul>\n<li><p><strong>class <name> [ <name>* ]</strong></p>\n<p>指定 <code>Services</code> 的类名。当 <code>Services</code> 所属类开启 (退出) 时，<code>Services</code> 也会开启 (退出) 。默认值为 default。</p>\n</li>\n<li><p><strong>class_start <serviceclass></strong></p>\n<p>启动所有未在运行的，类名被指定为 <code>serviceclass</code> 的 <code>Services</code>。</p>\n</li>\n<li><p><strong>priority <priority></strong></p>\n<p>设置 <code>Services</code> 进程的优先级。取值范围是 -20 ~ 19。默认值为 0。</p>\n</li>\n<li><p><strong>user <username></strong></p>\n<p>设置执行 <code>Services</code> 的用户。一般情况下，默认值为 root。</p>\n</li>\n<li><p><strong>group <groupname> [ <groupname>* ]</strong></p>\n<p>设置执行 <code>Services</code> 的用户组。一般情况下，默认值为 root。</p>\n</li>\n<li><p><strong>socket <name> <type> <perm> [ <user> [ <group> [ <seclabel> ] ] ]</strong></p>\n<p>创建一个 unix 域的 socket，命名为 <code>/dev/socket/&lt;name&gt;</code>，并将 socket 的文件描述符传递给创建的进程。</p>\n</li>\n<li><p><strong>onrestart</strong></p>\n<p>当 <code>Services</code> 重启时执行一个 <code>Commands</code>。</p>\n</li>\n<li><p><strong>oneshot</strong></p>\n<p>当 <code>Services</code> 退出后不再重启。</p>\n</li>\n<li><p><strong>writepid <file> [ <file>* ]</strong></p>\n<p>在进程 fork 之后，将子进程的 pid 写入指定的文件。</p>\n</li>\n</ul>\n<h5 id=\"2-4-4-1-2-加载-init-rc-脚本\"><a href=\"#2-4-4-1-2-加载-init-rc-脚本\" class=\"headerlink\" title=\"2.4.4.1.2 加载 init.rc 脚本\"></a>2.4.4.1.2 加载 init.rc 脚本</h5><p>脚本文件 init.rc 负责系统的初始设置，文件的路径为 <code>system/core/rootdir/init.rc</code>。</p>\n<p>在了解到脚本的编写语法之后，可以知道脚本的内容都是由  <code>Actions</code> 和 <code>Services</code> 构成的，而在 init.rc 脚本中绝大部分都是 <code>Actions</code>。在 [2.4.4.1.1.2] 中曾经提到，调用 <code>QueueEventTrigger()</code> 函数可以触发一个事件，当事件匹配上  <code>Actions</code> 的  <code>Triggers</code>，就会开始执行该 <code>Actions</code>。 接下来回到进程启动的第二阶段，寻找事件的触发点。</p>\n<h6 id=\"2-4-4-1-2-1-源码中事件的触发点\"><a href=\"#2-4-4-1-2-1-源码中事件的触发点\" class=\"headerlink\" title=\"2.4.4.1.2.1 源码中事件的触发点\"></a>2.4.4.1.2.1 源码中事件的触发点</h6><p>回到 init 进程启动的第二阶段，对应源代码 <code>system/core/init/init.cpp</code> 的 SecondStageMain 函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将触发事件 early-init 的操作加入到 ActionManager</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;early-init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Trigger all the boot actions to get us started.</span></span><br><span class=\"line\">    <span class=\"comment\">// 将触发事件 init 的操作加入到 ActionManager</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t mount filesystems or start core system services in charger mode.</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootmode = GetProperty(<span class=\"string\">&quot;ro.bootmode&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootmode == <span class=\"string\">&quot;charger&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前处于充电模式, 则将触发事件 charger 的操作加入到 ActionManager</span></span><br><span class=\"line\">        <span class=\"comment\">// 在充电模式下, 不会挂载文件系统和启动核心系统服务</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;charger&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前处于非充电模式, 则将触发事件 late-init 的操作加入到 ActionManager</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;late-init&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ActionManager 会按操作加入的顺序逐一执行 [2.4.5.x]，由此可知事件的触发顺序：</p>\n<ul>\n<li>非充电模式：early-init -&gt; init -&gt; late-init</li>\n<li>充电模式：early-init -&gt; init -&gt; charger</li>\n</ul>\n<p>由于在充电模式下，系统可能未完全启动，接下来将选取非充电模式下的流程进行分析。</p>\n<h6 id=\"2-4-4-1-2-2-init-rc-脚本的执行过程\"><a href=\"#2-4-4-1-2-2-init-rc-脚本的执行过程\" class=\"headerlink\" title=\"2.4.4.1.2.2 init.rc 脚本的执行过程\"></a>2.4.4.1.2.2 init.rc 脚本的执行过程</h6><!-- TODO: trigger boot -->\n\n<p>现在结合事件的触发顺序，分析脚本执行过程中的一些关键点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on early-init</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    # 以 start 方式启动 ueventd</span><br><span class=\"line\">    start ueventd</span><br><span class=\"line\"></span><br><span class=\"line\">    # 以 exec_start 方式运行 apexd-bootstrap, 在该命令返回之前暂停处理其他命令, 从而保证后续流程中 APEX 的可用性</span><br><span class=\"line\">    exec_start apexd-bootstrap</span><br><span class=\"line\"></span><br><span class=\"line\">on init</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    # 以 start 方式启动基本服务</span><br><span class=\"line\">    # 启动 servicemanager [2.4.4.1.2.3]</span><br><span class=\"line\">    start servicemanager</span><br><span class=\"line\">    start hwservicemanager</span><br><span class=\"line\">    start vndservicemanager</span><br><span class=\"line\"></span><br><span class=\"line\"># 挂载文件和启动核心系统服务</span><br><span class=\"line\"># 其中 trigger 用于触发一个事件 [2.4.4.1.1.2]</span><br><span class=\"line\">on late-init</span><br><span class=\"line\">    trigger early-fs</span><br><span class=\"line\">    trigger fs</span><br><span class=\"line\">    trigger post-fs</span><br><span class=\"line\">    trigger late-fs</span><br><span class=\"line\">    trigger post-fs-data</span><br><span class=\"line\">    trigger load_persist_props_action</span><br><span class=\"line\"></span><br><span class=\"line\">    # 触发事件 zygote-start, 启动 zygote [2.4.4.1.2.4]</span><br><span class=\"line\">    trigger zygote-start</span><br><span class=\"line\"></span><br><span class=\"line\">    trigger firmware_mounts_complete</span><br><span class=\"line\">    trigger early-boot</span><br><span class=\"line\">    trigger boot</span><br></pre></td></tr></table></figure>\n<p>经过分析，现在已经大致了解脚本的执行过程，接下来分析 servicemanager 和 zygote 的启动。</p>\n<h6 id=\"2-4-4-1-2-3-启动-servicemanager\"><a href=\"#2-4-4-1-2-3-启动-servicemanager\" class=\"headerlink\" title=\"2.4.4.1.2.3 启动 servicemanager\"></a>2.4.4.1.2.3 启动 servicemanager</h6><p>servicemanager 启动脚本的路径为 <code>frameworks/native/cmds/servicemanager/servicemanager.rc</code>，分析这个脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># servicemanager 是 Services 的名称</span><br><span class=\"line\"># &#x2F;system&#x2F;bin&#x2F;servicemanager 是可执行文件的路径</span><br><span class=\"line\">service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager</span><br><span class=\"line\">    # 指定类名为 core 和 animation</span><br><span class=\"line\">    # 当 core 或者 animation 开启 (关闭) 时, servicemanager 也将开启 (关闭)</span><br><span class=\"line\">    class core animation</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置用户为 system</span><br><span class=\"line\">    user system</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置用户组为 system 和 readproc</span><br><span class=\"line\">    group system readproc</span><br><span class=\"line\"></span><br><span class=\"line\">    # 将其标记为设备的关键服务</span><br><span class=\"line\">    # 如果此服务在规定时间内不断重启, 则设备会重启并进入 bootloader</span><br><span class=\"line\">    critical</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置服务重启后执行的操作</span><br><span class=\"line\">    # 每一个操作都是一个 Commands</span><br><span class=\"line\">    onrestart restart healthd</span><br><span class=\"line\">    onrestart restart zygote</span><br><span class=\"line\">    onrestart restart audioserver</span><br><span class=\"line\">    onrestart restart media</span><br><span class=\"line\">    onrestart restart surfaceflinger</span><br><span class=\"line\">    onrestart restart inputflinger</span><br><span class=\"line\">    onrestart restart drm</span><br><span class=\"line\">    onrestart restart cameraserver</span><br><span class=\"line\">    onrestart restart keystore</span><br><span class=\"line\">    onrestart restart gatekeeperd</span><br><span class=\"line\">    onrestart restart thermalservice</span><br><span class=\"line\"></span><br><span class=\"line\">    # 在进程执行 fork 操作之后，将子进程的 pid 写入文件 &#x2F;dev&#x2F;cpuset&#x2F;system-background&#x2F;tasks</span><br><span class=\"line\">    writepid &#x2F;dev&#x2F;cpuset&#x2F;system-background&#x2F;tasks</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置服务的关闭行为</span><br><span class=\"line\">    # shutdown critical 表示此服务在关闭期间不会被杀死, 当关闭超时后才会被杀死</span><br><span class=\"line\">    shutdown critical</span><br></pre></td></tr></table></figure>\n<p>启动 servicemanager 之后，便会进入 <code>frameworks/native/cmds/servicemanager/service_manager.c</code> 的 main 函数。</p>\n<h6 id=\"2-4-4-1-2-4-启动-zygote\"><a href=\"#2-4-4-1-2-4-启动-zygote\" class=\"headerlink\" title=\"2.4.4.1.2.4 启动 zygote\"></a>2.4.4.1.2.4 启动 zygote</h6><p>在 init.rc 脚本中，事件 <code>zygote-start</code> 有 3 个对应的 <code>Actions</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br><span class=\"line\"></span><br><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unsupported</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br><span class=\"line\"></span><br><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;encrypted &amp;&amp; property:ro.crypto.type&#x3D;file</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br></pre></td></tr></table></figure>\n<p>其中，zygote 通过以下语句导入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#x2F;init.$&#123;ro.zygote&#125;.rc</span><br></pre></td></tr></table></figure>\n<p>此语句会根据属性 <code>ro.zygote</code>，导入相应的文件，其中包括：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote32.rc</span><br><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote32_64.rc</span><br><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote64.rc</span><br><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote64_32.rc</span><br></pre></td></tr></table></figure>\n<p>zygote 的启动除了依赖事件 <code>zygote-start</code> 以外，还需要某些属性满足特定的值。当上面列出的三个 <code>Actions</code> 中的其中一个满足条件后，便会启动 zygote。</p>\n<p>这里分析启动 Zygote 64 位进程的脚本，脚本文件的路径为 <code>system/core/rootdir/init.zygote64.rc</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># zygote 是 Services 的名称</span><br><span class=\"line\"># &#x2F;system&#x2F;bin&#x2F;app_process64 是可执行文件的路径</span><br><span class=\"line\"># -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server 是启动参数</span><br><span class=\"line\">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class=\"line\">    # 指定类名为 main</span><br><span class=\"line\">    # 当 main 开启 (关闭) 时, zygote 也将开启 (关闭)</span><br><span class=\"line\">    class main</span><br><span class=\"line\"></span><br><span class=\"line\">    # 进程优先级为 -20</span><br><span class=\"line\">    # 由于优先级的取值范围是 -20 ~ 19, 数值越小, 优先级越高, 因此 zygote 进程拥有最高的优先级</span><br><span class=\"line\">    priority -20</span><br><span class=\"line\"></span><br><span class=\"line\">    # 用户和用户组都是 root</span><br><span class=\"line\">    user root</span><br><span class=\"line\">    group root readproc reserved_disk</span><br><span class=\"line\"></span><br><span class=\"line\">    # 创建 socket</span><br><span class=\"line\">    socket zygote stream 660 root system</span><br><span class=\"line\">    socket usap_pool_primary stream 660 root system</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置服务重启后执行的操作</span><br><span class=\"line\">    # 每一个操作都是一个 Commands</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class=\"line\">    onrestart restart audioserver</span><br><span class=\"line\">    onrestart restart cameraserver</span><br><span class=\"line\">    onrestart restart media</span><br><span class=\"line\">    onrestart restart netd</span><br><span class=\"line\">    onrestart restart wificond</span><br><span class=\"line\"></span><br><span class=\"line\">    # 在 zygote 进程执行 fork 操作之后，将子进程的 pid 写入文件 &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br><span class=\"line\">    writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br></pre></td></tr></table></figure>\n<p>启动 zygote 之后，便会进入 <code>frameworks/base/cmds/app_process/app_main.cpp</code> 的 main 函数。</p>\n<h3 id=\"2-4-5-进入无限循环状态\"><a href=\"#2-4-5-进入无限循环状态\" class=\"headerlink\" title=\"2.4.5 进入无限循环状态\"></a>2.4.5 进入无限循环状态</h3><p>init 进程启动完成之后，进程就会一直存活，而保持存活的方法就是进入无限循环状态。接下来分析这个过程，源代码的路径为 <code>system/core/init/init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置等待 epoll 事件的超时时长</span></span><br><span class=\"line\">        <span class=\"comment\">// 默认情况下会一直处于阻塞状态, 直到有事件发生, 此时 epoll_timeout 取值为 -1</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> epoll_timeout = <span class=\"built_in\">std</span>::optional&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// am 是一个引用, 指向 ActionManager 实例</span></span><br><span class=\"line\">            <span class=\"comment\">// 按顺序执行 ActionManager 中的一个命令 [2.4.5.1]</span></span><br><span class=\"line\">            am.ExecuteOneCommand();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!shutting_down) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取下一次 HandleProcessActions 的时间点 [2.4.5.2]</span></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> next_process_action_time = HandleProcessActions();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next_process_action_time) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 计算出 next_process_action_time 与当前时间的差值</span></span><br><span class=\"line\">                    epoll_timeout = <span class=\"built_in\">std</span>::chrono::<span class=\"built_in\">ceil</span>&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;(</span><br><span class=\"line\">                            *next_process_action_time - boot_clock::now());</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 如果差值小于 0, 说明需要立即进行下一次的循环</span></span><br><span class=\"line\">                    <span class=\"comment\">// 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (*epoll_timeout &lt; <span class=\"number\">0</span>ms) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果 ActionManager 中仍有待执行的命令, 那么 init 进程不会进入阻塞状态, 并立即再次唤起</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (am.HasMoreCommands()) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 Wait 函数, 等待事件触发 [2.4.1.3]</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Wait(epoll_timeout); !result) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; result.error();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经分析可知，init 进程进入循环状态后主要的工作有 3 个：</p>\n<ul>\n<li>执行 ActionManager 中的命令。</li>\n<li>重启服务。</li>\n<li>等待 epoll 事件，当事件触发后，调用相应的函数进行处理。结合前面的分析，可知等待的事件有：一个进程通过请求 init 进程向属性服务写入属性，以及 init 进程接收到 <code>SIGCHLD</code> 信号。</li>\n</ul>\n<h4 id=\"2-4-5-1-ActionManager\"><a href=\"#2-4-5-1-ActionManager\" class=\"headerlink\" title=\"2.4.5.1 ActionManager\"></a>2.4.5.1 ActionManager</h4><!-- TODO: 什么是 Action? -->\n\n<!-- TODO: Action 和脚本中的 Actions 有没有关系 -->\n\n<!-- TODO: 添加和执行过程 -->\n\n<p>ActionManager 是 Action 的管理器，它提供了对 Action 的添加、执行、清空等操作。</p>\n<h5 id=\"2-4-5-1-1-添加-Action\"><a href=\"#2-4-5-1-1-添加-Action\" class=\"headerlink\" title=\"2.4.5.1.1 添加 Action\"></a>2.4.5.1.1 添加 Action</h5><!-- TODO: 详细分析 Action 的作用 -->\n\n<p>在 init 进程启动的第二阶段中添加了一些 Action，简单看下其中部分 Action 的作用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// am 是一个引用, 指向 ActionManager 实例</span></span><br><span class=\"line\">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueBuiltinAction(SetupCgroupsAction, <span class=\"string\">&quot;SetupCgroups&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 触发事件 early-init [2.4.4.1.2.1]</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;early-init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 等待 coldboot 完成</span></span><br><span class=\"line\">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class=\"string\">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class=\"string\">&quot;MixHwrngIntoLinuxRng&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(SetMmapRndBitsAction, <span class=\"string\">&quot;SetMmapRndBits&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(SetKptrRestrictAction, <span class=\"string\">&quot;SetKptrRestrict&quot;</span>);</span><br><span class=\"line\">    Keychords keychords;</span><br><span class=\"line\">    am.QueueBuiltinAction(</span><br><span class=\"line\">        [&amp;epoll, &amp;keychords](<span class=\"keyword\">const</span> BuiltinArguments&amp; args) -&gt; Result&lt;Success&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; svc : ServiceList::GetInstance()) &#123;</span><br><span class=\"line\">                keychords.Register(svc-&gt;keycodes());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            keychords.Start(&amp;epoll, HandleKeychord);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;KeychordInit&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(console_init_action, <span class=\"string\">&quot;console_init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 触发事件 init [2.4.4.1.2.1]</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueBuiltinAction(StartBoringSslSelfTest, <span class=\"string\">&quot;StartBoringSslSelfTest&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class=\"string\">&quot;MixHwrngIntoLinuxRng&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 为 init 进程初始化 binder</span></span><br><span class=\"line\">    am.QueueBuiltinAction(InitBinder, <span class=\"string\">&quot;InitBinder&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootmode = GetProperty(<span class=\"string\">&quot;ro.bootmode&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootmode == <span class=\"string\">&quot;charger&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在充电模式下, 添加 Action: 触发事件 charger [2.4.4.1.2.1]</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;charger&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 否则, 添加 Action: 触发事件 late-init [2.4.4.1.2.1]</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;late-init&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 触发当前所有的属性触发器</span></span><br><span class=\"line\">    am.QueueBuiltinAction(queue_property_triggers_action, <span class=\"string\">&quot;queue_property_triggers&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，在解析脚本或者属性值改变的时候，也会使用 ActionManager 添加 Action。</p>\n<h4 id=\"2-4-5-2-HandleProcessActions\"><a href=\"#2-4-5-2-HandleProcessActions\" class=\"headerlink\" title=\"2.4.5.2 HandleProcessActions\"></a>2.4.5.2 HandleProcessActions</h4><!-- ((s->flags() & SVC_RUNNING) && s->timeout_period()) -->\n\n<!-- 详细分析 service 的重启过程 -->\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"built_in\">std</span>::optional&lt;boot_clock::time_point&gt; <span class=\"title\">HandleProcessActions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::optional&lt;boot_clock::time_point&gt; next_process_action_time;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历 ServiceList</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; s : ServiceList::GetInstance()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断服务是否处于运行中状态, 以及是否有超时时长</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((s-&gt;flags() &amp; SVC_RUNNING) &amp;&amp; s-&gt;timeout_period()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算出服务启动的超时时间</span></span><br><span class=\"line\">            <span class=\"keyword\">auto</span> timeout_time = s-&gt;time_started() + *s-&gt;timeout_period();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (boot_clock::now() &gt; timeout_time) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果当前时间已大于服务启动的超时时间, 说明服务启动已超时</span></span><br><span class=\"line\">                s-&gt;Timeout();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 更新 next_process_action_time</span></span><br><span class=\"line\">                <span class=\"comment\">// 此时, next_process_action_time 表示最近的, 需要检查服务是否启动成功的时间点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!next_process_action_time || timeout_time &lt; *next_process_action_time) &#123;</span><br><span class=\"line\">                    next_process_action_time = timeout_time;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果服务不带有标志位 SVC_RESTARTING, 则不需要重启, 继续 for 循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(s-&gt;flags() &amp; SVC_RESTARTING)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算出服务启动的超时时间</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> restart_time = s-&gt;time_started() + s-&gt;restart_period();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 现在服务需要重启, 接下来重启已满足重启条件的服务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (boot_clock::now() &gt; restart_time) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前时间已大于服务的重启时间, 那么立即启动服务</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = s-&gt;Start(); !result) &#123;</span><br><span class=\"line\">                LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Could not restart process &#x27;&quot;</span> &lt;&lt; s-&gt;name() &lt;&lt; <span class=\"string\">&quot;&#x27;: &quot;</span> &lt;&lt; result.error();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 更新 next_process_action_time</span></span><br><span class=\"line\">            <span class=\"comment\">// 此时, next_process_action_time 表示最近的, 需要对服务进行重启操作的时间点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!next_process_action_time || restart_time &lt; *next_process_action_time) &#123;</span><br><span class=\"line\">                next_process_action_time = restart_time;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next_process_action_time;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数的工作有：</p>\n<ol>\n<li>检查带有标志位 <code>SVC_RUNNING</code> 的服务是否超时，如果服务启动超时，则调用 <code>Timeout</code> 函数，否则更新下次检查的时间点。</li>\n<li>当服务带有标志位 <code>SVC_RESTARTING</code> 时，说明服务需要重启。如果当前时间已大于服务的重启时间，则立即重启服务；否则，更新下次重启的时间点。 </li>\n</ol>\n<p>经分析可知，<code>next_process_action_time</code> 可能表示下一次的检查服务是否启动超时的时间点，也可能表示下一次为某个服务重启的时间点。</p>\n<p>注意到，在之前的分析信号 [2.4.3.1.4.3] 提到过，当 init 收到子进程终结的信号之后，会为有重启需要的服务添加标志位 <code>SVC_RESTARTING</code>。那么现在可以知道，在 init 进程进入无限循环状态后，就会处理这些带有标志位 <code>SVC_RESTARTING</code> 的服务，重启满足条件的服务。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://gityuan.com/2016/02/01/android-booting/\">Android系统启动-综述</a></p>\n<p><a href=\"http://gityuan.com/2016/02/05/android-init/\">Android系统启动-Init篇</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man7/epoll.7.html\">epoll(7)</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Signal_(IPC)\">Signal</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man7/signal.7.html\">signal(7)</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man2/wait.2.html\">wait(2)</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man2/signalfd.2.html\">signalfd(2)</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文基于源代码：android-security-10.0.0_r56</p>\n</blockquote>\n<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><!-- TODO: 关于 init 进程更好的概述 -->\n\n<p>Android 基于 Linux 内核，在内核启动过程中会创建出 init 进程。</p>\n<p>init 进程是用户空间的第一个进程，进程的 pid = 1。</p>","more":"<h1 id=\"2-启动流程\"><a href=\"#2-启动流程\" class=\"headerlink\" title=\"2. 启动流程\"></a>2. 启动流程</h1><!-- TODO: 总结 -->\n\n\n\n<h2 id=\"2-1-init-进程的入口\"><a href=\"#2-1-init-进程的入口\" class=\"headerlink\" title=\"2.1 init 进程的入口\"></a>2.1 init 进程的入口</h2><!-- TODO: 为什么是入口？ -->\n\n<!-- TODO: init 就是一个普通的命令行程序, 位置在 /system/core/init？ -->\n\n<p>在 Android 9，init 进程的入口位于 <code>system/core/init/init.cpp</code> 中的 main 函数。</p>\n<p>在 Android 10 之后，init 进程的入口改到了 <code>system/core/init/main.cpp</code> 中的 main 函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(basename(argv[<span class=\"number\">0</span>]), <span class=\"string\">&quot;ueventd&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ueventd_main(argc, argv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;subcontext&quot;</span>)) &#123;</span><br><span class=\"line\">            android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class=\"line\">            <span class=\"keyword\">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> SubcontextMain(argc, argv, &amp;function_map);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;selinux_setup&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SetupSelinux(argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;second_stage&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SecondStageMain(argc, argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> FirstStageMain(argc, argv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先来了解其中使用到的两个库函数：<code>basename</code> 函数和 <code>strcmp</code> 函数。</p>\n<ul>\n<li><code>basename</code> 的函数原型为 <code>char* basename(char* __path)</code>，可以根据给定的一个路径，返回文件名。例如：传入参数 “/system/bin/ueventd”，函数会返回 “ueventd”。</li>\n<li><code>strcmp</code> 的函数原型为 <code>int strcmp(const char* __lhs, const char* __rhs)</code>，是一个字符串比较函数，返回值为整数。当两个字符串相等时，函数返回 0。</li>\n</ul>\n<p>再来分析 main 函数：函数的主要工作是根据参数 <code>argc</code> 和 <code>argv</code>，选择对应的执行方式。如果参数未匹配成功，则默认调用 <code>FirstStageMain</code> 函数。</p>\n<h2 id=\"2-2-启动的第一阶段\"><a href=\"#2-2-启动的第一阶段\" class=\"headerlink\" title=\"2.2 启动的第一阶段\"></a>2.2 启动的第一阶段</h2><!-- TODO: mkdir, mknod, tmpfs -->\n\n<!-- TODO: 所挂载的文件系统的用处 -->\n\n<!-- TODO: KernelLogging(/dev/kmsg) -->\n\n<!-- TODO: InstallRebootSignalHandlers -->\n\n<p>调用 <code>int FirstStageMain(int argc, char** argv)</code> 进入启动的第一阶段，函数所在文件的路径为 <code>system/core/init/first_stage_init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FirstStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(clearenv());</span><br><span class=\"line\">    CHECKCALL(setenv(<span class=\"string\">&quot;PATH&quot;</span>, _PATH_DEFPATH, <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"comment\">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class=\"line\">    <span class=\"comment\">// on / and then we&#x27;ll let the rc file figure out the rest.</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/dev&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class=\"string\">&quot;mode=0755&quot;</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/pts&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/socket&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/dm-user&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;devpts&quot;</span>, <span class=\"string\">&quot;/dev/pts&quot;</span>, <span class=\"string\">&quot;devpts&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;proc&quot;</span>, <span class=\"string\">&quot;/proc&quot;</span>, <span class=\"string\">&quot;proc&quot;</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;hidepid=2,gid=&quot;</span> MAKE_STR(AID_READPROC)));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> MAKE_STR</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t expose the raw commandline to unprivileged processes.</span></span><br><span class=\"line\">    <span class=\"comment\">// 设置文件权限 [2.2.1]</span></span><br><span class=\"line\">    CHECKCALL(chmod(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, <span class=\"number\">0440</span>));</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> cmdline;</span><br><span class=\"line\">    android::base::ReadFileToString(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, &amp;cmdline);</span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t expose the raw bootconfig to unprivileged processes.</span></span><br><span class=\"line\">    chmod(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, <span class=\"number\">0440</span>);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootconfig;</span><br><span class=\"line\">    android::base::ReadFileToString(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, &amp;bootconfig);</span><br><span class=\"line\">    <span class=\"keyword\">gid_t</span> groups[] = &#123;AID_READPROC&#125;;</span><br><span class=\"line\">    CHECKCALL(setgroups(arraysize(groups), groups));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;sysfs&quot;</span>, <span class=\"string\">&quot;/sys&quot;</span>, <span class=\"string\">&quot;sysfs&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;selinuxfs&quot;</span>, <span class=\"string\">&quot;/sys/fs/selinux&quot;</span>, <span class=\"string\">&quot;selinuxfs&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/kmsg&quot;</span>, S_IFCHR | <span class=\"number\">0600</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">11</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">if</span> <span class=\"title\">constexpr</span> <span class=\"params\">(WORLD_WRITABLE_KMSG)</span> </span>&#123;</span><br><span class=\"line\">        CHECKCALL(mknod(<span class=\"string\">&quot;/dev/kmsg_debug&quot;</span>, S_IFCHR | <span class=\"number\">0622</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">11</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/random&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">8</span>)));</span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/urandom&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">9</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This is needed for log wrapper, which gets called before ueventd runs.</span></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/ptmx&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">5</span>, <span class=\"number\">2</span>)));</span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/null&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">3</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// These below mounts are done in first stage init so that first stage mount can mount</span></span><br><span class=\"line\">    <span class=\"comment\">// subdirectories of /mnt/&#123;vendor,product&#125;/.  Other mounts, not required by first stage mount,</span></span><br><span class=\"line\">    <span class=\"comment\">// should be done in rc files.</span></span><br><span class=\"line\">    <span class=\"comment\">// Mount staging areas for devices managed by vold</span></span><br><span class=\"line\">    <span class=\"comment\">// See storage config details at http://source.android.com/devices/storage/</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/mnt&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=1000&quot;</span>));</span><br><span class=\"line\">    <span class=\"comment\">// /mnt/vendor is used to mount vendor-specific partitions that can not be</span></span><br><span class=\"line\">    <span class=\"comment\">// part of the vendor partition, e.g. because they are mounted read-write.</span></span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/mnt/vendor&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    <span class=\"comment\">// /mnt/product is used to mount product-specific partitions that can not be</span></span><br><span class=\"line\">    <span class=\"comment\">// part of the product partition, e.g. because they are mounted read-write.</span></span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/mnt/product&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /debug_ramdisk is used to preserve additional files from the debug ramdisk</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/debug_ramdisk&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=0&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /second_stage_resources is used to preserve files from first to second</span></span><br><span class=\"line\">    <span class=\"comment\">// stage init</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, kSecondStageRes, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=0&quot;</span>))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> CHECKCALL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    SetStdioToDevNull(argv);</span><br><span class=\"line\">    <span class=\"comment\">// Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually</span></span><br><span class=\"line\">    <span class=\"comment\">// talk to the outside world...</span></span><br><span class=\"line\">    InitKernelLogging(argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!errors.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; [error_string, error_errno] : errors) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; error_string &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; strerror(error_errno);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;Init encountered errors starting first stage, aborting&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG(INFO) &lt;&lt; <span class=\"string\">&quot;init first stage started!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 /system/bin/init</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到传入的参数是 selinux_setup, 因此接下来会调用 SetupSelinux 函数进行 SELinux 的初始化 [2.3]</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;selinux_setup&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> fd = open(<span class=\"string\">&quot;/dev/kmsg&quot;</span>, O_WRONLY | O_CLOEXEC);</span><br><span class=\"line\">    dup2(fd, STDOUT_FILENO);</span><br><span class=\"line\">    dup2(fd, STDERR_FILENO);</span><br><span class=\"line\">    close(fd);</span><br><span class=\"line\">    execv(path, <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">char</span>**&gt;(args));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// execv() only returns if an error happened, in which case we</span></span><br><span class=\"line\">    <span class=\"comment\">// panic and never fall through this conditional.</span></span><br><span class=\"line\">    PLOG(FATAL) &lt;&lt; <span class=\"string\">&quot;execv(\\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class=\"string\">&quot;\\&quot;) failed&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数主要工作是挂载一些文件系统，然后执行 <code>/system/bin/init</code>，重新进入 main 函数，通过传入参数 <code>&quot;selinux_setup&quot;</code>，进而调用 SetupSelinux 函数，进行 SELinux 的初始化。</p>\n<h3 id=\"2-2-1-设置文件或目录的权限\"><a href=\"#2-2-1-设置文件或目录的权限\" class=\"headerlink\" title=\"2.2.1 设置文件或目录的权限\"></a>2.2.1 设置文件或目录的权限</h3><p>在 Linux 系统上，<code>chmod</code> 命令用于控制用户对文件或者目录的权限，但只有文件所有者和超级用户可以修改文件或目录的权限。</p>\n<p>权限分为三类：读，写，执行。</p>\n<h4 id=\"2-2-1-1-符号表示法\"><a href=\"#2-2-1-1-符号表示法\" class=\"headerlink\" title=\"2.2.1.1 符号表示法\"></a>2.2.1.1 符号表示法</h4><p>符号表示法用 10 位字符表示权限，其形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rwxrwxrwx</span><br></pre></td></tr></table></figure>\n<p>其中第一个字符表示文件类型，常见的符号有：</p>\n<ul>\n<li><code>-</code>，表示普通文件。</li>\n<li><code>d</code>，表示目录。</li>\n<li><code>c</code>，表示字符特殊文件。</li>\n</ul>\n<p>剩余的 9 个字符，每 3 个字符分为一组，分别表示文件所有者，用户组，其他用户的权限。</p>\n<p>3 个字符组成的字符串，第 1 位控制读权限，第 2 位控制写权限，第 3 位控制执行权限：</p>\n<ul>\n<li>如果拥有读权限，第 1 位字符为 <code>r</code>，否则为 <code>-</code>。</li>\n<li>如果拥有写权限，第 2 位字符为 <code>w</code>，否则为 <code>-</code>。</li>\n<li>如果拥有执行权限，第 3 位字符为 <code>x</code>，否则为 <code>-</code>。</li>\n</ul>\n<p>示例：<code>-rwxrw-r--</code> 表示一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。</p>\n<h4 id=\"2-2-1-2-数字表示法\"><a href=\"#2-2-1-2-数字表示法\" class=\"headerlink\" title=\"2.2.1.2 数字表示法\"></a>2.2.1.2 数字表示法</h4><p>可以用 4 位八进制数字表示权限，第 1 位同样表示文件类型，剩余的 3 位数字，分别表示文件所有者，用户组，其他用户的权限。</p>\n<p>读，写，执行，这 3 类权限可以使用 3 位二进制数字表示，不同类型的权限单独对应二进制数字中一个位：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数值</th>\n<th align=\"center\">权限</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">二进制：100，八进制：4</td>\n<td align=\"center\">r</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：010，八进制：2</td>\n<td align=\"center\">w</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：001，八进制：1</td>\n<td align=\"center\">x</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：000，八进制：0</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p>在各类权限对应的数值之和，可以代表一组特定的权限。由于和的数值范围为 0~7，因此可以通过一个八进制数字表示。示例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数值</th>\n<th align=\"center\">权限</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">二进制：111，八进制：7</td>\n<td align=\"center\">rwx</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：110，八进制：6</td>\n<td align=\"center\">rw-</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：101，八进制：5</td>\n<td align=\"center\">r-x</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：000，八进制：0</td>\n<td align=\"center\">—</td>\n</tr>\n</tbody></table>\n<p>因此，用符号表示法表示的权限，同样可以使用数字表示法来表示，示例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号表示法</th>\n<th align=\"center\">数字表示法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-rwxrwxrwx</td>\n<td align=\"center\">0777</td>\n<td align=\"center\">一个普通文件，文件所有者，用户组，其他用户都有读，写，执行的权限</td>\n</tr>\n<tr>\n<td align=\"center\">-rwxrw-r–</td>\n<td align=\"center\">0764</td>\n<td align=\"center\">一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-2-1-3-分析源码中的权限设置\"><a href=\"#2-2-1-3-分析源码中的权限设置\" class=\"headerlink\" title=\"2.2.1.3 分析源码中的权限设置\"></a>2.2.1.3 分析源码中的权限设置</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Don&#x27;t expose the raw commandline to unprivileged processes.</span></span><br><span class=\"line\">CHECKCALL(chmod(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, <span class=\"number\">0440</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Don&#x27;t expose the raw bootconfig to unprivileged processes.</span></span><br><span class=\"line\">chmod(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, <span class=\"number\">0440</span>);</span><br></pre></td></tr></table></figure>\n<p>在源码中有两处使用到 <code>chmod</code> 命令，分别对文件 <code>/proc/cmdline</code>，<code>/proc/bootconfig</code> 设置了权限 <code>0440</code>，表明 root 用户 (文件所有者) 及其用户组也只有文件的读权限。</p>\n<h2 id=\"2-3-初始化-SELinux\"><a href=\"#2-3-初始化-SELinux\" class=\"headerlink\" title=\"2.3 初始化 SELinux\"></a>2.3 初始化 SELinux</h2><!-- TODO: 分析 SELinux -->\n\n<p>调用 <code>int SetupSelinux(char** argv)</code> 进行 SELinux 的初始化，该函数所在文件的路径为 <code>system/core/init/selinux.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This function initializes SELinux then execs init to run in the init SELinux context.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SetupSelinux</span><span class=\"params\">(<span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set up SELinux, loading the SELinux policy.</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 SELinux</span></span><br><span class=\"line\">    SelinuxSetupKernelLogging();</span><br><span class=\"line\">    SelinuxInitialize();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 /system/bin/init</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到传入的参数是 second_stage, 因此接下来会调用 SecondStageMain 函数进入启动的第二阶段 [2.4]</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;second_stage&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    execv(path, <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">char</span>**&gt;(args));</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数首先初始化了 SELinux，然后执行 <code>/system/bin/init</code>，重新进入 main 函数，通过传入参数 <code>&quot;second_stage&quot;</code>，进而调用 SecondStageMain 函数，进入启动的第二阶段。</p>\n<h2 id=\"2-4-启动的第二阶段\"><a href=\"#2-4-启动的第二阶段\" class=\"headerlink\" title=\"2.4 启动的第二阶段\"></a>2.4 启动的第二阶段</h2><!-- TODO: property_load_boot_defaults -->\n\n<!-- TODO: 在编译的过程中, android 的各种系统参数会被汇总到 build.prop 文件中？ -->\n\n<!-- TODO: SELinux 相关代码的分析 -->\n\n<!-- TODO: keyctl_get_keyring_ID(KEY_SPEC_SESSION_KEYRING, 1) -->\n\n<!-- TODO: InitializeSubcontext() -->\n\n<!-- TODO: ActionManager 和 ServiceList 的作用 -->\n\n<p>调用 <code>int SecondStageMain(int argc, char** argv)</code> 进入启动的第二阶段，函数所在文件的路径为 <code>system/core/init/init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set init and its forked children&#x27;s oom_adj.</span></span><br><span class=\"line\">    <span class=\"comment\">// 设置 init 进程以及由其 fork 得到的子进程 oom_score_adj 的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 数值越小, 进程优先级越高</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = WriteFile(<span class=\"string\">&quot;/proc/1/oom_score_adj&quot;</span>, <span class=\"string\">&quot;-1000&quot;</span>); !result) &#123;</span><br><span class=\"line\">        LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Unable to write -1000 to /proc/1/oom_score_adj: &quot;</span> &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化属性服务 [2.4.2.1]</span></span><br><span class=\"line\">    property_init();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 epoll [2.4.1.1]</span></span><br><span class=\"line\">    Epoll epoll;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Open(); !result) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用 epoll 对 init 子进程的信号进行监听 [2.4.3.1.3]</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化子进程退出的信号处理函数</span></span><br><span class=\"line\">    InstallSignalFdHandler(&amp;epoll);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 开启属性服务 [2.4.2.2]</span></span><br><span class=\"line\">    StartPropertyService(&amp;epoll);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class=\"line\">    ServiceList&amp; sm = ServiceList::GetInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 加载启动脚本 [2.4.4]</span></span><br><span class=\"line\">    LoadBootScripts(am, sm);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action [2.4.5.1]</span></span><br><span class=\"line\">    am.QueueBuiltinAction(SetupCgroupsAction, <span class=\"string\">&quot;SetupCgroups&quot;</span>);</span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;early-init&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class=\"string\">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    am.QueueBuiltinAction(queue_property_triggers_action, <span class=\"string\">&quot;queue_property_triggers&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进入无限循环状态 [2.4.5]</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> epoll_timeout = <span class=\"built_in\">std</span>::optional&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (do_shutdown &amp;&amp; !shutting_down) &#123;</span><br><span class=\"line\">            do_shutdown = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (HandlePowerctlMessage(shutdown_command)) &#123;</span><br><span class=\"line\">                shutting_down = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            am.ExecuteOneCommand();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!shutting_down) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> next_process_action_time = HandleProcessActions();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next_process_action_time) &#123;</span><br><span class=\"line\">                    epoll_timeout = <span class=\"built_in\">std</span>::chrono::<span class=\"built_in\">ceil</span>&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;(</span><br><span class=\"line\">                            *next_process_action_time - boot_clock::now());</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (*epoll_timeout &lt; <span class=\"number\">0</span>ms) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (am.HasMoreCommands()) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Wait(epoll_timeout); !result) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; result.error();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二阶段的工作可以大致分为 5 个部分：</p>\n<ul>\n<li><p>epoll</p>\n</li>\n<li><p>属性服务</p>\n</li>\n<li><p>信号</p>\n</li>\n<li><p>加载启动脚本</p>\n</li>\n<li><p>进入无限循环状态</p>\n</li>\n</ul>\n<p>接下来将分别对这 5 个部分的工作进行分析。</p>\n<h3 id=\"2-4-1-epoll\"><a href=\"#2-4-1-epoll\" class=\"headerlink\" title=\"2.4.1 epoll\"></a>2.4.1 epoll</h3><p>epoll 是 Linux 提供的 I/O 事件通知机制。epoll 可以监听大量的文件描述符，检查其中某一个文件描述符是否进入就绪状态。</p>\n<h4 id=\"2-4-1-1-初始化\"><a href=\"#2-4-1-1-初始化\" class=\"headerlink\" title=\"2.4.1.1 初始化\"></a>2.4.1.1 初始化</h4><p>在 init 进程中，epoll 通过以下代码初始化：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Epoll epoll;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Open(); !result) &#123;</span><br><span class=\"line\">    PLOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以知道，epoll 实例是通过调用 Open 函数创建的，函数所在文件的路径为 <code>system/core/init/epoll.cpp</code>，来分析这个函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::Open</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_fd_ &gt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关键点</span></span><br><span class=\"line\">    epoll_fd_.reset(epoll_create1(EPOLL_CLOEXEC));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_fd_ == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ErrnoError() &lt;&lt; <span class=\"string\">&quot;epoll_create1 failed&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数的关键点在于调用 <code>epoll_create1</code>。<code>epoll_create1</code> 是一个系统调用，其新建了一个 epoll 实例并返回该实例文件描述符。</p>\n<h4 id=\"2-4-1-2-使用-epoll-监听文件描述符\"><a href=\"#2-4-1-2-使用-epoll-监听文件描述符\" class=\"headerlink\" title=\"2.4.1.2 使用 epoll 监听文件描述符\"></a>2.4.1.2 使用 epoll 监听文件描述符</h4><p>要使用 epoll 监听文件描述符，需要调用 RegisterHandler 函数，将文件描述符注册到 epoll。</p>\n<p>函数所在文件的路径为 <code>system/core/init/epoll.cpp</code>，此函数的关键点在于系统调用 epoll_ctl：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::RegisterHandler</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; handler, <span class=\"keyword\">uint32_t</span> events)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关键点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &amp;ev) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先来看下 epoll_ctl 这个系统调用。</p>\n<h5 id=\"2-4-1-2-1-系统调用-epoll-ctl\"><a href=\"#2-4-1-2-1-系统调用-epoll-ctl\" class=\"headerlink\" title=\"2.4.1.2.1 系统调用 epoll_ctl\"></a>2.4.1.2.1 系统调用 epoll_ctl</h5><p><strong>epoll_ctl</strong> 是一个系统调用，函数原型为 <code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code>，用于对指定的文件描述符 fd 进行添加、修改或者删除操作。</p>\n<h6 id=\"2-4-1-2-1-1-参数\"><a href=\"#2-4-1-2-1-1-参数\" class=\"headerlink\" title=\"2.4.1.2.1.1 参数\"></a>2.4.1.2.1.1 参数</h6><p>首先来理解 epoll_ctl 的参数：</p>\n<ul>\n<li><p><strong>epfd</strong> 是 epoll 实例的文件描述符。</p>\n</li>\n<li><p><strong>op</strong> 表示要执行的操作，有三种取值：</p>\n<ul>\n<li><p><strong>EPOLL_CTL_ADD</strong></p>\n<p>添加指定的文件描述符到 epoll 的监控列表。</p>\n</li>\n<li><p><strong>EPOLL_CTL_MOD</strong></p>\n<p>修改 epoll 的监控列表中指定的文件描述符。</p>\n</li>\n<li><p><strong>EPOLL_CTL_DEL</strong></p>\n<p>从 epoll 的监控列表中删除指定的文件描述符。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>fd</strong> 表示指定的文件描述符。</p>\n</li>\n<li><p><strong>event</strong> 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，其定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">uint32_t</span>     events;      <span class=\"comment\">/* Epoll events */</span></span><br><span class=\"line\">   <span class=\"keyword\">epoll_data_t</span> data;        <span class=\"comment\">/* User data variable */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>结构体成员 <code>events</code> 用于表示要监听的事件，可以由零个或者多个事件类型组成，下面列出部分常见的事件类型：</p>\n<ul>\n<li><p>\u0015\u0015<strong>EPOLLIN</strong><br>表示关联的文件描述符可用于读操作。</p>\n</li>\n<li><p><strong>EPOLLOUT</strong><br>表示关联的文件描述符可用于写操作。</p>\n</li>\n<li><p><strong>EPOLLPRI</strong><br>表示关联的文件描述符出现异常情况。</p>\n</li>\n<li><p><strong>EPOLLERR</strong><br>表示关联的文件描述符出现错误。</p>\n</li>\n<li><p><strong>EPOLLHUP</strong><br>表示关联的文件描述符被挂断。</p>\n</li>\n<li><p><strong>EPOLLONESHOT</strong><br>表示只监听文件描述符的一次事件。当事件触发之后，epoll 就会禁用此文件描述符。<br>如果想要继续监听该文件描述符的事件，需要再次调用 epoll_ctl，并执行 EPOLL_CTL_MOD 操作。</p>\n</li>\n</ul>\n<p>结构体成员 <code>data</code> 的作用是将其数据交给内核保存，当文件描述符就绪后，内核会返回保存的数据 [2.4.1.3]。<code>epoll_data_t</code> 是一个共用体，其定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">epoll_data</span> &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span>        *ptr;</span><br><span class=\"line\">   <span class=\"keyword\">int</span>          fd;</span><br><span class=\"line\">   <span class=\"keyword\">uint32_t</span>     u32;</span><br><span class=\"line\">   <span class=\"keyword\">uint64_t</span>     u64;</span><br><span class=\"line\">&#125; <span class=\"keyword\">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h6 id=\"2-4-1-2-1-2-返回值\"><a href=\"#2-4-1-2-1-2-返回值\" class=\"headerlink\" title=\"2.4.1.2.1.2 返回值\"></a>2.4.1.2.1.2 返回值</h6><p>最后来了解 epoll_ctl 的返回值：</p>\n<ul>\n<li><p>当操作成功时，返回值为 0。</p>\n</li>\n<li><p>当发生错误时，返回值为 -1。</p>\n</li>\n</ul>\n<h5 id=\"2-4-1-2-2-分析-RegisterHandler-函数\"><a href=\"#2-4-1-2-2-分析-RegisterHandler-函数\" class=\"headerlink\" title=\"2.4.1.2.2 分析 RegisterHandler 函数\"></a>2.4.1.2.2 分析 RegisterHandler 函数</h5><p>在了解过系统调用 epoll_ctl 以后，现在开始分析 RegisterHandler 函数。首先来看函数在头文件中的声明，头文件的路径为 <code>system/core/init/epoll.h</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Epoll</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Result&lt;Success&gt; <span class=\"title\">RegisterHandler</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; handler,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                    <span class=\"keyword\">uint32_t</span> events = EPOLLIN)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>由函数原型可知，函数的第三个参数 <code>events</code> 有默认值 <code>EPOLLIN</code>，表示监听文件描述符的读操作是否可用。</p>\n<p>接下来分析 RegisterHandler 函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::RegisterHandler</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; handler, <span class=\"keyword\">uint32_t</span> events)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// handler 是事件触发时的回调函数</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> [it, inserted] = epoll_handlers_.emplace(fd, <span class=\"built_in\">std</span>::move(handler));</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    epoll_event ev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置要监听的事件类型</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于 events 有默认值 EPOLLIN, 因此默认监听的事件类型是读操作是否可用</span></span><br><span class=\"line\">    ev.events = events;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 设置回调函数, 回调函数会在事件触发后被调用 [2.4.1.3.2]</span></span><br><span class=\"line\">    ev.data.ptr = <span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"keyword\">void</span>*&gt;(&amp;it-&gt;second);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发起 epoll_ctl 系统调用</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到第二个参数传入的是 EPOLL_CTL_ADD, 因此对指定文件描述符执行的是添加操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &amp;ev) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        Result&lt;Success&gt; result = ErrnoError() &lt;&lt; <span class=\"string\">&quot;epoll_ctl failed to add fd&quot;</span>;</span><br><span class=\"line\">        epoll_handlers_.erase(fd);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过分析，可以知道函数的主要工作是：设置文件描述符需要监听的事件类型 <code>events</code> 以及事件触发时的回调函数 <code>handler</code>，最后发起 <code>epoll_ctl</code> 系统调用，将文件描述符添加到 epoll 监控列表。</p>\n<h4 id=\"2-4-1-3-等待事件触发\"><a href=\"#2-4-1-3-等待事件触发\" class=\"headerlink\" title=\"2.4.1.3 等待事件触发\"></a>2.4.1.3 等待事件触发</h4><p>经过 epoll 的初始化以及将文件描述符注册到 epoll 之后，接下来就需要等待事件触发，然后处理事件。</p>\n<p>在 init 进程启动的第二阶段，最后一个步骤就是进入死循环，不断地等待事件触发。接下来看下这段逻辑：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 关键点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Wait(epoll_timeout); !result) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; result.error();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段逻辑的关键点在于 Wait 函数，接下来分析这个函数。</p>\n<h5 id=\"2-4-1-3-1-系统调用-epoll-wait\"><a href=\"#2-4-1-3-1-系统调用-epoll-wait\" class=\"headerlink\" title=\"2.4.1.3.1 系统调用 epoll_wait\"></a>2.4.1.3.1 系统调用 epoll_wait</h5><p>在分析 Wait 函数之前，首先要了解系统调用 epoll_wait，这个系统调用是 Wait 函数的关键点。</p>\n<p><strong>epoll_wait</strong> 是一个系统调用，函数原型为 <code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code>，用于等待 epoll 上的事件。</p>\n<p>调用 epoll_wait 便会进入阻塞状态，直至满足以下任一条件，调用才会返回：</p>\n<ul>\n<li>监听的文件描述符传递一个事件；</li>\n<li>调用被信号处理程序中断；</li>\n<li>等待超出超时时长。</li>\n</ul>\n<h6 id=\"2-4-1-3-1-1-参数\"><a href=\"#2-4-1-3-1-1-参数\" class=\"headerlink\" title=\"2.4.1.3.1.1 参数\"></a>2.4.1.3.1.1 参数</h6><p>首先来理解 epoll_wait 的参数：</p>\n<ul>\n<li><p><strong>epfd</strong> 是 epoll 实例的文件描述符。</p>\n</li>\n<li><p><strong>events</strong> 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，在 [2.4.1.2.1] 一节已经详细介绍过。</p>\n<p>当事件触发后，调用就会返回，此时可以从 events 中得到已触发事件的集合。集合中每一个事件结构体 epoll_event 的 data 字段和调用 epoll_ctl 为相应的文件描述符设置的 data 字段是相同的。意味着，当事件触发后，之前调用 epoll_ctl 给指定文件描述符设置的 event.data 会通过这个参数返回给 epoll_wait 的调用者。</p>\n</li>\n<li><p><strong>maxevents</strong> 表示在一次调用中返回事件的最大数量。因此，从参数 events 中得到的事件数量不会大于 maxevents。</p>\n</li>\n<li><p><strong>timeout</strong> 是此次调用的超时时长。当 timeout = -1 时，调用将会一直阻塞，直到有事件发生；当 timeout = 0 时，调用会立即返回，即使当前没有事件发生。</p>\n</li>\n</ul>\n<h6 id=\"2-4-1-3-1-2-返回值\"><a href=\"#2-4-1-3-1-2-返回值\" class=\"headerlink\" title=\"2.4.1.3.1.2 返回值\"></a>2.4.1.3.1.2 返回值</h6><p>最后来了解 epoll_wait 的返回值：</p>\n<ul>\n<li><p>当调用成功时，返回值为已就绪的文件描述符的数量，此时可以对这些文件描述符进行 I/O 操作。</p>\n<p>需要注意的是，如果该调用是因为超出等待时长而返回的，则返回值为 0，表明没有已就绪的文件描述符。</p>\n</li>\n<li><p>当调用失败时，返回值为 -1，并返回错误信息。</p>\n</li>\n</ul>\n<h5 id=\"2-4-1-3-2-分析-Wait-函数\"><a href=\"#2-4-1-3-2-分析-Wait-函数\" class=\"headerlink\" title=\"2.4.1.3.2 分析 Wait 函数\"></a>2.4.1.3.2 分析 Wait 函数</h5><p>在了解过系统调用 epoll_wait 以后，就可以开始分析 Wait 函数，函数所在文件的路径为 <code>system/core/init/epoll.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::Wait</span><span class=\"params\">(<span class=\"built_in\">std</span>::optional&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt; timeout)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 超时时长默认值为 -1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> timeout_ms = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeout &amp;&amp; timeout-&gt;count() &lt; INT_MAX) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当参数 timeout 满足不等于 0 和数值没有溢出时, 更新超时时长</span></span><br><span class=\"line\">        timeout_ms = timeout-&gt;count();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    epoll_event ev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发起 epoll_wait 系统调用</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到第三个参数传入的是 1, 表明每次调用最多返回 1 个事件</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd_, &amp;ev, <span class=\"number\">1</span>, timeout_ms));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nr == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用返回 -1, 表明此次调用失败</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ErrnoError() &lt;&lt; <span class=\"string\">&quot;epoll_wait failed&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nr == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用返回 1, 表明此次调用成功, 有 1 个事件触发</span></span><br><span class=\"line\">        <span class=\"comment\">// ev.data.ptr 是之前调用 epoll_ctl 给指定文件描述符设置的回调函数, 因此事件最后交给回调函数进行处理</span></span><br><span class=\"line\">        <span class=\"built_in\">std</span>::invoke(*<span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt;*&gt;(ev.data.ptr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数设置了超时时长，然后发起 <code>epoll_wait</code> 系统调用，等待事件触发。当 <code>epoll_wait</code> 成功返回时，会从返回的数据里面取出之前通过 epoll_ctl 设置的回调函数，将事件交由回调函数处理。</p>\n<h3 id=\"2-4-2-属性服务\"><a href=\"#2-4-2-属性服务\" class=\"headerlink\" title=\"2.4.2 属性服务\"></a>2.4.2 属性服务</h3><p>属性服务是 Android 提供的一个用于存取系统属性的服务，属性以 key-value 的形式存储在一块共享内存，所有进程都可以通过这个服务获取和设置属性。</p>\n<p>使用 adb，输入命令 <code>getprop</code>，可以查看一台设备上的属性，下面列举其中的一些输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ro.product.brand]: [Redmi]</span><br><span class=\"line\">[ro.product.manufacturer]: [Xiaomi]</span><br><span class=\"line\">[ro.product.marketname]: [Redmi K30S Ultra]</span><br><span class=\"line\">[ro.product.model]: [M2007J3SC]</span><br><span class=\"line\">[ro.product.name]: [apollo]</span><br><span class=\"line\"></span><br><span class=\"line\">[ro.product.cpu.abi]: [arm64-v8a]</span><br><span class=\"line\">[ro.product.cpu.abilist]: [arm64-v8a,armeabi-v7a,armeabi]</span><br><span class=\"line\">[ro.product.cpu.abilist32]: [armeabi-v7a,armeabi]</span><br><span class=\"line\">[ro.product.cpu.abilist64]: [arm64-v8a]</span><br><span class=\"line\"></span><br><span class=\"line\">[dalvik.vm.heapsize]: [512m]</span><br><span class=\"line\">[dalvik.vm.heapstartsize]: [8m]</span><br></pre></td></tr></table></figure>\n<p>通过列举出的数据，可以看出属性里面包含了很多重要的信息：机型信息，CPU 架构，虚拟机分配的内存大小等等。</p>\n<p>在 Java 代码中，可以调用 <code>SystemProperties.get(String, String)</code> 方法获取系统属性。例如，在 ActivityManager 中就有这样的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">staticGetLargeMemoryClass</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过获取系统属性 dalvik.vm.heapsize, 得出应用可用堆内存的最大值</span></span><br><span class=\"line\">    String vmHeapSize = SystemProperties.get(<span class=\"string\">&quot;dalvik.vm.heapsize&quot;</span>, <span class=\"string\">&quot;16m&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.parseInt(vmHeapSize.substring(<span class=\"number\">0</span>, vmHeapSize.length() - <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似地，调用 <code>SystemProperties.set(String, String)</code> 方法可以设置系统属性。例如，在 ActivityManagerService 中就有这样的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">finishBooting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Tell anyone interested that we are done booting!</span></span><br><span class=\"line\">        <span class=\"comment\">// 通过设置属性 sys.boot_completed = 1, 标记系统已经启动完成</span></span><br><span class=\"line\">        SystemProperties.set(<span class=\"string\">&quot;sys.boot_completed&quot;</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"2-4-2-1-初始化\"><a href=\"#2-4-2-1-初始化\" class=\"headerlink\" title=\"2.4.2.1 初始化\"></a>2.4.2.1 初始化</h4><!-- TODO: 如何创建内存区域？ -->\n\n<!-- TODO: 进程是怎样获取共享内存中的属性？ -->\n\n<!-- TODO: 进程为什么不能直接设置共享内存中的属性？ -->\n\n<!-- TODO: CreateSerializedPropertyInfo() -->\n\n<!-- TODO: property_info_area.LoadDefaultPath() -->\n\n<p>属性服务初始化时，调用的是 property_init 函数，文件路径为 <code>system/core/init/property_service.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">property_init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mkdir(<span class=\"string\">&quot;/dev/__properties__&quot;</span>, S_IRWXU | S_IXGRP | S_IXOTH);</span><br><span class=\"line\">    CreateSerializedPropertyInfo();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建内存区域</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__system_property_area_init()) &#123;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;Failed to initialize property area&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!property_info_area.LoadDefaultPath()) &#123;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;Failed to load serialized property info file&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数最主要的工作是通过调用 <code>__system_property_area_init</code> 函数，创建用于存储属性的内存区域。</p>\n<h4 id=\"2-4-2-2-启动\"><a href=\"#2-4-2-2-启动\" class=\"headerlink\" title=\"2.4.2.2 启动\"></a>2.4.2.2 启动</h4><!-- TODO: socket 的创建过程 -->\n\n<!-- TODO: listen(property_set_fd, 8) -->\n\n<!-- TODO: 一个进程是怎样向 init 进程发起属性设置的请求？ -->\n\n<p>属性服务启动时，调用的是 StartPropertyService 函数，文件路径为 <code>system/core/init/property_service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StartPropertyService</span><span class=\"params\">(Epoll* epoll)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建 socket 并返回其文件描述符, 其中 PROP_SERVICE_NAME = &quot;property_service&quot;</span></span><br><span class=\"line\">    property_set_fd = CreateSocket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,</span><br><span class=\"line\">                                   <span class=\"literal\">false</span>, <span class=\"number\">0666</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (property_set_fd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; <span class=\"string\">&quot;start_property_service socket creation failed&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listen(property_set_fd, <span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将 socket 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]</span></span><br><span class=\"line\">    <span class=\"comment\">// handle_property_set_fd 是可读事件触发时的回调函数 [2.4.2.3]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll-&gt;RegisterHandler(property_set_fd, handle_property_set_fd); !result) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数首先创建名称为 property_service 的 socket，然后将 socket 文件描述符注册到 epoll，监听其可读事件。</p>\n<p>当可读事件触发时，会进入回调函数 <code>handle_property_set_fd</code>，接着来分析这个回调函数。</p>\n<h4 id=\"2-4-2-3-回调函数-handle-property-set-fd\"><a href=\"#2-4-2-3-回调函数-handle-property-set-fd\" class=\"headerlink\" title=\"2.4.2.3 回调函数 handle_property_set_fd\"></a>2.4.2.3 回调函数 handle_property_set_fd</h4><!-- TODO: ucred cr; socklen_t cr_size = sizeof(cr); -->\n\n<!-- TODO: 设置属性的具体实现 -->\n\n<!-- TODO: 除了通过向 init 进程发出请求设置属性以外, 在其他地方是否也有属性的设置？ -->\n\n<!-- TODO: 属性的同步问题 -->\n\n<p>函数所在文件的路径为 <code>system/core/init/property_service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handle_property_set_fd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2000ms</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">constexpr</span> <span class=\"keyword\">uint32_t</span> kDefaultSocketTimeout = <span class=\"number\">2000</span>; <span class=\"comment\">/* ms */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">SocketConnection <span class=\"title\">socket</span><span class=\"params\">(s, cr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置 2000ms 的超时时长</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> timeout_ms = kDefaultSocketTimeout;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> cmd = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!socket.RecvUint32(&amp;cmd, &amp;timeout_ms)) &#123;</span><br><span class=\"line\">        PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop: error while reading command from the socket&quot;</span>;</span><br><span class=\"line\">        socket.SendUint32(PROP_ERROR_READ_CMD);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (cmd) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理 PROP_MSG_SETPROP 命令</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> PROP_MSG_SETPROP: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// PROP_NAME_MAX = 32</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> prop_name[PROP_NAME_MAX];</span><br><span class=\"line\">        <span class=\"keyword\">char</span> prop_value[PROP_VALUE_MAX];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收属性名和属性值, 分别存储于字符数组 prop_name 和 prop_value 中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!socket.RecvChars(prop_name, PROP_NAME_MAX, &amp;timeout_ms) ||</span><br><span class=\"line\">            !socket.RecvChars(prop_value, PROP_VALUE_MAX, &amp;timeout_ms)) &#123;</span><br><span class=\"line\">          PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop(PROP_MSG_SETPROP): error while reading name/value from the socket&quot;</span>;</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将字符数组中最后的一个元素设置为 0</span></span><br><span class=\"line\">        prop_name[PROP_NAME_MAX<span class=\"number\">-1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        prop_value[PROP_VALUE_MAX<span class=\"number\">-1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; cr = socket.cred();</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> error;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置属性</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> result =</span><br><span class=\"line\">            HandlePropertySet(prop_name, prop_value, socket.source_context(), cr, &amp;error);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != PROP_SUCCESS) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Unable to set property &#x27;&quot;</span> &lt;&lt; prop_name &lt;&lt; <span class=\"string\">&quot;&#x27; to &#x27;&quot;</span> &lt;&lt; prop_value</span><br><span class=\"line\">                       &lt;&lt; <span class=\"string\">&quot;&#x27; from uid:&quot;</span> &lt;&lt; cr.uid &lt;&lt; <span class=\"string\">&quot; gid:&quot;</span> &lt;&lt; cr.gid &lt;&lt; <span class=\"string\">&quot; pid:&quot;</span> &lt;&lt; cr.pid &lt;&lt; <span class=\"string\">&quot;: &quot;</span></span><br><span class=\"line\">                       &lt;&lt; error;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 处理 PROP_MSG_SETPROP2 命令</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> PROP_MSG_SETPROP2: &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收字符串类型的属性名和属性值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!socket.RecvString(&amp;name, &amp;timeout_ms) ||</span><br><span class=\"line\">            !socket.RecvString(&amp;value, &amp;timeout_ms)) &#123;</span><br><span class=\"line\">          PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop(PROP_MSG_SETPROP2): error while reading name/value from the socket&quot;</span>;</span><br><span class=\"line\">          socket.SendUint32(PROP_ERROR_READ_DATA);</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; cr = socket.cred();</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> error;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置属性</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> result = HandlePropertySet(name, value, socket.source_context(), cr, &amp;error);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != PROP_SUCCESS) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Unable to set property &#x27;&quot;</span> &lt;&lt; name &lt;&lt; <span class=\"string\">&quot;&#x27; to &#x27;&quot;</span> &lt;&lt; value</span><br><span class=\"line\">                       &lt;&lt; <span class=\"string\">&quot;&#x27; from uid:&quot;</span> &lt;&lt; cr.uid &lt;&lt; <span class=\"string\">&quot; gid:&quot;</span> &lt;&lt; cr.gid &lt;&lt; <span class=\"string\">&quot; pid:&quot;</span> &lt;&lt; cr.pid &lt;&lt; <span class=\"string\">&quot;: &quot;</span></span><br><span class=\"line\">                       &lt;&lt; error;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        socket.SendUint32(result);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop: invalid command &quot;</span> &lt;&lt; cmd;</span><br><span class=\"line\">        socket.SendUint32(PROP_ERROR_INVALID_CMD);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数初始化了 socket 接收事件的超时时长，然后对接收到的 <code>cmd</code> 做相应的操作：</p>\n<ul>\n<li>对于 <code>PROP_MSG_SETPROP</code> 命令，使用两个长度为 <code>PROP_NAME_MAX</code> 的字符数组保存接收到的属性名和属性值。值得注意的是，最后会将字符数组中最后的一个元素设为 0，因此接收的属性名和属性值的最大长度不应超过 <code>PROP_NAME_MAX - 1</code> 。</li>\n<li>对于 <code>PROP_MSG_SETPROP2</code> 命令，使用两个 <code>std::string</code> 保存接收到的属性名和属性值。</li>\n</ul>\n<p>最后，不论是 <code>PROP_MSG_SETPROP</code> 命令还是 <code>PROP_MSG_SETPROP2</code> 命令，都会调用 <code>HandlePropertySet</code> 函数来设置属性。</p>\n<h3 id=\"2-4-3-信号\"><a href=\"#2-4-3-信号\" class=\"headerlink\" title=\"2.4.3 信号\"></a>2.4.3 信号</h3><p><strong>信号 (Signals)</strong> 属于 IPC 的一种方式，用于向一个进程或者进程中的特定线程发送事件通知。</p>\n<p>信号是一个<strong>异步的</strong>通信机制，一个进程可以不需要等待信号的到达。在信号未产生时，进程会正常执行；当信号产生后，系统可以中断目标进程的任何非原子操作，此时进程的正常执行流程会被中断，进而对信号进行处理。</p>\n<h4 id=\"2-4-3-1-处理信号\"><a href=\"#2-4-3-1-处理信号\" class=\"headerlink\" title=\"2.4.3.1 处理信号\"></a>2.4.3.1 处理信号</h4><p>在 Linux，一个子进程终结后，内核依然会为其维护关于此进程的最小信息集 (PID、终结状态、资源使用信息)，以便父进程获取有关子进程的信息。如果父进程没有为该子进程发起 wait、waitpid 或者 waitid 系统调用，那么子进程的信息就会一直占据着内核进程表的空间。在这种情况下，这个子进程就成为了一个**僵尸进程 (Zombie process)**。</p>\n<p>一般情况下，对于一个僵尸进程，如果其父进程终结了，那么 init 进程就会自动成为僵尸进程的父进程。此时，为了避免僵尸进程一直占据着系统资源，init 进程需要为僵尸进程释放占据的空间。</p>\n<p>而且，在加载启动脚本 [2.4.4] 这一步骤中，init 进程会 fork 得到一些子进程，例如：servicemanager 进程、zygote 进程。这些子进程对 Android 而言非常重要，在这些进程退出后，init 进程需要有相应的动作将其重启。</p>\n<p>于是，为了管理这些子进程，init 进程需要接收子进程终结的信号并进行相应的处理。</p>\n<p>在 Android，信号处理基于 Linux 的信号机制。</p>\n<h5 id=\"2-4-3-1-1-信号的处理方式\"><a href=\"#2-4-3-1-1-信号的处理方式\" class=\"headerlink\" title=\"2.4.3.1.1 信号的处理方式\"></a>2.4.3.1.1 信号的处理方式</h5><!-- 更正: 注册信号处理函数 -->\n\n<p>信号的处理方式有以下三种：</p>\n<ul>\n<li>\u0015\u0015<strong>忽略该信号</strong></li>\n<li><strong>按信号的默认行为处理该信号</strong></li>\n<li><strong>使用自定义的信号处理函数来处理该信号</strong></li>\n</ul>\n<p>init 进程使用的是第三种处理方式：使用自定义的信号处理函数来处理该信号。进程注册了一个信号处理函数，当目标信号产生时，信号会被捕获，并调用注册的函数进行处理。</p>\n<p>接下来分析这个过程。</p>\n<h5 id=\"2-4-3-1-2-系统调用-sigaction\"><a href=\"#2-4-3-1-2-系统调用-sigaction\" class=\"headerlink\" title=\"2.4.3.1.2 系统调用 sigaction\"></a>2.4.3.1.2 系统调用 sigaction</h5><p>在分析 init 进程注册函数的过程之前，首先来了解系统调用 sigaction，这个系统调用是此过程的一个关键点。</p>\n<p><strong>sigaction</strong> 是一个系统调用，函数原型为 <code>int sigaction(int signum, const struct sigaction *restrict act, struct sigaction *restrict oldact)</code>，用于更改进程在收到指定信号后的行为。</p>\n<h6 id=\"2-4-3-1-2-1-参数\"><a href=\"#2-4-3-1-2-1-参数\" class=\"headerlink\" title=\"2.4.3.1.2.1 参数\"></a>2.4.3.1.2.1 参数</h6><p>首先来理解 sigaction 的参数：</p>\n<ul>\n<li><p><strong>signum</strong> 是指定信号的编号。</p>\n<p>同一个信号在不同的架构上可能有不同的编号。在 Android，ARM 架构的信号编号定义在 <code>bionic/libc/kernel/uapi/asm-arm/asm/signal.h</code> 文件上。</p>\n</li>\n<li><p><strong>act</strong> 是一个 sigaction 类型的指针，而 sigaction 是一个结构体，其定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span>     (*sa_handler)(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">   <span class=\"keyword\">void</span>     (*sa_sigaction)(<span class=\"keyword\">int</span>, <span class=\"keyword\">siginfo_t</span> *, <span class=\"keyword\">void</span> *);</span><br><span class=\"line\">   <span class=\"keyword\">sigset_t</span>   sa_mask;</span><br><span class=\"line\">   <span class=\"keyword\">int</span>        sa_flags;</span><br><span class=\"line\">   <span class=\"keyword\">void</span>     (*sa_restorer)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>关注结构体中两个较为重要的成员 <code>sa_handler</code> 和 <code>sa_flags</code>。</p>\n<p>成员 <code>sa_handler</code> 用于指定信号产生时的行为，可以是以下这些值之一：</p>\n<ul>\n<li><p><strong>SIG_DFL</strong></p>\n<p>表示执行该信号的默认行为。</p>\n</li>\n<li><p><strong>SIG_IGN</strong></p>\n<p>表示忽略该信号。</p>\n</li>\n<li><p><strong>一个指向信号处理函数的指针</strong></p>\n<p>信号编号 signum 将作为函数的唯一参数传入。当目标信号产生时，会自动调用此函数进行处理。</p>\n</li>\n</ul>\n<p>成员 <code>sa_flags</code> 是标志位，可以由零个或者多个标志组成。下面列出其中的一些标志：</p>\n<ul>\n<li><p><strong>SA_NOCLDSTOP</strong></p>\n<p>只有当 signum = SIGCHLD 时才有意义。表示进程不接收子进程停止或者恢复时产生的信号，只接收子进程终结的信号。</p>\n</li>\n<li><p><strong>SA_RESETHAND</strong></p>\n<p>当信号已经由信号处理函数处理过后，将信号恢复为使用默认行为进行处理。</p>\n</li>\n<li><p><strong>SA_SIGINFO</strong></p>\n<p>不再通过结构体成员 sa_handler 设置信号处理函数，而是使用成员 sa_sigaction。此时，函数的入参有三个。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>oldact</strong> 同样是一个 sigaction 类型的指针，用于保存上一个 sigaction 调用所传入的参数 act，可以为空。</p>\n</li>\n</ul>\n<h6 id=\"2-4-3-1-2-2-返回值\"><a href=\"#2-4-3-1-2-2-返回值\" class=\"headerlink\" title=\"2.4.3.1.2.2 返回值\"></a>2.4.3.1.2.2 返回值</h6><p>最后来了解 sigaction 的返回值：</p>\n<ul>\n<li><p>当操作成功时，返回值为 0。</p>\n</li>\n<li><p>当发生错误时，返回值为 -1。</p>\n</li>\n</ul>\n<h5 id=\"2-4-3-1-3-init-进程注册信号处理函数\"><a href=\"#2-4-3-1-3-init-进程注册信号处理函数\" class=\"headerlink\" title=\"2.4.3.1.3 init 进程注册信号处理函数\"></a>2.4.3.1.3 init 进程注册信号处理函数</h5><p>在了解过系统调用 sigaction 以后，现在可以开始分析 init 进程注册信号处理函数的过程。</p>\n<h6 id=\"2-4-3-1-3-1-发起系统调用-sigaction\"><a href=\"#2-4-3-1-3-1-发起系统调用-sigaction\" class=\"headerlink\" title=\"2.4.3.1.3.1 发起系统调用 sigaction\"></a>2.4.3.1.3.1 发起系统调用 sigaction</h6><p>init 进程通过调用 InstallSignalFdHandler 函数实现注册信号处理函数，函数所在文件的路径为 <code>system/core/init/init.cpp</code>，首先来关注函数前半部分所做的工作：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">InstallSignalFdHandler</span><span class=\"params\">(Epoll* epoll)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建结构体 sigaction</span></span><br><span class=\"line\">    <span class=\"comment\">// 成员 sa_handler 用于指定信号产生时的行为, 令 sa_handler = SIG_DFL 表明当信号产生时按默认行为对信号进行处理</span></span><br><span class=\"line\">    <span class=\"comment\">// 成员 sa_flags 是标志位, 令 sa_flags = SA_NOCLDSTOP 表明 init 进程不接收子进程被中断或者被中断后恢复时产生的信号, 只接收子进程终结的信号</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> <span class=\"title\">act</span> &#123;</span> .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDSTOP &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// sigaction 是一个系统调用, 用于更改进程在收到指定的信号时所执行的操作 [2.4.3.1.2]</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到第一个参数传入的是 SIGCHLD, 表明目标信号是 SIGCHLD, 当子进程终结, 被中断, 或者被中断后恢复时, 就会产生此信号</span></span><br><span class=\"line\">    sigaction(SIGCHLD, &amp;act, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数前半部分所做的工作是：发起系统调用 sigaction，针对子进程产生的 <code>SIGCHLD</code> 信号，当进程在收到信号时，按默认行为对信号进行处理，而 <code>SIGCHLD</code> 信号的默认行为就是忽略该信号。</p>\n<p>值得注意的是，当子进程终结、被中断或者被中断后恢复时，都会产生 <code>SIGCHLD</code> 信号，而添加标志位 <code>SA_NOCLDSTOP</code> 可以使得 init 进程只接收子进程终结的信号。</p>\n<p>显然，在函数前半部分所做的工作中，并没有实现按自定义行为对信号进行处理。事实上，init 进程是通过监听 signal 文件描述符来实现按自定义行为来处理信号的。接下来分析 InstallSignalFdHandler 函数后半部分所做的工作。</p>\n<h6 id=\"2-4-3-1-3-2-监听-signal-文件描述符\"><a href=\"#2-4-3-1-3-2-监听-signal-文件描述符\" class=\"headerlink\" title=\"2.4.3.1.3.2 监听 signal 文件描述符\"></a>2.4.3.1.3.2 监听 signal 文件描述符</h6><p>之前提到，信号是一个异步的通信机制。进程可以注册一个信号处理函数，接着就能继续进行其他的工作，只有当目标信号发送到进程时，才回调处理函数进行处理，这里就体现出异步的性质。</p>\n<p>除了异步的方式以外，进程还可以通过同步的方式接收信号。Linux 提供了系统调用 signalfd，用于创建一个接收指定信号的文件描述符。对文件描述符执行读操作会进入阻塞状态，直到目标信号产生并传递给进程。</p>\n<p>init 进程就是通过这种方式来同步接收信号的，接下来分析这个过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">InstallSignalFdHandler</span><span class=\"params\">(Epoll* epoll)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// mask 是一个信号集, 用于指定想要接收的信号</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这里, 目标信号就是 SIGCHLD</span></span><br><span class=\"line\">    <span class=\"keyword\">sigset_t</span> mask;</span><br><span class=\"line\">    sigemptyset(&amp;mask);</span><br><span class=\"line\">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 signal 文件描述符</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到, 在发起系统调用 signalfd 时, 传入的第一个参数是 -1, 则调用会创建一个新的文件描述符</span></span><br><span class=\"line\">    signal_fd = signalfd(<span class=\"number\">-1</span>, &amp;mask, SFD_CLOEXEC);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (signal_fd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; <span class=\"string\">&quot;failed to create signalfd&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将 signal 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]</span></span><br><span class=\"line\">    <span class=\"comment\">// HandleSignalFd 是可读事件触发时的回调函数 [2.4.3.1.4]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll-&gt;RegisterHandler(signal_fd, HandleSignalFd); !result) &#123;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数后半部分所做的工作是：创建信号集，信号集里面包含了信号 <code>SIGCHLD</code>，然后新建一个与信号集关联的 signal 文件描述符，最后将文件描述符注册到 epoll。</p>\n<p>当 signal 文件描述符的可读事件触发时，就会调用 HandleSignalFd 函数，接下来分析这个函数。</p>\n<h5 id=\"2-4-3-1-4-回调函数-HandleSignalFd\"><a href=\"#2-4-3-1-4-回调函数-HandleSignalFd\" class=\"headerlink\" title=\"2.4.3.1.4 回调函数 HandleSignalFd\"></a>2.4.3.1.4 回调函数 HandleSignalFd</h5><p>函数所在文件的路径为 <code>system/core/init/init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">HandleSignalFd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    signalfd_siginfo siginfo;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从 signal 文件描述符中读取结构体 signalfd_siginfo, 每次读取一个</span></span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> bytes_read = TEMP_FAILURE_RETRY(read(signal_fd, &amp;siginfo, <span class=\"keyword\">sizeof</span>(siginfo)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bytes_read != <span class=\"keyword\">sizeof</span>(siginfo)) &#123;</span><br><span class=\"line\">        PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Failed to read siginfo from signal_fd&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据信号编号执行相应的操作</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (siginfo.ssi_signo) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SIGCHLD:</span><br><span class=\"line\">            ReapAnyOutstandingChildren();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SIGTERM:</span><br><span class=\"line\">            HandleSigtermSignal(siginfo);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;signal_fd: received unexpected signal &quot;</span> &lt;&lt; siginfo.ssi_signo;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当目标信号产生并传递给进程时，signal 文件描述符的可读事件就会触发，返回一个或者多个结构体 signalfd_siginfo。而函数 HandleSignalFd 负责从 signal 文件描述符中读出一个结构体 signalfd_siginfo，并根据信号编号执行相应的操作。</p>\n<p>在这里，我们关心的信号是 <code>SIGCHLD</code>。当此信号产生后，会调用 ReapAnyOutstandingChildren 函数，接着来分析这个函数。</p>\n<h6 id=\"2-4-3-1-4-1-分析-ReapAnyOutstandingChildren-函数\"><a href=\"#2-4-3-1-4-1-分析-ReapAnyOutstandingChildren-函数\" class=\"headerlink\" title=\"2.4.3.1.4.1 分析 ReapAnyOutstandingChildren 函数\"></a>2.4.3.1.4.1 分析 ReapAnyOutstandingChildren 函数</h6><p>函数所在文件的路径为 <code>system/core/init/sigchld_handler.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ReapAnyOutstandingChildren</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ReapOneProcess()) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数循环调用 ReapOneProcess 函数，只有当函数 ReapOneProcess 返回 false 时，循环才会停止。接着来看 ReapOneProcess 函数做了什么工作。</p>\n<h6 id=\"2-4-3-1-4-2-分析-ReapOneProcess-函数\"><a href=\"#2-4-3-1-4-2-分析-ReapOneProcess-函数\" class=\"headerlink\" title=\"2.4.3.1.4.2 分析 ReapOneProcess 函数\"></a>2.4.3.1.4.2 分析 ReapOneProcess 函数</h6><!-- TODO: 分析 service->flags() -->\n\n<!-- TODO: 分析 ServiceList::GetInstance().RemoveService(*service) -->\n\n<p>函数所在文件的路径为 <code>system/core/init/sigchld_handler.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">ReapOneProcess</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">siginfo_t</span> siginfo = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发起系统调用 waitid, 此系统调用用于获取子进程状态的变更和相关的信息</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于 init 进程只接收子进程终结的信号, 因此这里获取到的都是已进入僵尸状态的子进程的相关信息, 信息保存在 siginfo 当中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TEMP_FAILURE_RETRY(waitid(P_ALL, <span class=\"number\">0</span>, &amp;siginfo, WEXITED | WNOHANG | WNOWAIT)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 失败, 函数返回 false</span></span><br><span class=\"line\">        PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;waitid failed&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取子进程的 pid</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> pid = siginfo.si_pid;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 子进程的 pid 不存在, 函数返回 false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> wait_string;</span><br><span class=\"line\">    Service* service = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PropertyChildReap(pid)) &#123;</span><br><span class=\"line\">        name = <span class=\"string\">&quot;Async property child&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (SubcontextChildReap(pid)) &#123;</span><br><span class=\"line\">        name = <span class=\"string\">&quot;Subcontext&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据 pid 查询相应的 service</span></span><br><span class=\"line\">        service = ServiceList::GetInstance().FindService(pid, &amp;Service::pid);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (service) &#123;</span><br><span class=\"line\">            name = StringPrintf(<span class=\"string\">&quot;Service &#x27;%s&#x27; (pid %d)&quot;</span>, service-&gt;name().c_str(), pid);</span><br><span class=\"line\"></span><br><span class=\"line\">            ...</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            name = StringPrintf(<span class=\"string\">&quot;Untracked pid %d&quot;</span>, pid);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 没有找到对应的 service, 函数返回 true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!service) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用 service 的 Reap 函数</span></span><br><span class=\"line\">    service-&gt;Reap(siginfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经分析可知，ReapOneProcess 函数的主要工作是：为每个进入终结状态的子进程发起系统调用 waitid，从而避免已进入僵尸状态的子进程一直占据着系统资源。最后，函数会根据子进程 pid 查找是否存在相应的 service，如果 service 存在，还会调用 service 的 Reap 函数。接着来分析 Reap 函数。</p>\n<h6 id=\"2-4-3-1-4-3-分析-Reap-函数\"><a href=\"#2-4-3-1-4-3-分析-Reap-函数\" class=\"headerlink\" title=\"2.4.3.1.4.3 分析 Reap 函数\"></a>2.4.3.1.4.3 分析 Reap 函数</h6><p>函数所在文件的路径为 <code>system/core/init/service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Service::Reap</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">siginfo_t</span>&amp; siginfo)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(flags_ &amp; SVC_ONESHOT) || (flags_ &amp; SVC_RESTART)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果服务的标志位同时不带有 SVC_ONESHOT 和 SVC_RESTART, 则直接杀死服务所在的进程组</span></span><br><span class=\"line\">        KillProcessGroup(SIGKILL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果服务的标志位带有 SVC_TEMPORARY, 则直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags_ &amp; SVC_TEMPORARY) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重置状态</span></span><br><span class=\"line\">    pid_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    flags_ &amp;= (~SVC_RUNNING);</span><br><span class=\"line\">    start_order_ = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((flags_ &amp; SVC_ONESHOT) &amp;&amp; !(flags_ &amp; SVC_RESTART) &amp;&amp; !(flags_ &amp; SVC_RESET)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将带有 SVC_ONESHOT 的服务设为不可用状态</span></span><br><span class=\"line\">        flags_ |= SVC_DISABLED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags_ &amp; (SVC_DISABLED | SVC_RESET))  &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果服务的标志位带有 SVC_DISABLED 或者 SVC_RESET, 则使其进入 stopped 状态, 不会自动重启</span></span><br><span class=\"line\">        NotifyStateChange(<span class=\"string\">&quot;stopped&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 带有标志位 SVC_CRITICAL 的服务会被标记为系统关键服务</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果服务在 4 分钟之内崩溃 4 次以上, 又或者服务崩溃时系统处于未完全启动状态</span></span><br><span class=\"line\">    <span class=\"comment\">// 则设备会重启并进入 bootloader 或者设置崩溃相关的属性</span></span><br><span class=\"line\">    boot_clock::time_point now = boot_clock::now();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (((flags_ &amp; SVC_CRITICAL) || !pre_apexd_) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> boot_completed = android::base::GetBoolProperty(<span class=\"string\">&quot;sys.boot_completed&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now &lt; time_crashed_ + <span class=\"number\">4</span>min || !boot_completed) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++crash_count_ &gt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (flags_ &amp; SVC_CRITICAL) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Aborts into bootloader</span></span><br><span class=\"line\">                    LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;critical process &#x27;&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;&#x27; exited 4 times &quot;</span></span><br><span class=\"line\">                               &lt;&lt; (boot_completed ? <span class=\"string\">&quot;in 4 minutes&quot;</span> : <span class=\"string\">&quot;before boot completed&quot;</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;updatable process &#x27;&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;&#x27; exited 4 times &quot;</span></span><br><span class=\"line\">                               &lt;&lt; (boot_completed ? <span class=\"string\">&quot;in 4 minutes&quot;</span> : <span class=\"string\">&quot;before boot completed&quot;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// Notifies update_verifier and apexd</span></span><br><span class=\"line\">                    property_set(<span class=\"string\">&quot;ro.init.updatable_crashing&quot;</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            time_crashed_ = now;</span><br><span class=\"line\">            crash_count_ = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加标志位 SVC_RESTARTING, init 进程会重启带有此标志位的服务 [2.4.5.2]</span></span><br><span class=\"line\">    flags_ &amp;= (~SVC_RESTART);</span><br><span class=\"line\">    flags_ |= SVC_RESTARTING;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行当前 service 中所有 onrestart 命令</span></span><br><span class=\"line\">    onrestart_.ExecuteAllCommands();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使服务进入 restarting 状态</span></span><br><span class=\"line\">    NotifyStateChange(<span class=\"string\">&quot;restarting&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Reap 函数最主要的工作就是重启有需要的服务。注意到，改变服务状态是通过调用 NotifyStateChange 函数实现的，来看看这个函数。</p>\n<h6 id=\"2-4-3-1-4-4-分析-NotifyStateChange-函数\"><a href=\"#2-4-3-1-4-4-分析-NotifyStateChange-函数\" class=\"headerlink\" title=\"2.4.3.1.4.4 分析 NotifyStateChange 函数\"></a>2.4.3.1.4.4 分析 NotifyStateChange 函数</h6><p>函数所在文件的路径为 <code>system/core/init/service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Service::NotifyStateChange</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; new_state)</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((flags_ &amp; SVC_TEMPORARY) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果服务的标志位中带有 SVC_TEMPORARY, 则不会使用属性服务来记录它的状态</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用属性服务来记录服务当前的状态</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> prop_name = <span class=\"string\">&quot;init.svc.&quot;</span> + name_;</span><br><span class=\"line\">    property_set(prop_name, new_state);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过分析这个函数，可以知道，系统会使用属性服务以 key-value 的形式存储服务当前的状态，其中 key 的取值为 init.svc.[service_name]，value 是服务当前的状态。因此，可以使用 adb，输入命令 <code>getprop | grep init.svc.</code>，查看设备上 service 的运行状态，以下是其中的一些输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[init.svc.adbd]: [running]</span><br><span class=\"line\">[init.svc.alarm-hal-1-0]: [running]</span><br><span class=\"line\">[init.svc.android.thermal-hal]: [running]</span><br><span class=\"line\">[init.svc.apexd]: [stopped]</span><br><span class=\"line\">[init.svc.apexd-bootstrap]: [stopped]</span><br><span class=\"line\">[init.svc.apexd-snapshotde]: [stopped]</span><br><span class=\"line\">[init.svc.audioserver]: [running]</span><br><span class=\"line\">[init.svc.wifidisplayhalservice]: [running]</span><br><span class=\"line\">[init.svc.wpa_supplicant]: [running]</span><br><span class=\"line\">[init.svc.zygote]: [running]</span><br><span class=\"line\">[init.svc.zygote_secondary]: [running]</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-4-4-加载启动脚本\"><a href=\"#2-4-4-加载启动脚本\" class=\"headerlink\" title=\"2.4.4 加载启动脚本\"></a>2.4.4 加载启动脚本</h3><!-- TODO: 分析函数 CreateParser -->\n\n<!-- TODO: .rc 文件的解析过程 -->\n\n<!-- TODO: 属性的变更如何触发脚本中的属性触发器？ -->\n\n<!-- TODO: /system/etc/init -->\n\n<!-- TODO: /odm/etc/init -->\n\n<!-- TODO: /vendor/etc/init -->\n\n<p>调用 LoadBootScripts 函数加载启动脚本，函数所在文件的路径为 <code>system/core/init/init.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">LoadBootScripts</span><span class=\"params\">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class=\"line\">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootscript = GetProperty(<span class=\"string\">&quot;ro.boot.init_rc&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootscript.empty()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 加载 init.rc 脚本文件 [2.4.4.1]</span></span><br><span class=\"line\">        parser.ParseConfig(<span class=\"string\">&quot;/init.rc&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /system/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/system/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/system/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /product/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /product_services/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /odm/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/odm/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/odm/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /vendor/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        parser.ParseConfig(bootscript);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般情况下，此函数会去加载一些指定的脚本，其中：</p>\n<ul>\n<li><code>init.rc</code> 是主要的 .rc 文件。</li>\n<li><code>/system/etc/init/</code> 包含了核心的系统项目，例如：SurfaceFlinger, MediaService, logcatd。</li>\n<li><code>/vendor/etc/init/</code> 包含了 SoC 供应商项目，例如：核心 SoC 功能所需的操作或守护进程。</li>\n<li><code>/odm/etc/init/</code> 包含了设备制造商项目，例如：运动传感器或其他外围设备所需的操作或守护进程。</li>\n</ul>\n<p>init.rc 是最主要脚本文件，接下来将对这个脚本进行分析。</p>\n<h4 id=\"2-4-4-1-init-rc-脚本\"><a href=\"#2-4-4-1-init-rc-脚本\" class=\"headerlink\" title=\"2.4.4.1 init.rc 脚本\"></a>2.4.4.1 init.rc 脚本</h4><p>在 Android，后缀为 .rc 的文件由 Android Init Language 编写，<a href=\"https://cs.android.com/android/platform/superproject/+/android-security-10.0.0_r56:system/core/init/README.md\">关于 Android Init Language 的详细说明</a> 可以在 AOSP 上找到，路径为 <code>system/core/init/README.md</code>。</p>\n<p>在分析脚本之前，首先来了解这种语言的语法。</p>\n<h5 id=\"2-4-4-1-1-Android-Init-Language\"><a href=\"#2-4-4-1-1-Android-Init-Language\" class=\"headerlink\" title=\"2.4.4.1.1 Android Init Language\"></a>2.4.4.1.1 Android Init Language</h5><p>Android Init Language 由五大类表达式组成：<code>Actions</code>，<code>Commands</code>，<code>Services</code>，<code>Options</code>，<code>Imports</code>。</p>\n<p>其语法规则有：</p>\n<ul>\n<li>每一行都是一条语句，一条语句由多个 token 组成，token 之间以空格分开。</li>\n<li>如果一个 token 包含了空格，可以跟 c 语言类似，使用反斜杠 <code>\\</code> 作为转义字符，又或者使用双引号包裹整个 token。</li>\n<li>在行的末尾使用反斜杠 <code>\\</code>，可以将语句换行。</li>\n<li>以符号 <code>#</code> 开头的行是注释行。</li>\n<li>系统属性的值可以通过语法 <code>$&#123;property.name&#125;</code> 获取，例如：<code>import /init.recovery.$&#123;ro.hardware&#125;.rc</code>。</li>\n<li>一个文件可以分为多个 section，必须使用 <code>Actions</code> 或者 <code>Services</code> 来声明一个新的 section。所有的 <code>Commands</code> 和 <code>Options</code> 都是属于最近声明的那一个 section。如果在一个 section 之前声明了 <code>Commands</code> 或者 <code>Options</code> ，则声明会被忽略。</li>\n<li><code>Services</code> 的名称必须是唯一的，如果存在多个重名的 <code>Services</code> ，除了第一个以外，其他的都会被忽略，并且会输出错误日志。</li>\n</ul>\n<p>接下来列出一些较为重要的表达式。</p>\n<h6 id=\"2-4-4-1-1-1-Actions\"><a href=\"#2-4-4-1-1-1-Actions\" class=\"headerlink\" title=\"2.4.4.1.1.1 Actions\"></a>2.4.4.1.1.1 Actions</h6><p><code>Actions</code> 由 一系列 <code>Commands</code> 组成，同时 <code>Triggers</code> 决定了 <code>Actions</code> 的触发时机，其形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]*</span><br><span class=\"line\">   &lt;command&gt;</span><br><span class=\"line\">   &lt;command&gt;</span><br><span class=\"line\">   &lt;command&gt;</span><br></pre></td></tr></table></figure>\n<p>当一个事件触发后，如果此事件能够匹配上 <code>Actions</code> 的  <code>Triggers</code>，那么 <code>Actions</code> 会被添加到待执行队列的尾部。</p>\n<p>之后，待执行队列中的 <code>Actions</code> 会按照加入顺序出队，并且执行该 <code>Actions</code> 中的 <code>Commands</code>。</p>\n<p>以启动 Zygote 作为示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br></pre></td></tr></table></figure>\n<p>简单分析这个脚本：</p>\n<p>这个 <code>Actions</code> 拥有两个 <code>Triggers</code>，分别是 <code>zygote-start</code> 和 <code>property:ro.crypto.state=unencrypted</code>，从第二行开始，每一行都是一个 <code>Command</code>。</p>\n<p>当事件 <code>zygote-start</code> 和 <code>property:ro.crypto.state=unencrypted</code> 触发后，<code>Actions</code> 会被加入到待执行队列。在执行到该 <code>Actions</code> 时，会按照 <code>Commands</code> 定义的先后顺序，依次执行 <code>Actions</code> 中的 <code>Commands</code>。</p>\n<h6 id=\"2-4-4-1-1-2-Triggers\"><a href=\"#2-4-4-1-1-2-Triggers\" class=\"headerlink\" title=\"2.4.4.1.1.2 Triggers\"></a>2.4.4.1.1.2 Triggers</h6><p><code>Triggers</code> 是字符串，用于匹配某些类型的事件并触发 <code>Actions</code> 中的 <code>Commands</code>。</p>\n<p>Triggers 可以分为两类：</p>\n<ul>\n<li><p><strong>Event triggers</strong></p>\n<p>事件触发器，这类触发器所匹配的事件由命令 <code>trigger</code>  触发，又或者通过调用 <code>QueueEventTrigger()</code> 函数触发。</p>\n</li>\n<li><p><strong>Property triggers</strong></p>\n<p>属性触发器，这类触发器所匹配的事件是：属性是否满足某个值，形式为 <code>property:&lt;key&gt;=&lt;value&gt;</code>。这里的属性就是之前提到的属性服务管理的属性。</p>\n</li>\n</ul>\n<p>注意，每一个 <code>Actions</code> 可以有多个属性触发器，但只能有一个事件触发器。</p>\n<p>例如：</p>\n<p><code>on init &amp;&amp; property:a=b</code>，<code>on property:a=b &amp;&amp; property:c=d</code> 是合法的。</p>\n<p><code>on boot &amp;&amp; on init</code> 是不合法的。</p>\n<h6 id=\"2-4-4-1-1-3-Commands\"><a href=\"#2-4-4-1-1-3-Commands\" class=\"headerlink\" title=\"2.4.4.1.1.3 Commands\"></a>2.4.4.1.1.3 Commands</h6><p>下面列举一些常见的 <code>Commands</code>：</p>\n<ul>\n<li><p><strong>trigger <event></strong></p>\n<p>触发一个事件。</p>\n</li>\n<li><p><strong>write <path> <content></strong></p>\n<p>按 path 打开文件，往文件中写入内容。</p>\n</li>\n<li><p><strong>chown <owner> <group> <path></strong></p>\n<p>更改文件所有者和组。</p>\n</li>\n<li><p><strong>mkdir <path> [mode] [owner] [group]</strong></p>\n<p>在路径上创建一个目录，可以选择使用给定的权限，所有者，用户组。 </p>\n<p>如果未指定权限，所有者，用户组，则新建的目录默认具有权限 755，并由 root 用户和 root 组拥有。</p>\n<p>当指定权限，所有者，用户组时，如果目录已经存在，则权限，所有者，用户组将被更新。</p>\n</li>\n<li><p><strong>start <service></strong></p>\n<p>当指定的服务未在运行时，启动该服务。</p>\n</li>\n<li><p><strong>exec_start <service></strong></p>\n<p>启动指定的服务，在该命令返回之前暂停处理其他命令。</p>\n</li>\n<li><p><strong>setprop <name> <value></strong></p>\n<p>给系统属性赋值，这里的属性是之前提到的属性服务中的属性。</p>\n</li>\n<li><p><strong>symlink <target> <path></strong></p>\n<p>在 path 上创建一个连接到 target 的符号链接。</p>\n</li>\n</ul>\n<h6 id=\"2-4-4-1-1-4-Services\"><a href=\"#2-4-4-1-1-4-Services\" class=\"headerlink\" title=\"2.4.4.1.1.4 Services\"></a>2.4.4.1.1.4 Services</h6><p><code>Services</code> 是由 init 进程启动的程序，一般运行在 init 进程的一个子进程，因此 init 进程在启动一个 <code>Services</code> 时会通过 fork 的方式生成子进程。</p>\n<p>默认情况下，<code>Services</code> 退出后会重启。</p>\n<p><code>Services</code> 的形式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class=\"line\">   &lt;option&gt;</span><br><span class=\"line\">   &lt;option&gt;</span><br><span class=\"line\">   ...</span><br></pre></td></tr></table></figure>\n<p>以启动 Zygote 64 位进程的脚本作为示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class=\"line\">    class main</span><br><span class=\"line\">    priority -20</span><br><span class=\"line\">    user root</span><br><span class=\"line\">    group root readproc reserved_disk</span><br><span class=\"line\">    socket zygote stream 660 root system</span><br><span class=\"line\">    socket usap_pool_primary stream 660 root system</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class=\"line\">    onrestart restart audioserver</span><br><span class=\"line\">    onrestart restart cameraserver</span><br><span class=\"line\">    onrestart restart media</span><br><span class=\"line\">    onrestart restart netd</span><br><span class=\"line\">    onrestart restart wificond</span><br><span class=\"line\">    writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br></pre></td></tr></table></figure>\n<p>简单分析这个脚本：<code>zygote</code> 是 <code>Services</code> 的名称，<code>/system/bin/app_process64</code> 是可执行文件的路径，<code>-Xzygote /system/bin --zygote --start-system-server</code> 是启动参数，从第二行开始，每一行都是一个 <code>Options</code>。</p>\n<h6 id=\"2-4-4-1-1-5-Options\"><a href=\"#2-4-4-1-1-5-Options\" class=\"headerlink\" title=\"2.4.4.1.1.5 Options\"></a>2.4.4.1.1.5 Options</h6><p><code>Options</code> 是 <code>Services</code> 的配置项，用于控制 init 进程运行 <code>Services</code> 的方式和时间。</p>\n<p> 下面列举一些常见的 <code>Options</code>：</p>\n<ul>\n<li><p><strong>class <name> [ <name>* ]</strong></p>\n<p>指定 <code>Services</code> 的类名。当 <code>Services</code> 所属类开启 (退出) 时，<code>Services</code> 也会开启 (退出) 。默认值为 default。</p>\n</li>\n<li><p><strong>class_start <serviceclass></strong></p>\n<p>启动所有未在运行的，类名被指定为 <code>serviceclass</code> 的 <code>Services</code>。</p>\n</li>\n<li><p><strong>priority <priority></strong></p>\n<p>设置 <code>Services</code> 进程的优先级。取值范围是 -20 ~ 19。默认值为 0。</p>\n</li>\n<li><p><strong>user <username></strong></p>\n<p>设置执行 <code>Services</code> 的用户。一般情况下，默认值为 root。</p>\n</li>\n<li><p><strong>group <groupname> [ <groupname>* ]</strong></p>\n<p>设置执行 <code>Services</code> 的用户组。一般情况下，默认值为 root。</p>\n</li>\n<li><p><strong>socket <name> <type> <perm> [ <user> [ <group> [ <seclabel> ] ] ]</strong></p>\n<p>创建一个 unix 域的 socket，命名为 <code>/dev/socket/&lt;name&gt;</code>，并将 socket 的文件描述符传递给创建的进程。</p>\n</li>\n<li><p><strong>onrestart</strong></p>\n<p>当 <code>Services</code> 重启时执行一个 <code>Commands</code>。</p>\n</li>\n<li><p><strong>oneshot</strong></p>\n<p>当 <code>Services</code> 退出后不再重启。</p>\n</li>\n<li><p><strong>writepid <file> [ <file>* ]</strong></p>\n<p>在进程 fork 之后，将子进程的 pid 写入指定的文件。</p>\n</li>\n</ul>\n<h5 id=\"2-4-4-1-2-加载-init-rc-脚本\"><a href=\"#2-4-4-1-2-加载-init-rc-脚本\" class=\"headerlink\" title=\"2.4.4.1.2 加载 init.rc 脚本\"></a>2.4.4.1.2 加载 init.rc 脚本</h5><p>脚本文件 init.rc 负责系统的初始设置，文件的路径为 <code>system/core/rootdir/init.rc</code>。</p>\n<p>在了解到脚本的编写语法之后，可以知道脚本的内容都是由  <code>Actions</code> 和 <code>Services</code> 构成的，而在 init.rc 脚本中绝大部分都是 <code>Actions</code>。在 [2.4.4.1.1.2] 中曾经提到，调用 <code>QueueEventTrigger()</code> 函数可以触发一个事件，当事件匹配上  <code>Actions</code> 的  <code>Triggers</code>，就会开始执行该 <code>Actions</code>。 接下来回到进程启动的第二阶段，寻找事件的触发点。</p>\n<h6 id=\"2-4-4-1-2-1-源码中事件的触发点\"><a href=\"#2-4-4-1-2-1-源码中事件的触发点\" class=\"headerlink\" title=\"2.4.4.1.2.1 源码中事件的触发点\"></a>2.4.4.1.2.1 源码中事件的触发点</h6><p>回到 init 进程启动的第二阶段，对应源代码 <code>system/core/init/init.cpp</code> 的 SecondStageMain 函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将触发事件 early-init 的操作加入到 ActionManager</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;early-init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Trigger all the boot actions to get us started.</span></span><br><span class=\"line\">    <span class=\"comment\">// 将触发事件 init 的操作加入到 ActionManager</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t mount filesystems or start core system services in charger mode.</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootmode = GetProperty(<span class=\"string\">&quot;ro.bootmode&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootmode == <span class=\"string\">&quot;charger&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前处于充电模式, 则将触发事件 charger 的操作加入到 ActionManager</span></span><br><span class=\"line\">        <span class=\"comment\">// 在充电模式下, 不会挂载文件系统和启动核心系统服务</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;charger&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前处于非充电模式, 则将触发事件 late-init 的操作加入到 ActionManager</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;late-init&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ActionManager 会按操作加入的顺序逐一执行 [2.4.5.x]，由此可知事件的触发顺序：</p>\n<ul>\n<li>非充电模式：early-init -&gt; init -&gt; late-init</li>\n<li>充电模式：early-init -&gt; init -&gt; charger</li>\n</ul>\n<p>由于在充电模式下，系统可能未完全启动，接下来将选取非充电模式下的流程进行分析。</p>\n<h6 id=\"2-4-4-1-2-2-init-rc-脚本的执行过程\"><a href=\"#2-4-4-1-2-2-init-rc-脚本的执行过程\" class=\"headerlink\" title=\"2.4.4.1.2.2 init.rc 脚本的执行过程\"></a>2.4.4.1.2.2 init.rc 脚本的执行过程</h6><!-- TODO: trigger boot -->\n\n<p>现在结合事件的触发顺序，分析脚本执行过程中的一些关键点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on early-init</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    # 以 start 方式启动 ueventd</span><br><span class=\"line\">    start ueventd</span><br><span class=\"line\"></span><br><span class=\"line\">    # 以 exec_start 方式运行 apexd-bootstrap, 在该命令返回之前暂停处理其他命令, 从而保证后续流程中 APEX 的可用性</span><br><span class=\"line\">    exec_start apexd-bootstrap</span><br><span class=\"line\"></span><br><span class=\"line\">on init</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    # 以 start 方式启动基本服务</span><br><span class=\"line\">    # 启动 servicemanager [2.4.4.1.2.3]</span><br><span class=\"line\">    start servicemanager</span><br><span class=\"line\">    start hwservicemanager</span><br><span class=\"line\">    start vndservicemanager</span><br><span class=\"line\"></span><br><span class=\"line\"># 挂载文件和启动核心系统服务</span><br><span class=\"line\"># 其中 trigger 用于触发一个事件 [2.4.4.1.1.2]</span><br><span class=\"line\">on late-init</span><br><span class=\"line\">    trigger early-fs</span><br><span class=\"line\">    trigger fs</span><br><span class=\"line\">    trigger post-fs</span><br><span class=\"line\">    trigger late-fs</span><br><span class=\"line\">    trigger post-fs-data</span><br><span class=\"line\">    trigger load_persist_props_action</span><br><span class=\"line\"></span><br><span class=\"line\">    # 触发事件 zygote-start, 启动 zygote [2.4.4.1.2.4]</span><br><span class=\"line\">    trigger zygote-start</span><br><span class=\"line\"></span><br><span class=\"line\">    trigger firmware_mounts_complete</span><br><span class=\"line\">    trigger early-boot</span><br><span class=\"line\">    trigger boot</span><br></pre></td></tr></table></figure>\n<p>经过分析，现在已经大致了解脚本的执行过程，接下来分析 servicemanager 和 zygote 的启动。</p>\n<h6 id=\"2-4-4-1-2-3-启动-servicemanager\"><a href=\"#2-4-4-1-2-3-启动-servicemanager\" class=\"headerlink\" title=\"2.4.4.1.2.3 启动 servicemanager\"></a>2.4.4.1.2.3 启动 servicemanager</h6><p>servicemanager 启动脚本的路径为 <code>frameworks/native/cmds/servicemanager/servicemanager.rc</code>，分析这个脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># servicemanager 是 Services 的名称</span><br><span class=\"line\"># &#x2F;system&#x2F;bin&#x2F;servicemanager 是可执行文件的路径</span><br><span class=\"line\">service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager</span><br><span class=\"line\">    # 指定类名为 core 和 animation</span><br><span class=\"line\">    # 当 core 或者 animation 开启 (关闭) 时, servicemanager 也将开启 (关闭)</span><br><span class=\"line\">    class core animation</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置用户为 system</span><br><span class=\"line\">    user system</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置用户组为 system 和 readproc</span><br><span class=\"line\">    group system readproc</span><br><span class=\"line\"></span><br><span class=\"line\">    # 将其标记为设备的关键服务</span><br><span class=\"line\">    # 如果此服务在规定时间内不断重启, 则设备会重启并进入 bootloader</span><br><span class=\"line\">    critical</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置服务重启后执行的操作</span><br><span class=\"line\">    # 每一个操作都是一个 Commands</span><br><span class=\"line\">    onrestart restart healthd</span><br><span class=\"line\">    onrestart restart zygote</span><br><span class=\"line\">    onrestart restart audioserver</span><br><span class=\"line\">    onrestart restart media</span><br><span class=\"line\">    onrestart restart surfaceflinger</span><br><span class=\"line\">    onrestart restart inputflinger</span><br><span class=\"line\">    onrestart restart drm</span><br><span class=\"line\">    onrestart restart cameraserver</span><br><span class=\"line\">    onrestart restart keystore</span><br><span class=\"line\">    onrestart restart gatekeeperd</span><br><span class=\"line\">    onrestart restart thermalservice</span><br><span class=\"line\"></span><br><span class=\"line\">    # 在进程执行 fork 操作之后，将子进程的 pid 写入文件 &#x2F;dev&#x2F;cpuset&#x2F;system-background&#x2F;tasks</span><br><span class=\"line\">    writepid &#x2F;dev&#x2F;cpuset&#x2F;system-background&#x2F;tasks</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置服务的关闭行为</span><br><span class=\"line\">    # shutdown critical 表示此服务在关闭期间不会被杀死, 当关闭超时后才会被杀死</span><br><span class=\"line\">    shutdown critical</span><br></pre></td></tr></table></figure>\n<p>启动 servicemanager 之后，便会进入 <code>frameworks/native/cmds/servicemanager/service_manager.c</code> 的 main 函数。</p>\n<h6 id=\"2-4-4-1-2-4-启动-zygote\"><a href=\"#2-4-4-1-2-4-启动-zygote\" class=\"headerlink\" title=\"2.4.4.1.2.4 启动 zygote\"></a>2.4.4.1.2.4 启动 zygote</h6><p>在 init.rc 脚本中，事件 <code>zygote-start</code> 有 3 个对应的 <code>Actions</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br><span class=\"line\"></span><br><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unsupported</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br><span class=\"line\"></span><br><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;encrypted &amp;&amp; property:ro.crypto.type&#x3D;file</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br></pre></td></tr></table></figure>\n<p>其中，zygote 通过以下语句导入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#x2F;init.$&#123;ro.zygote&#125;.rc</span><br></pre></td></tr></table></figure>\n<p>此语句会根据属性 <code>ro.zygote</code>，导入相应的文件，其中包括：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote32.rc</span><br><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote32_64.rc</span><br><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote64.rc</span><br><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote64_32.rc</span><br></pre></td></tr></table></figure>\n<p>zygote 的启动除了依赖事件 <code>zygote-start</code> 以外，还需要某些属性满足特定的值。当上面列出的三个 <code>Actions</code> 中的其中一个满足条件后，便会启动 zygote。</p>\n<p>这里分析启动 Zygote 64 位进程的脚本，脚本文件的路径为 <code>system/core/rootdir/init.zygote64.rc</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># zygote 是 Services 的名称</span><br><span class=\"line\"># &#x2F;system&#x2F;bin&#x2F;app_process64 是可执行文件的路径</span><br><span class=\"line\"># -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server 是启动参数</span><br><span class=\"line\">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class=\"line\">    # 指定类名为 main</span><br><span class=\"line\">    # 当 main 开启 (关闭) 时, zygote 也将开启 (关闭)</span><br><span class=\"line\">    class main</span><br><span class=\"line\"></span><br><span class=\"line\">    # 进程优先级为 -20</span><br><span class=\"line\">    # 由于优先级的取值范围是 -20 ~ 19, 数值越小, 优先级越高, 因此 zygote 进程拥有最高的优先级</span><br><span class=\"line\">    priority -20</span><br><span class=\"line\"></span><br><span class=\"line\">    # 用户和用户组都是 root</span><br><span class=\"line\">    user root</span><br><span class=\"line\">    group root readproc reserved_disk</span><br><span class=\"line\"></span><br><span class=\"line\">    # 创建 socket</span><br><span class=\"line\">    socket zygote stream 660 root system</span><br><span class=\"line\">    socket usap_pool_primary stream 660 root system</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置服务重启后执行的操作</span><br><span class=\"line\">    # 每一个操作都是一个 Commands</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class=\"line\">    onrestart restart audioserver</span><br><span class=\"line\">    onrestart restart cameraserver</span><br><span class=\"line\">    onrestart restart media</span><br><span class=\"line\">    onrestart restart netd</span><br><span class=\"line\">    onrestart restart wificond</span><br><span class=\"line\"></span><br><span class=\"line\">    # 在 zygote 进程执行 fork 操作之后，将子进程的 pid 写入文件 &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br><span class=\"line\">    writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br></pre></td></tr></table></figure>\n<p>启动 zygote 之后，便会进入 <code>frameworks/base/cmds/app_process/app_main.cpp</code> 的 main 函数。</p>\n<h3 id=\"2-4-5-进入无限循环状态\"><a href=\"#2-4-5-进入无限循环状态\" class=\"headerlink\" title=\"2.4.5 进入无限循环状态\"></a>2.4.5 进入无限循环状态</h3><p>init 进程启动完成之后，进程就会一直存活，而保持存活的方法就是进入无限循环状态。接下来分析这个过程，源代码的路径为 <code>system/core/init/init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置等待 epoll 事件的超时时长</span></span><br><span class=\"line\">        <span class=\"comment\">// 默认情况下会一直处于阻塞状态, 直到有事件发生, 此时 epoll_timeout 取值为 -1</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> epoll_timeout = <span class=\"built_in\">std</span>::optional&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// am 是一个引用, 指向 ActionManager 实例</span></span><br><span class=\"line\">            <span class=\"comment\">// 按顺序执行 ActionManager 中的一个命令 [2.4.5.1]</span></span><br><span class=\"line\">            am.ExecuteOneCommand();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!shutting_down) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取下一次 HandleProcessActions 的时间点 [2.4.5.2]</span></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> next_process_action_time = HandleProcessActions();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next_process_action_time) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 计算出 next_process_action_time 与当前时间的差值</span></span><br><span class=\"line\">                    epoll_timeout = <span class=\"built_in\">std</span>::chrono::<span class=\"built_in\">ceil</span>&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;(</span><br><span class=\"line\">                            *next_process_action_time - boot_clock::now());</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 如果差值小于 0, 说明需要立即进行下一次的循环</span></span><br><span class=\"line\">                    <span class=\"comment\">// 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (*epoll_timeout &lt; <span class=\"number\">0</span>ms) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果 ActionManager 中仍有待执行的命令, 那么 init 进程不会进入阻塞状态, 并立即再次唤起</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (am.HasMoreCommands()) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 Wait 函数, 等待事件触发 [2.4.1.3]</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Wait(epoll_timeout); !result) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; result.error();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经分析可知，init 进程进入循环状态后主要的工作有 3 个：</p>\n<ul>\n<li>执行 ActionManager 中的命令。</li>\n<li>重启服务。</li>\n<li>等待 epoll 事件，当事件触发后，调用相应的函数进行处理。结合前面的分析，可知等待的事件有：一个进程通过请求 init 进程向属性服务写入属性，以及 init 进程接收到 <code>SIGCHLD</code> 信号。</li>\n</ul>\n<h4 id=\"2-4-5-1-ActionManager\"><a href=\"#2-4-5-1-ActionManager\" class=\"headerlink\" title=\"2.4.5.1 ActionManager\"></a>2.4.5.1 ActionManager</h4><!-- TODO: 什么是 Action? -->\n\n<!-- TODO: Action 和脚本中的 Actions 有没有关系 -->\n\n<!-- TODO: 添加和执行过程 -->\n\n<p>ActionManager 是 Action 的管理器，它提供了对 Action 的添加、执行、清空等操作。</p>\n<h5 id=\"2-4-5-1-1-添加-Action\"><a href=\"#2-4-5-1-1-添加-Action\" class=\"headerlink\" title=\"2.4.5.1.1 添加 Action\"></a>2.4.5.1.1 添加 Action</h5><!-- TODO: 详细分析 Action 的作用 -->\n\n<p>在 init 进程启动的第二阶段中添加了一些 Action，简单看下其中部分 Action 的作用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// am 是一个引用, 指向 ActionManager 实例</span></span><br><span class=\"line\">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueBuiltinAction(SetupCgroupsAction, <span class=\"string\">&quot;SetupCgroups&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 触发事件 early-init [2.4.4.1.2.1]</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;early-init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 等待 coldboot 完成</span></span><br><span class=\"line\">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class=\"string\">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class=\"string\">&quot;MixHwrngIntoLinuxRng&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(SetMmapRndBitsAction, <span class=\"string\">&quot;SetMmapRndBits&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(SetKptrRestrictAction, <span class=\"string\">&quot;SetKptrRestrict&quot;</span>);</span><br><span class=\"line\">    Keychords keychords;</span><br><span class=\"line\">    am.QueueBuiltinAction(</span><br><span class=\"line\">        [&amp;epoll, &amp;keychords](<span class=\"keyword\">const</span> BuiltinArguments&amp; args) -&gt; Result&lt;Success&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; svc : ServiceList::GetInstance()) &#123;</span><br><span class=\"line\">                keychords.Register(svc-&gt;keycodes());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            keychords.Start(&amp;epoll, HandleKeychord);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;KeychordInit&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(console_init_action, <span class=\"string\">&quot;console_init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 触发事件 init [2.4.4.1.2.1]</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueBuiltinAction(StartBoringSslSelfTest, <span class=\"string\">&quot;StartBoringSslSelfTest&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class=\"string\">&quot;MixHwrngIntoLinuxRng&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 为 init 进程初始化 binder</span></span><br><span class=\"line\">    am.QueueBuiltinAction(InitBinder, <span class=\"string\">&quot;InitBinder&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootmode = GetProperty(<span class=\"string\">&quot;ro.bootmode&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootmode == <span class=\"string\">&quot;charger&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在充电模式下, 添加 Action: 触发事件 charger [2.4.4.1.2.1]</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;charger&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 否则, 添加 Action: 触发事件 late-init [2.4.4.1.2.1]</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;late-init&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 触发当前所有的属性触发器</span></span><br><span class=\"line\">    am.QueueBuiltinAction(queue_property_triggers_action, <span class=\"string\">&quot;queue_property_triggers&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，在解析脚本或者属性值改变的时候，也会使用 ActionManager 添加 Action。</p>\n<h4 id=\"2-4-5-2-HandleProcessActions\"><a href=\"#2-4-5-2-HandleProcessActions\" class=\"headerlink\" title=\"2.4.5.2 HandleProcessActions\"></a>2.4.5.2 HandleProcessActions</h4><!-- ((s->flags() & SVC_RUNNING) && s->timeout_period()) -->\n\n<!-- 详细分析 service 的重启过程 -->\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"built_in\">std</span>::optional&lt;boot_clock::time_point&gt; <span class=\"title\">HandleProcessActions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::optional&lt;boot_clock::time_point&gt; next_process_action_time;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历 ServiceList</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; s : ServiceList::GetInstance()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断服务是否处于运行中状态, 以及是否有超时时长</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((s-&gt;flags() &amp; SVC_RUNNING) &amp;&amp; s-&gt;timeout_period()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算出服务启动的超时时间</span></span><br><span class=\"line\">            <span class=\"keyword\">auto</span> timeout_time = s-&gt;time_started() + *s-&gt;timeout_period();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (boot_clock::now() &gt; timeout_time) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果当前时间已大于服务启动的超时时间, 说明服务启动已超时</span></span><br><span class=\"line\">                s-&gt;Timeout();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 更新 next_process_action_time</span></span><br><span class=\"line\">                <span class=\"comment\">// 此时, next_process_action_time 表示最近的, 需要检查服务是否启动成功的时间点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!next_process_action_time || timeout_time &lt; *next_process_action_time) &#123;</span><br><span class=\"line\">                    next_process_action_time = timeout_time;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果服务不带有标志位 SVC_RESTARTING, 则不需要重启, 继续 for 循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(s-&gt;flags() &amp; SVC_RESTARTING)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算出服务启动的超时时间</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> restart_time = s-&gt;time_started() + s-&gt;restart_period();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 现在服务需要重启, 接下来重启已满足重启条件的服务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (boot_clock::now() &gt; restart_time) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前时间已大于服务的重启时间, 那么立即启动服务</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = s-&gt;Start(); !result) &#123;</span><br><span class=\"line\">                LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Could not restart process &#x27;&quot;</span> &lt;&lt; s-&gt;name() &lt;&lt; <span class=\"string\">&quot;&#x27;: &quot;</span> &lt;&lt; result.error();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 更新 next_process_action_time</span></span><br><span class=\"line\">            <span class=\"comment\">// 此时, next_process_action_time 表示最近的, 需要对服务进行重启操作的时间点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!next_process_action_time || restart_time &lt; *next_process_action_time) &#123;</span><br><span class=\"line\">                next_process_action_time = restart_time;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next_process_action_time;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数的工作有：</p>\n<ol>\n<li>检查带有标志位 <code>SVC_RUNNING</code> 的服务是否超时，如果服务启动超时，则调用 <code>Timeout</code> 函数，否则更新下次检查的时间点。</li>\n<li>当服务带有标志位 <code>SVC_RESTARTING</code> 时，说明服务需要重启。如果当前时间已大于服务的重启时间，则立即重启服务；否则，更新下次重启的时间点。 </li>\n</ol>\n<p>经分析可知，<code>next_process_action_time</code> 可能表示下一次的检查服务是否启动超时的时间点，也可能表示下一次为某个服务重启的时间点。</p>\n<p>注意到，在之前的分析信号 [2.4.3.1.4.3] 提到过，当 init 收到子进程终结的信号之后，会为有重启需要的服务添加标志位 <code>SVC_RESTARTING</code>。那么现在可以知道，在 init 进程进入无限循环状态后，就会处理这些带有标志位 <code>SVC_RESTARTING</code> 的服务，重启满足条件的服务。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://gityuan.com/2016/02/01/android-booting/\">Android系统启动-综述</a></p>\n<p><a href=\"http://gityuan.com/2016/02/05/android-init/\">Android系统启动-Init篇</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man7/epoll.7.html\">epoll(7)</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Signal_(IPC)\">Signal</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man7/signal.7.html\">signal(7)</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man2/wait.2.html\">wait(2)</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man2/signalfd.2.html\">signalfd(2)</a></p>"},{"title":"Android 屏幕刷新机制","_content":"\n\n\n<!-- more -->\n\n## ViewRootImpl::scheduleTraversals()\n\n```java\nvoid scheduleTraversals() {\n    // 变量 mTraversalScheduled 的分析见[小节3.1]\n    if (!mTraversalScheduled) {\n        // 将变量 mTraversalScheduled 设为 true, 防止逻辑重入\n        mTraversalScheduled = true;          \n\n        // 发起同步屏障, 分析见[小节3.2]\n        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n\n        // 方法的第2个入参 mTraversalRunnable 的类型是 Runnable, 分析见[小节3.3]\n        // 关于 Choreographer 的分析见[小节4]\n        mChoreographer.postCallback(\n                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n\n        if (!mUnbufferedInputDispatch) {\n            scheduleConsumeBatchedInput();\n        }\n        notifyRendererOfFramePending();\n        pokeDrawLockIfNeeded();\n    }\n}\n```\n\n\n\n### ViewRootImpl::mTraversalScheduled\n\n变量 mTraversalScheduled 的声明如下：\n\n```java\npublic boolean mTraversalScheduled;\n```\n\n从变量声明可以看出，mTraversalScheduled 就是一个普通的 boolean 类型的变量。\n\n在 scheduleTraversals() 方法中，变量 mTraversalScheduled 的作用是防止重复执行同一段逻辑。\n\n对变量 mTraversalScheduled 的操作之所以没有加上线程同步，是因为 Android UI 操作是单线程的，在对变量 mTraversalScheduled 的操作之前都会检查一次线程，因此没必要对其加锁进行操作。\n\nmTraversalScheduled  变量只有在执行 scheduleTraversals() 方法的过程中才有机会将 mTraversalScheduled 设为 true。\n\n\n\n### MessageQueue::postSyncBarrier()\n\n```java\npublic int postSyncBarrier() {\n    return postSyncBarrier(SystemClock.uptimeMillis());\n}\n\nprivate int postSyncBarrier(long when) {\n    synchronized (this) {\n        final int token = mNextBarrierToken++;\n        final Message msg = Message.obtain();\n        msg.markInUse();\n        msg.when = when;\n        msg.arg1 = token;\n\n        Message prev = null;\n        Message p = mMessages;\n        if (when != 0) {\n            while (p != null && p.when <= when) {\n                prev = p;\n                p = p.next;\n            }\n        }\n        if (prev != null) {\n            msg.next = p;\n            prev.next = msg;\n        } else {\n            msg.next = p;\n            mMessages = msg;\n        }\n        return token;\n    }\n}\n```\n\n关于消息队列的同步屏障，我在 [Android 同步屏障](https://hasssssssh.github.io/2021/03/25/android-sync-barrier/) 一文中分析过，在这里目的是为了更快的响应UI刷新事件，让ViewRootImpl::mTraversalRunnable 尽快被执行。\n\n\n\n### ViewRootImpl::mTraversalRunnable\n\n入参 mTraversalRunnable 是 TraversalRunnable 的实例，TraversalRunnable 的实现如下：\n\n```java\nfinal class TraversalRunnable implements Runnable {\n    @Override\n    public void run() {\n        doTraversal();\n    }\n}\n```\n\n这个 Runnable 执行的是 doTraversal() 方法，接着来看这个方法。\n\n#### ViewRootImpl::doTraversal()\n\n```java\nvoid doTraversal() {\n    if (mTraversalScheduled) {\n        // TODO\n        // 在进入 doTraversal 的核心逻辑后, 首先将变量 mTraversalScheduled 置为 false\n        // 说明即使多次调用 scheduleTraversals() 方法, \n        mTraversalScheduled = false;\n\n        // 移除消息屏障\n        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);\n\n        // 省略...\n\n        // 触发 View 的绘制流程\n        performTraversals();\n\n        // 省略...\n    }\n}\n```\n\nperformTraversals() 这个方法我曾经在之前的一篇文章 (// TODO) 中做过分析，View 的测量、布局、绘制三大流程都是由此方法发起的。\n\n现在可以知道，View 的绘制流程是在 doTraversal() 方法中发起的，而 doTraversal() 方法又被封装成一个 Runnable，接下来就要搞清楚这个 Runnable 是在什么时机被执行的。\n\n\n\n## Choreographer\n\n\n\n### Choreographer::postCallback(int, Runnable, Object)\n\n```java\npublic void postCallback(int callbackType, Runnable action, Object token) {\n    postCallbackDelayed(callbackType, action, token, 0);\n}\n```\n\n\n\n\n\n","source":"_drafts/android-display-refresh.md","raw":"---\ntitle: Android 屏幕刷新机制\ntags:\n- Graphics\ncategories:\n- [Android, Framework, Graphics]\n---\n\n\n\n<!-- more -->\n\n## ViewRootImpl::scheduleTraversals()\n\n```java\nvoid scheduleTraversals() {\n    // 变量 mTraversalScheduled 的分析见[小节3.1]\n    if (!mTraversalScheduled) {\n        // 将变量 mTraversalScheduled 设为 true, 防止逻辑重入\n        mTraversalScheduled = true;          \n\n        // 发起同步屏障, 分析见[小节3.2]\n        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n\n        // 方法的第2个入参 mTraversalRunnable 的类型是 Runnable, 分析见[小节3.3]\n        // 关于 Choreographer 的分析见[小节4]\n        mChoreographer.postCallback(\n                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n\n        if (!mUnbufferedInputDispatch) {\n            scheduleConsumeBatchedInput();\n        }\n        notifyRendererOfFramePending();\n        pokeDrawLockIfNeeded();\n    }\n}\n```\n\n\n\n### ViewRootImpl::mTraversalScheduled\n\n变量 mTraversalScheduled 的声明如下：\n\n```java\npublic boolean mTraversalScheduled;\n```\n\n从变量声明可以看出，mTraversalScheduled 就是一个普通的 boolean 类型的变量。\n\n在 scheduleTraversals() 方法中，变量 mTraversalScheduled 的作用是防止重复执行同一段逻辑。\n\n对变量 mTraversalScheduled 的操作之所以没有加上线程同步，是因为 Android UI 操作是单线程的，在对变量 mTraversalScheduled 的操作之前都会检查一次线程，因此没必要对其加锁进行操作。\n\nmTraversalScheduled  变量只有在执行 scheduleTraversals() 方法的过程中才有机会将 mTraversalScheduled 设为 true。\n\n\n\n### MessageQueue::postSyncBarrier()\n\n```java\npublic int postSyncBarrier() {\n    return postSyncBarrier(SystemClock.uptimeMillis());\n}\n\nprivate int postSyncBarrier(long when) {\n    synchronized (this) {\n        final int token = mNextBarrierToken++;\n        final Message msg = Message.obtain();\n        msg.markInUse();\n        msg.when = when;\n        msg.arg1 = token;\n\n        Message prev = null;\n        Message p = mMessages;\n        if (when != 0) {\n            while (p != null && p.when <= when) {\n                prev = p;\n                p = p.next;\n            }\n        }\n        if (prev != null) {\n            msg.next = p;\n            prev.next = msg;\n        } else {\n            msg.next = p;\n            mMessages = msg;\n        }\n        return token;\n    }\n}\n```\n\n关于消息队列的同步屏障，我在 [Android 同步屏障](https://hasssssssh.github.io/2021/03/25/android-sync-barrier/) 一文中分析过，在这里目的是为了更快的响应UI刷新事件，让ViewRootImpl::mTraversalRunnable 尽快被执行。\n\n\n\n### ViewRootImpl::mTraversalRunnable\n\n入参 mTraversalRunnable 是 TraversalRunnable 的实例，TraversalRunnable 的实现如下：\n\n```java\nfinal class TraversalRunnable implements Runnable {\n    @Override\n    public void run() {\n        doTraversal();\n    }\n}\n```\n\n这个 Runnable 执行的是 doTraversal() 方法，接着来看这个方法。\n\n#### ViewRootImpl::doTraversal()\n\n```java\nvoid doTraversal() {\n    if (mTraversalScheduled) {\n        // TODO\n        // 在进入 doTraversal 的核心逻辑后, 首先将变量 mTraversalScheduled 置为 false\n        // 说明即使多次调用 scheduleTraversals() 方法, \n        mTraversalScheduled = false;\n\n        // 移除消息屏障\n        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);\n\n        // 省略...\n\n        // 触发 View 的绘制流程\n        performTraversals();\n\n        // 省略...\n    }\n}\n```\n\nperformTraversals() 这个方法我曾经在之前的一篇文章 (// TODO) 中做过分析，View 的测量、布局、绘制三大流程都是由此方法发起的。\n\n现在可以知道，View 的绘制流程是在 doTraversal() 方法中发起的，而 doTraversal() 方法又被封装成一个 Runnable，接下来就要搞清楚这个 Runnable 是在什么时机被执行的。\n\n\n\n## Choreographer\n\n\n\n### Choreographer::postCallback(int, Runnable, Object)\n\n```java\npublic void postCallback(int callbackType, Runnable action, Object token) {\n    postCallbackDelayed(callbackType, action, token, 0);\n}\n```\n\n\n\n\n\n","slug":"android-display-refresh","published":0,"date":"2021-03-24T08:26:52.327Z","updated":"2021-11-09T12:27:37.503Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvt7aq4g0000elpre24685ab","content":"<a id=\"more\"></a>\n\n<h2 id=\"ViewRootImpl-scheduleTraversals\"><a href=\"#ViewRootImpl-scheduleTraversals\" class=\"headerlink\" title=\"ViewRootImpl::scheduleTraversals()\"></a>ViewRootImpl::scheduleTraversals()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTraversals</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 变量 mTraversalScheduled 的分析见[小节3.1]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mTraversalScheduled) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将变量 mTraversalScheduled 设为 true, 防止逻辑重入</span></span><br><span class=\"line\">        mTraversalScheduled = <span class=\"keyword\">true</span>;          </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发起同步屏障, 分析见[小节3.2]</span></span><br><span class=\"line\">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 方法的第2个入参 mTraversalRunnable 的类型是 Runnable, 分析见[小节3.3]</span></span><br><span class=\"line\">        <span class=\"comment\">// 关于 Choreographer 的分析见[小节4]</span></span><br><span class=\"line\">        mChoreographer.postCallback(</span><br><span class=\"line\">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class=\"line\">            scheduleConsumeBatchedInput();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notifyRendererOfFramePending();</span><br><span class=\"line\">        pokeDrawLockIfNeeded();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"ViewRootImpl-mTraversalScheduled\"><a href=\"#ViewRootImpl-mTraversalScheduled\" class=\"headerlink\" title=\"ViewRootImpl::mTraversalScheduled\"></a>ViewRootImpl::mTraversalScheduled</h3><p>变量 mTraversalScheduled 的声明如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> mTraversalScheduled;</span><br></pre></td></tr></table></figure>\n<p>从变量声明可以看出，mTraversalScheduled 就是一个普通的 boolean 类型的变量。</p>\n<p>在 scheduleTraversals() 方法中，变量 mTraversalScheduled 的作用是防止重复执行同一段逻辑。</p>\n<p>对变量 mTraversalScheduled 的操作之所以没有加上线程同步，是因为 Android UI 操作是单线程的，在对变量 mTraversalScheduled 的操作之前都会检查一次线程，因此没必要对其加锁进行操作。</p>\n<p>mTraversalScheduled  变量只有在执行 scheduleTraversals() 方法的过程中才有机会将 mTraversalScheduled 设为 true。</p>\n<h3 id=\"MessageQueue-postSyncBarrier\"><a href=\"#MessageQueue-postSyncBarrier\" class=\"headerlink\" title=\"MessageQueue::postSyncBarrier()\"></a>MessageQueue::postSyncBarrier()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> token = mNextBarrierToken++;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Message msg = Message.obtain();</span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        msg.arg1 = token;</span><br><span class=\"line\"></span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (when != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于消息队列的同步屏障，我在 <a href=\"https://hasssssssh.github.io/2021/03/25/android-sync-barrier/\">Android 同步屏障</a> 一文中分析过，在这里目的是为了更快的响应UI刷新事件，让ViewRootImpl::mTraversalRunnable 尽快被执行。</p>\n<h3 id=\"ViewRootImpl-mTraversalRunnable\"><a href=\"#ViewRootImpl-mTraversalRunnable\" class=\"headerlink\" title=\"ViewRootImpl::mTraversalRunnable\"></a>ViewRootImpl::mTraversalRunnable</h3><p>入参 mTraversalRunnable 是 TraversalRunnable 的实例，TraversalRunnable 的实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TraversalRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        doTraversal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个 Runnable 执行的是 doTraversal() 方法，接着来看这个方法。</p>\n<h4 id=\"ViewRootImpl-doTraversal\"><a href=\"#ViewRootImpl-doTraversal\" class=\"headerlink\" title=\"ViewRootImpl::doTraversal()\"></a>ViewRootImpl::doTraversal()</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doTraversal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTraversalScheduled) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO</span></span><br><span class=\"line\">        <span class=\"comment\">// 在进入 doTraversal 的核心逻辑后, 首先将变量 mTraversalScheduled 置为 false</span></span><br><span class=\"line\">        <span class=\"comment\">// 说明即使多次调用 scheduleTraversals() 方法, </span></span><br><span class=\"line\">        mTraversalScheduled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 移除消息屏障</span></span><br><span class=\"line\">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 省略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 触发 View 的绘制流程</span></span><br><span class=\"line\">        performTraversals();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 省略...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>performTraversals() 这个方法我曾经在之前的一篇文章 (// TODO) 中做过分析，View 的测量、布局、绘制三大流程都是由此方法发起的。</p>\n<p>现在可以知道，View 的绘制流程是在 doTraversal() 方法中发起的，而 doTraversal() 方法又被封装成一个 Runnable，接下来就要搞清楚这个 Runnable 是在什么时机被执行的。</p>\n<h2 id=\"Choreographer\"><a href=\"#Choreographer\" class=\"headerlink\" title=\"Choreographer\"></a>Choreographer</h2><h3 id=\"Choreographer-postCallback-int-Runnable-Object\"><a href=\"#Choreographer-postCallback-int-Runnable-Object\" class=\"headerlink\" title=\"Choreographer::postCallback(int, Runnable, Object)\"></a>Choreographer::postCallback(int, Runnable, Object)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postCallback</span><span class=\"params\">(<span class=\"keyword\">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class=\"line\">    postCallbackDelayed(callbackType, action, token, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ViewRootImpl-scheduleTraversals\"><a href=\"#ViewRootImpl-scheduleTraversals\" class=\"headerlink\" title=\"ViewRootImpl::scheduleTraversals()\"></a>ViewRootImpl::scheduleTraversals()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTraversals</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 变量 mTraversalScheduled 的分析见[小节3.1]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mTraversalScheduled) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将变量 mTraversalScheduled 设为 true, 防止逻辑重入</span></span><br><span class=\"line\">        mTraversalScheduled = <span class=\"keyword\">true</span>;          </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发起同步屏障, 分析见[小节3.2]</span></span><br><span class=\"line\">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 方法的第2个入参 mTraversalRunnable 的类型是 Runnable, 分析见[小节3.3]</span></span><br><span class=\"line\">        <span class=\"comment\">// 关于 Choreographer 的分析见[小节4]</span></span><br><span class=\"line\">        mChoreographer.postCallback(</span><br><span class=\"line\">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class=\"line\">            scheduleConsumeBatchedInput();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notifyRendererOfFramePending();</span><br><span class=\"line\">        pokeDrawLockIfNeeded();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"ViewRootImpl-mTraversalScheduled\"><a href=\"#ViewRootImpl-mTraversalScheduled\" class=\"headerlink\" title=\"ViewRootImpl::mTraversalScheduled\"></a>ViewRootImpl::mTraversalScheduled</h3><p>变量 mTraversalScheduled 的声明如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> mTraversalScheduled;</span><br></pre></td></tr></table></figure>\n<p>从变量声明可以看出，mTraversalScheduled 就是一个普通的 boolean 类型的变量。</p>\n<p>在 scheduleTraversals() 方法中，变量 mTraversalScheduled 的作用是防止重复执行同一段逻辑。</p>\n<p>对变量 mTraversalScheduled 的操作之所以没有加上线程同步，是因为 Android UI 操作是单线程的，在对变量 mTraversalScheduled 的操作之前都会检查一次线程，因此没必要对其加锁进行操作。</p>\n<p>mTraversalScheduled  变量只有在执行 scheduleTraversals() 方法的过程中才有机会将 mTraversalScheduled 设为 true。</p>\n<h3 id=\"MessageQueue-postSyncBarrier\"><a href=\"#MessageQueue-postSyncBarrier\" class=\"headerlink\" title=\"MessageQueue::postSyncBarrier()\"></a>MessageQueue::postSyncBarrier()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> token = mNextBarrierToken++;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Message msg = Message.obtain();</span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        msg.arg1 = token;</span><br><span class=\"line\"></span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (when != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于消息队列的同步屏障，我在 <a href=\"https://hasssssssh.github.io/2021/03/25/android-sync-barrier/\">Android 同步屏障</a> 一文中分析过，在这里目的是为了更快的响应UI刷新事件，让ViewRootImpl::mTraversalRunnable 尽快被执行。</p>\n<h3 id=\"ViewRootImpl-mTraversalRunnable\"><a href=\"#ViewRootImpl-mTraversalRunnable\" class=\"headerlink\" title=\"ViewRootImpl::mTraversalRunnable\"></a>ViewRootImpl::mTraversalRunnable</h3><p>入参 mTraversalRunnable 是 TraversalRunnable 的实例，TraversalRunnable 的实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TraversalRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        doTraversal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个 Runnable 执行的是 doTraversal() 方法，接着来看这个方法。</p>\n<h4 id=\"ViewRootImpl-doTraversal\"><a href=\"#ViewRootImpl-doTraversal\" class=\"headerlink\" title=\"ViewRootImpl::doTraversal()\"></a>ViewRootImpl::doTraversal()</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doTraversal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTraversalScheduled) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO</span></span><br><span class=\"line\">        <span class=\"comment\">// 在进入 doTraversal 的核心逻辑后, 首先将变量 mTraversalScheduled 置为 false</span></span><br><span class=\"line\">        <span class=\"comment\">// 说明即使多次调用 scheduleTraversals() 方法, </span></span><br><span class=\"line\">        mTraversalScheduled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 移除消息屏障</span></span><br><span class=\"line\">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 省略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 触发 View 的绘制流程</span></span><br><span class=\"line\">        performTraversals();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 省略...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>performTraversals() 这个方法我曾经在之前的一篇文章 (// TODO) 中做过分析，View 的测量、布局、绘制三大流程都是由此方法发起的。</p>\n<p>现在可以知道，View 的绘制流程是在 doTraversal() 方法中发起的，而 doTraversal() 方法又被封装成一个 Runnable，接下来就要搞清楚这个 Runnable 是在什么时机被执行的。</p>\n<h2 id=\"Choreographer\"><a href=\"#Choreographer\" class=\"headerlink\" title=\"Choreographer\"></a>Choreographer</h2><h3 id=\"Choreographer-postCallback-int-Runnable-Object\"><a href=\"#Choreographer-postCallback-int-Runnable-Object\" class=\"headerlink\" title=\"Choreographer::postCallback(int, Runnable, Object)\"></a>Choreographer::postCallback(int, Runnable, Object)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postCallback</span><span class=\"params\">(<span class=\"keyword\">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class=\"line\">    postCallbackDelayed(callbackType, action, token, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Android 图形系统基础","mathjax":true,"_content":"\n\n\n本文将会对图形系统常见概念作一个简单的介绍和分析。\n\n<!-- more -->\n\n\n\n# 1. 计算机图形系统\n\n一个计算机图形系统可以简单分为三个部分：\n\n- 图形输入设备（鼠标、键盘、扫描仪等）\n- CPU、GPU\n- 图形输出设备（显示器、打印机等）\n\n图像的显示过程可以简单总结为：CPU 负责计算数据，把计算好数据交给 GPU，然后 GPU 会对图形数据进行渲染，渲染完毕之后会数据放置到缓冲区当中，最后显示器负责取出缓冲区中的数据并呈现到屏幕上。\n\n\n\n# 2. 帧率\n\n帧率 (Frame rate)，一般是表示显示器上被称为帧的连续图形出现的速率，但是有时候也会用于表示渲染引擎输出帧的速率。单位一般用 fps(frames per second) 表示。\n\n\n\n# 3. 刷新率\n\n刷新率 (Refresh rate)，表示基于光栅的显示设备显示新图像的速率。单位一般用 HZ 表示。\n\n例如，一个 60HZ 的显示器，表示显示器可以每秒重新绘图 60 次，绘制一帧画面大约需要 $\\frac{1}{60}$ 秒 。\n\n一般来说，显示器的刷新率都是固定的，但现在有一些搭载 G-sync 和 freesync 的显示器可以动态调整自身的刷新率，以此适应显卡输出的速率。\n\n\n\n# 4. 逐行扫描\n\n逐行扫描是显示设备显示运动图像的方式。通俗地说，显示器输出一帧画面，是通过电子束按照从左到右，从上到下的顺序进行屏幕扫描，一行一行输出的。\n\n\n\n# 5. 画面撕裂\n\n画面撕裂 (Screen tearing)，指的是显示设备在一次画面绘制中展示了来自多个帧信息的错误显示现象。\n\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/0/03/Tearing_%28simulated%29.jpg\" alt=\"A typical video tearing artifact (simulated image)\" style=\"zoom:30%;\" />\n\n## 5.1 原因\n\n画面撕裂本质上是渲染引擎提供帧的速率和显示器刷新率不匹配造成的。\n\n例如，假设现在有一块缓冲区，显卡输出的帧率恒定为 100FPS，而显示器的刷新率恒定为 60HZ，那么会出现以下过程：\n\n1. 在第 $\\frac{1}{100}$(0.01) 秒，显卡向缓冲区输出了一帧画面 A；\n2. 在第 $\\frac{1}{60}$(0.016) 秒，显示器从缓冲区中读取数据并绘制画面 A，这个刷新过程会在第 $\\frac{2}{60}$(0.032) 秒完成；\n3. 在第 $\\frac{2}{100}$(0.02) 秒，显卡向缓冲区输出了一帧画面 B，此时由于只有一块缓冲区，那么画面 A 的数据会被画面 B 的数据覆盖。本来，显示器绘制画面 A 会在第 $\\frac{2}{60}$(0.032) 秒完成，但是缓冲区中画面 A 的数据已经被画面 B 的数据覆盖，因此接下来显示器绘制用的是画面 B 的数据。此时，屏幕上会出现了画面 A 的一部分以及画面 B 的一部分，这个现象就是画面撕裂。\n\n\n\n# 6. 画面撕裂的解决方法\n\n经过 [小节5.1] 的分析，我们知道，当渲染引擎提供帧的速率和显示器刷新率不匹配时，很容易导致显示器读取到 \"脏数据\"，从而导致画面撕裂的现象。\n\n显然，这个是数据同步问题。要彻底解决画面撕裂问题，就必须增加一些同步机制。\n\n## 6.1 垂直同步\n\n垂直同步 (Vertical synchronization)，是指在显示器的刷新期间，显卡被禁止修改显示内存的数据，只有当显示器完成当前的刷新周期之后，显卡才可以刷新显示内存的数据。\n\n以此保证显示器在刷新期间，当前显示帧的数据不会被修改，从而避免画面撕裂的问题。\n\n### 6.1.1 **垂直消隐间隔**\n\n垂直消隐间隔 (Vertical Blank Interval)，是指扫描当前帧最后一行的结束时间和扫描下一帧第一行的开始时间两者的时间差。\n\n在开启垂直同步之后，显卡会在此期间刷新缓冲区的数据。\n\n### 6.1.2 影响\n\n#### 6.1.2.1 渲染引擎的帧速率受限\n\n在开启垂直同步之后，由于在显示器的刷新期间显卡不能输出帧数据，所以显卡输出帧的速率会受限于显示器的刷新率。\n\n例如，假设显示器的刷新率是 60HZ，在使用单缓冲区的情况下，显卡输出帧的速率最高只能达到 60FPS。\n\n#### 6.1.2.2 输入延迟\n\n输入延迟 (Input lag)，通常是指一次输入与游戏或显示器对该输入作出反应之间的任何延迟。\n\n假设显示器的刷新率是 60HZ，在开启垂直同步之后，如果在显示器刷新过程中有输入，那么这次输入到显示就可能会有约 16ms 的延迟。\n\n## 6.2 可变刷新率\n\n可变刷新率 (variable refresh rate)，此技术可以使得显示器的刷新率适应显卡输出帧的速率，从而避免画面撕裂，以及减少显示器刷新率不匹配显卡输出帧的速率造成的画面卡顿现象。\n\n### 6.2.1 技术实现\n\n[Nvidia G-Sync](https://en.wikipedia.org/wiki/Nvidia_G-Sync)\n\n[FreeSync](https://en.wikipedia.org/wiki/FreeSync)\n\n\n\n# 7. 多重缓冲\n\n使用多重缓冲可以减少画面撕裂，提高工作效率。\n\n## 7.1 双缓冲\n\n双缓冲技术将缓冲区扩展到两块，渲染引擎所有绘制操作输出的数据结果将被存储于特定的内存区域，这块区域被称为 \"后缓冲区\"，而显示器获取帧数据的内存区域被称为 \"前缓冲区\"，前缓冲区和后缓冲区是两块不同的内存。\n\n当渲染引擎绘制完成后，后缓冲区的帧数据将被 \"复制\" 到前缓冲区，事实上这个操作是通过交换表示 \"前缓冲区\" 的引用和表示 \"后缓冲区\" 的引用来实现的，因此这个操作可视为瞬间完成。\n\n// TODO: 补充画图\n\n\n\n\n\n## \n\n\n\n# 参考\n\n[计算机图形学——计算机图形系统及硬件基础](https://www.cnblogs.com/wkfvawl/p/11559508.html)\n\n[Frame rate](https://en.wikipedia.org/wiki/Frame_rate)\n\n[Refresh rate](https://en.wikipedia.org/wiki/Refresh_rate)\n\n[Screen tearing](https://en.wikipedia.org/wiki/Screen_tearing)\n\n[Vertical blanking interval](https://en.wikipedia.org/wiki/Vertical_blanking_interval)\n\n[Input lag](https://en.wikipedia.org/wiki/Input_lag)\n\n[Multiple buffering](https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics)\n\n","source":"_drafts/android-graphics-basis.md","raw":"---\ntitle: Android 图形系统基础\ntags:\n- Basis\n- Graphics\ncategories:\n- [Graphics]\nmathjax: true\n---\n\n\n\n本文将会对图形系统常见概念作一个简单的介绍和分析。\n\n<!-- more -->\n\n\n\n# 1. 计算机图形系统\n\n一个计算机图形系统可以简单分为三个部分：\n\n- 图形输入设备（鼠标、键盘、扫描仪等）\n- CPU、GPU\n- 图形输出设备（显示器、打印机等）\n\n图像的显示过程可以简单总结为：CPU 负责计算数据，把计算好数据交给 GPU，然后 GPU 会对图形数据进行渲染，渲染完毕之后会数据放置到缓冲区当中，最后显示器负责取出缓冲区中的数据并呈现到屏幕上。\n\n\n\n# 2. 帧率\n\n帧率 (Frame rate)，一般是表示显示器上被称为帧的连续图形出现的速率，但是有时候也会用于表示渲染引擎输出帧的速率。单位一般用 fps(frames per second) 表示。\n\n\n\n# 3. 刷新率\n\n刷新率 (Refresh rate)，表示基于光栅的显示设备显示新图像的速率。单位一般用 HZ 表示。\n\n例如，一个 60HZ 的显示器，表示显示器可以每秒重新绘图 60 次，绘制一帧画面大约需要 $\\frac{1}{60}$ 秒 。\n\n一般来说，显示器的刷新率都是固定的，但现在有一些搭载 G-sync 和 freesync 的显示器可以动态调整自身的刷新率，以此适应显卡输出的速率。\n\n\n\n# 4. 逐行扫描\n\n逐行扫描是显示设备显示运动图像的方式。通俗地说，显示器输出一帧画面，是通过电子束按照从左到右，从上到下的顺序进行屏幕扫描，一行一行输出的。\n\n\n\n# 5. 画面撕裂\n\n画面撕裂 (Screen tearing)，指的是显示设备在一次画面绘制中展示了来自多个帧信息的错误显示现象。\n\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/0/03/Tearing_%28simulated%29.jpg\" alt=\"A typical video tearing artifact (simulated image)\" style=\"zoom:30%;\" />\n\n## 5.1 原因\n\n画面撕裂本质上是渲染引擎提供帧的速率和显示器刷新率不匹配造成的。\n\n例如，假设现在有一块缓冲区，显卡输出的帧率恒定为 100FPS，而显示器的刷新率恒定为 60HZ，那么会出现以下过程：\n\n1. 在第 $\\frac{1}{100}$(0.01) 秒，显卡向缓冲区输出了一帧画面 A；\n2. 在第 $\\frac{1}{60}$(0.016) 秒，显示器从缓冲区中读取数据并绘制画面 A，这个刷新过程会在第 $\\frac{2}{60}$(0.032) 秒完成；\n3. 在第 $\\frac{2}{100}$(0.02) 秒，显卡向缓冲区输出了一帧画面 B，此时由于只有一块缓冲区，那么画面 A 的数据会被画面 B 的数据覆盖。本来，显示器绘制画面 A 会在第 $\\frac{2}{60}$(0.032) 秒完成，但是缓冲区中画面 A 的数据已经被画面 B 的数据覆盖，因此接下来显示器绘制用的是画面 B 的数据。此时，屏幕上会出现了画面 A 的一部分以及画面 B 的一部分，这个现象就是画面撕裂。\n\n\n\n# 6. 画面撕裂的解决方法\n\n经过 [小节5.1] 的分析，我们知道，当渲染引擎提供帧的速率和显示器刷新率不匹配时，很容易导致显示器读取到 \"脏数据\"，从而导致画面撕裂的现象。\n\n显然，这个是数据同步问题。要彻底解决画面撕裂问题，就必须增加一些同步机制。\n\n## 6.1 垂直同步\n\n垂直同步 (Vertical synchronization)，是指在显示器的刷新期间，显卡被禁止修改显示内存的数据，只有当显示器完成当前的刷新周期之后，显卡才可以刷新显示内存的数据。\n\n以此保证显示器在刷新期间，当前显示帧的数据不会被修改，从而避免画面撕裂的问题。\n\n### 6.1.1 **垂直消隐间隔**\n\n垂直消隐间隔 (Vertical Blank Interval)，是指扫描当前帧最后一行的结束时间和扫描下一帧第一行的开始时间两者的时间差。\n\n在开启垂直同步之后，显卡会在此期间刷新缓冲区的数据。\n\n### 6.1.2 影响\n\n#### 6.1.2.1 渲染引擎的帧速率受限\n\n在开启垂直同步之后，由于在显示器的刷新期间显卡不能输出帧数据，所以显卡输出帧的速率会受限于显示器的刷新率。\n\n例如，假设显示器的刷新率是 60HZ，在使用单缓冲区的情况下，显卡输出帧的速率最高只能达到 60FPS。\n\n#### 6.1.2.2 输入延迟\n\n输入延迟 (Input lag)，通常是指一次输入与游戏或显示器对该输入作出反应之间的任何延迟。\n\n假设显示器的刷新率是 60HZ，在开启垂直同步之后，如果在显示器刷新过程中有输入，那么这次输入到显示就可能会有约 16ms 的延迟。\n\n## 6.2 可变刷新率\n\n可变刷新率 (variable refresh rate)，此技术可以使得显示器的刷新率适应显卡输出帧的速率，从而避免画面撕裂，以及减少显示器刷新率不匹配显卡输出帧的速率造成的画面卡顿现象。\n\n### 6.2.1 技术实现\n\n[Nvidia G-Sync](https://en.wikipedia.org/wiki/Nvidia_G-Sync)\n\n[FreeSync](https://en.wikipedia.org/wiki/FreeSync)\n\n\n\n# 7. 多重缓冲\n\n使用多重缓冲可以减少画面撕裂，提高工作效率。\n\n## 7.1 双缓冲\n\n双缓冲技术将缓冲区扩展到两块，渲染引擎所有绘制操作输出的数据结果将被存储于特定的内存区域，这块区域被称为 \"后缓冲区\"，而显示器获取帧数据的内存区域被称为 \"前缓冲区\"，前缓冲区和后缓冲区是两块不同的内存。\n\n当渲染引擎绘制完成后，后缓冲区的帧数据将被 \"复制\" 到前缓冲区，事实上这个操作是通过交换表示 \"前缓冲区\" 的引用和表示 \"后缓冲区\" 的引用来实现的，因此这个操作可视为瞬间完成。\n\n// TODO: 补充画图\n\n\n\n\n\n## \n\n\n\n# 参考\n\n[计算机图形学——计算机图形系统及硬件基础](https://www.cnblogs.com/wkfvawl/p/11559508.html)\n\n[Frame rate](https://en.wikipedia.org/wiki/Frame_rate)\n\n[Refresh rate](https://en.wikipedia.org/wiki/Refresh_rate)\n\n[Screen tearing](https://en.wikipedia.org/wiki/Screen_tearing)\n\n[Vertical blanking interval](https://en.wikipedia.org/wiki/Vertical_blanking_interval)\n\n[Input lag](https://en.wikipedia.org/wiki/Input_lag)\n\n[Multiple buffering](https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics)\n\n","slug":"android-graphics-basis","published":0,"date":"2021-05-18T12:58:52.142Z","updated":"2021-11-09T12:25:44.683Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvt7aq4k0001elprgcal1w0y","content":"<p>本文将会对图形系统常见概念作一个简单的介绍和分析。</p>\n<a id=\"more\"></a>\n\n\n\n<h1 id=\"1-计算机图形系统\"><a href=\"#1-计算机图形系统\" class=\"headerlink\" title=\"1. 计算机图形系统\"></a>1. 计算机图形系统</h1><p>一个计算机图形系统可以简单分为三个部分：</p>\n<ul>\n<li>图形输入设备（鼠标、键盘、扫描仪等）</li>\n<li>CPU、GPU</li>\n<li>图形输出设备（显示器、打印机等）</li>\n</ul>\n<p>图像的显示过程可以简单总结为：CPU 负责计算数据，把计算好数据交给 GPU，然后 GPU 会对图形数据进行渲染，渲染完毕之后会数据放置到缓冲区当中，最后显示器负责取出缓冲区中的数据并呈现到屏幕上。</p>\n<h1 id=\"2-帧率\"><a href=\"#2-帧率\" class=\"headerlink\" title=\"2. 帧率\"></a>2. 帧率</h1><p>帧率 (Frame rate)，一般是表示显示器上被称为帧的连续图形出现的速率，但是有时候也会用于表示渲染引擎输出帧的速率。单位一般用 fps(frames per second) 表示。</p>\n<h1 id=\"3-刷新率\"><a href=\"#3-刷新率\" class=\"headerlink\" title=\"3. 刷新率\"></a>3. 刷新率</h1><p>刷新率 (Refresh rate)，表示基于光栅的显示设备显示新图像的速率。单位一般用 HZ 表示。</p>\n<p>例如，一个 60HZ 的显示器，表示显示器可以每秒重新绘图 60 次，绘制一帧画面大约需要 $\\frac{1}{60}$ 秒 。</p>\n<p>一般来说，显示器的刷新率都是固定的，但现在有一些搭载 G-sync 和 freesync 的显示器可以动态调整自身的刷新率，以此适应显卡输出的速率。</p>\n<h1 id=\"4-逐行扫描\"><a href=\"#4-逐行扫描\" class=\"headerlink\" title=\"4. 逐行扫描\"></a>4. 逐行扫描</h1><p>逐行扫描是显示设备显示运动图像的方式。通俗地说，显示器输出一帧画面，是通过电子束按照从左到右，从上到下的顺序进行屏幕扫描，一行一行输出的。</p>\n<h1 id=\"5-画面撕裂\"><a href=\"#5-画面撕裂\" class=\"headerlink\" title=\"5. 画面撕裂\"></a>5. 画面撕裂</h1><p>画面撕裂 (Screen tearing)，指的是显示设备在一次画面绘制中展示了来自多个帧信息的错误显示现象。</p>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/0/03/Tearing_%28simulated%29.jpg\" alt=\"A typical video tearing artifact (simulated image)\" style=\"zoom:30%;\" />\n\n<h2 id=\"5-1-原因\"><a href=\"#5-1-原因\" class=\"headerlink\" title=\"5.1 原因\"></a>5.1 原因</h2><p>画面撕裂本质上是渲染引擎提供帧的速率和显示器刷新率不匹配造成的。</p>\n<p>例如，假设现在有一块缓冲区，显卡输出的帧率恒定为 100FPS，而显示器的刷新率恒定为 60HZ，那么会出现以下过程：</p>\n<ol>\n<li>在第 $\\frac{1}{100}$(0.01) 秒，显卡向缓冲区输出了一帧画面 A；</li>\n<li>在第 $\\frac{1}{60}$(0.016) 秒，显示器从缓冲区中读取数据并绘制画面 A，这个刷新过程会在第 $\\frac{2}{60}$(0.032) 秒完成；</li>\n<li>在第 $\\frac{2}{100}$(0.02) 秒，显卡向缓冲区输出了一帧画面 B，此时由于只有一块缓冲区，那么画面 A 的数据会被画面 B 的数据覆盖。本来，显示器绘制画面 A 会在第 $\\frac{2}{60}$(0.032) 秒完成，但是缓冲区中画面 A 的数据已经被画面 B 的数据覆盖，因此接下来显示器绘制用的是画面 B 的数据。此时，屏幕上会出现了画面 A 的一部分以及画面 B 的一部分，这个现象就是画面撕裂。</li>\n</ol>\n<h1 id=\"6-画面撕裂的解决方法\"><a href=\"#6-画面撕裂的解决方法\" class=\"headerlink\" title=\"6. 画面撕裂的解决方法\"></a>6. 画面撕裂的解决方法</h1><p>经过 [小节5.1] 的分析，我们知道，当渲染引擎提供帧的速率和显示器刷新率不匹配时，很容易导致显示器读取到 “脏数据”，从而导致画面撕裂的现象。</p>\n<p>显然，这个是数据同步问题。要彻底解决画面撕裂问题，就必须增加一些同步机制。</p>\n<h2 id=\"6-1-垂直同步\"><a href=\"#6-1-垂直同步\" class=\"headerlink\" title=\"6.1 垂直同步\"></a>6.1 垂直同步</h2><p>垂直同步 (Vertical synchronization)，是指在显示器的刷新期间，显卡被禁止修改显示内存的数据，只有当显示器完成当前的刷新周期之后，显卡才可以刷新显示内存的数据。</p>\n<p>以此保证显示器在刷新期间，当前显示帧的数据不会被修改，从而避免画面撕裂的问题。</p>\n<h3 id=\"6-1-1-垂直消隐间隔\"><a href=\"#6-1-1-垂直消隐间隔\" class=\"headerlink\" title=\"6.1.1 垂直消隐间隔\"></a>6.1.1 <strong>垂直消隐间隔</strong></h3><p>垂直消隐间隔 (Vertical Blank Interval)，是指扫描当前帧最后一行的结束时间和扫描下一帧第一行的开始时间两者的时间差。</p>\n<p>在开启垂直同步之后，显卡会在此期间刷新缓冲区的数据。</p>\n<h3 id=\"6-1-2-影响\"><a href=\"#6-1-2-影响\" class=\"headerlink\" title=\"6.1.2 影响\"></a>6.1.2 影响</h3><h4 id=\"6-1-2-1-渲染引擎的帧速率受限\"><a href=\"#6-1-2-1-渲染引擎的帧速率受限\" class=\"headerlink\" title=\"6.1.2.1 渲染引擎的帧速率受限\"></a>6.1.2.1 渲染引擎的帧速率受限</h4><p>在开启垂直同步之后，由于在显示器的刷新期间显卡不能输出帧数据，所以显卡输出帧的速率会受限于显示器的刷新率。</p>\n<p>例如，假设显示器的刷新率是 60HZ，在使用单缓冲区的情况下，显卡输出帧的速率最高只能达到 60FPS。</p>\n<h4 id=\"6-1-2-2-输入延迟\"><a href=\"#6-1-2-2-输入延迟\" class=\"headerlink\" title=\"6.1.2.2 输入延迟\"></a>6.1.2.2 输入延迟</h4><p>输入延迟 (Input lag)，通常是指一次输入与游戏或显示器对该输入作出反应之间的任何延迟。</p>\n<p>假设显示器的刷新率是 60HZ，在开启垂直同步之后，如果在显示器刷新过程中有输入，那么这次输入到显示就可能会有约 16ms 的延迟。</p>\n<h2 id=\"6-2-可变刷新率\"><a href=\"#6-2-可变刷新率\" class=\"headerlink\" title=\"6.2 可变刷新率\"></a>6.2 可变刷新率</h2><p>可变刷新率 (variable refresh rate)，此技术可以使得显示器的刷新率适应显卡输出帧的速率，从而避免画面撕裂，以及减少显示器刷新率不匹配显卡输出帧的速率造成的画面卡顿现象。</p>\n<h3 id=\"6-2-1-技术实现\"><a href=\"#6-2-1-技术实现\" class=\"headerlink\" title=\"6.2.1 技术实现\"></a>6.2.1 技术实现</h3><p><a href=\"https://en.wikipedia.org/wiki/Nvidia_G-Sync\">Nvidia G-Sync</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/FreeSync\">FreeSync</a></p>\n<h1 id=\"7-多重缓冲\"><a href=\"#7-多重缓冲\" class=\"headerlink\" title=\"7. 多重缓冲\"></a>7. 多重缓冲</h1><p>使用多重缓冲可以减少画面撕裂，提高工作效率。</p>\n<h2 id=\"7-1-双缓冲\"><a href=\"#7-1-双缓冲\" class=\"headerlink\" title=\"7.1 双缓冲\"></a>7.1 双缓冲</h2><p>双缓冲技术将缓冲区扩展到两块，渲染引擎所有绘制操作输出的数据结果将被存储于特定的内存区域，这块区域被称为 “后缓冲区”，而显示器获取帧数据的内存区域被称为 “前缓冲区”，前缓冲区和后缓冲区是两块不同的内存。</p>\n<p>当渲染引擎绘制完成后，后缓冲区的帧数据将被 “复制” 到前缓冲区，事实上这个操作是通过交换表示 “前缓冲区” 的引用和表示 “后缓冲区” 的引用来实现的，因此这个操作可视为瞬间完成。</p>\n<p>// TODO: 补充画图</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.cnblogs.com/wkfvawl/p/11559508.html\">计算机图形学——计算机图形系统及硬件基础</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Frame_rate\">Frame rate</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Refresh_rate\">Refresh rate</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Screen_tearing\">Screen tearing</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Vertical_blanking_interval\">Vertical blanking interval</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Input_lag\">Input lag</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics\">Multiple buffering</a></p>\n","site":{"data":{}},"excerpt":"<p>本文将会对图形系统常见概念作一个简单的介绍和分析。</p>","more":"<h1 id=\"1-计算机图形系统\"><a href=\"#1-计算机图形系统\" class=\"headerlink\" title=\"1. 计算机图形系统\"></a>1. 计算机图形系统</h1><p>一个计算机图形系统可以简单分为三个部分：</p>\n<ul>\n<li>图形输入设备（鼠标、键盘、扫描仪等）</li>\n<li>CPU、GPU</li>\n<li>图形输出设备（显示器、打印机等）</li>\n</ul>\n<p>图像的显示过程可以简单总结为：CPU 负责计算数据，把计算好数据交给 GPU，然后 GPU 会对图形数据进行渲染，渲染完毕之后会数据放置到缓冲区当中，最后显示器负责取出缓冲区中的数据并呈现到屏幕上。</p>\n<h1 id=\"2-帧率\"><a href=\"#2-帧率\" class=\"headerlink\" title=\"2. 帧率\"></a>2. 帧率</h1><p>帧率 (Frame rate)，一般是表示显示器上被称为帧的连续图形出现的速率，但是有时候也会用于表示渲染引擎输出帧的速率。单位一般用 fps(frames per second) 表示。</p>\n<h1 id=\"3-刷新率\"><a href=\"#3-刷新率\" class=\"headerlink\" title=\"3. 刷新率\"></a>3. 刷新率</h1><p>刷新率 (Refresh rate)，表示基于光栅的显示设备显示新图像的速率。单位一般用 HZ 表示。</p>\n<p>例如，一个 60HZ 的显示器，表示显示器可以每秒重新绘图 60 次，绘制一帧画面大约需要 $\\frac{1}{60}$ 秒 。</p>\n<p>一般来说，显示器的刷新率都是固定的，但现在有一些搭载 G-sync 和 freesync 的显示器可以动态调整自身的刷新率，以此适应显卡输出的速率。</p>\n<h1 id=\"4-逐行扫描\"><a href=\"#4-逐行扫描\" class=\"headerlink\" title=\"4. 逐行扫描\"></a>4. 逐行扫描</h1><p>逐行扫描是显示设备显示运动图像的方式。通俗地说，显示器输出一帧画面，是通过电子束按照从左到右，从上到下的顺序进行屏幕扫描，一行一行输出的。</p>\n<h1 id=\"5-画面撕裂\"><a href=\"#5-画面撕裂\" class=\"headerlink\" title=\"5. 画面撕裂\"></a>5. 画面撕裂</h1><p>画面撕裂 (Screen tearing)，指的是显示设备在一次画面绘制中展示了来自多个帧信息的错误显示现象。</p>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/0/03/Tearing_%28simulated%29.jpg\" alt=\"A typical video tearing artifact (simulated image)\" style=\"zoom:30%;\" />\n\n<h2 id=\"5-1-原因\"><a href=\"#5-1-原因\" class=\"headerlink\" title=\"5.1 原因\"></a>5.1 原因</h2><p>画面撕裂本质上是渲染引擎提供帧的速率和显示器刷新率不匹配造成的。</p>\n<p>例如，假设现在有一块缓冲区，显卡输出的帧率恒定为 100FPS，而显示器的刷新率恒定为 60HZ，那么会出现以下过程：</p>\n<ol>\n<li>在第 $\\frac{1}{100}$(0.01) 秒，显卡向缓冲区输出了一帧画面 A；</li>\n<li>在第 $\\frac{1}{60}$(0.016) 秒，显示器从缓冲区中读取数据并绘制画面 A，这个刷新过程会在第 $\\frac{2}{60}$(0.032) 秒完成；</li>\n<li>在第 $\\frac{2}{100}$(0.02) 秒，显卡向缓冲区输出了一帧画面 B，此时由于只有一块缓冲区，那么画面 A 的数据会被画面 B 的数据覆盖。本来，显示器绘制画面 A 会在第 $\\frac{2}{60}$(0.032) 秒完成，但是缓冲区中画面 A 的数据已经被画面 B 的数据覆盖，因此接下来显示器绘制用的是画面 B 的数据。此时，屏幕上会出现了画面 A 的一部分以及画面 B 的一部分，这个现象就是画面撕裂。</li>\n</ol>\n<h1 id=\"6-画面撕裂的解决方法\"><a href=\"#6-画面撕裂的解决方法\" class=\"headerlink\" title=\"6. 画面撕裂的解决方法\"></a>6. 画面撕裂的解决方法</h1><p>经过 [小节5.1] 的分析，我们知道，当渲染引擎提供帧的速率和显示器刷新率不匹配时，很容易导致显示器读取到 “脏数据”，从而导致画面撕裂的现象。</p>\n<p>显然，这个是数据同步问题。要彻底解决画面撕裂问题，就必须增加一些同步机制。</p>\n<h2 id=\"6-1-垂直同步\"><a href=\"#6-1-垂直同步\" class=\"headerlink\" title=\"6.1 垂直同步\"></a>6.1 垂直同步</h2><p>垂直同步 (Vertical synchronization)，是指在显示器的刷新期间，显卡被禁止修改显示内存的数据，只有当显示器完成当前的刷新周期之后，显卡才可以刷新显示内存的数据。</p>\n<p>以此保证显示器在刷新期间，当前显示帧的数据不会被修改，从而避免画面撕裂的问题。</p>\n<h3 id=\"6-1-1-垂直消隐间隔\"><a href=\"#6-1-1-垂直消隐间隔\" class=\"headerlink\" title=\"6.1.1 垂直消隐间隔\"></a>6.1.1 <strong>垂直消隐间隔</strong></h3><p>垂直消隐间隔 (Vertical Blank Interval)，是指扫描当前帧最后一行的结束时间和扫描下一帧第一行的开始时间两者的时间差。</p>\n<p>在开启垂直同步之后，显卡会在此期间刷新缓冲区的数据。</p>\n<h3 id=\"6-1-2-影响\"><a href=\"#6-1-2-影响\" class=\"headerlink\" title=\"6.1.2 影响\"></a>6.1.2 影响</h3><h4 id=\"6-1-2-1-渲染引擎的帧速率受限\"><a href=\"#6-1-2-1-渲染引擎的帧速率受限\" class=\"headerlink\" title=\"6.1.2.1 渲染引擎的帧速率受限\"></a>6.1.2.1 渲染引擎的帧速率受限</h4><p>在开启垂直同步之后，由于在显示器的刷新期间显卡不能输出帧数据，所以显卡输出帧的速率会受限于显示器的刷新率。</p>\n<p>例如，假设显示器的刷新率是 60HZ，在使用单缓冲区的情况下，显卡输出帧的速率最高只能达到 60FPS。</p>\n<h4 id=\"6-1-2-2-输入延迟\"><a href=\"#6-1-2-2-输入延迟\" class=\"headerlink\" title=\"6.1.2.2 输入延迟\"></a>6.1.2.2 输入延迟</h4><p>输入延迟 (Input lag)，通常是指一次输入与游戏或显示器对该输入作出反应之间的任何延迟。</p>\n<p>假设显示器的刷新率是 60HZ，在开启垂直同步之后，如果在显示器刷新过程中有输入，那么这次输入到显示就可能会有约 16ms 的延迟。</p>\n<h2 id=\"6-2-可变刷新率\"><a href=\"#6-2-可变刷新率\" class=\"headerlink\" title=\"6.2 可变刷新率\"></a>6.2 可变刷新率</h2><p>可变刷新率 (variable refresh rate)，此技术可以使得显示器的刷新率适应显卡输出帧的速率，从而避免画面撕裂，以及减少显示器刷新率不匹配显卡输出帧的速率造成的画面卡顿现象。</p>\n<h3 id=\"6-2-1-技术实现\"><a href=\"#6-2-1-技术实现\" class=\"headerlink\" title=\"6.2.1 技术实现\"></a>6.2.1 技术实现</h3><p><a href=\"https://en.wikipedia.org/wiki/Nvidia_G-Sync\">Nvidia G-Sync</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/FreeSync\">FreeSync</a></p>\n<h1 id=\"7-多重缓冲\"><a href=\"#7-多重缓冲\" class=\"headerlink\" title=\"7. 多重缓冲\"></a>7. 多重缓冲</h1><p>使用多重缓冲可以减少画面撕裂，提高工作效率。</p>\n<h2 id=\"7-1-双缓冲\"><a href=\"#7-1-双缓冲\" class=\"headerlink\" title=\"7.1 双缓冲\"></a>7.1 双缓冲</h2><p>双缓冲技术将缓冲区扩展到两块，渲染引擎所有绘制操作输出的数据结果将被存储于特定的内存区域，这块区域被称为 “后缓冲区”，而显示器获取帧数据的内存区域被称为 “前缓冲区”，前缓冲区和后缓冲区是两块不同的内存。</p>\n<p>当渲染引擎绘制完成后，后缓冲区的帧数据将被 “复制” 到前缓冲区，事实上这个操作是通过交换表示 “前缓冲区” 的引用和表示 “后缓冲区” 的引用来实现的，因此这个操作可视为瞬间完成。</p>\n<p>// TODO: 补充画图</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.cnblogs.com/wkfvawl/p/11559508.html\">计算机图形学——计算机图形系统及硬件基础</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Frame_rate\">Frame rate</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Refresh_rate\">Refresh rate</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Screen_tearing\">Screen tearing</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Vertical_blanking_interval\">Vertical blanking interval</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Input_lag\">Input lag</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics\">Multiple buffering</a></p>"},{"title":"图形系统基础","mathjax":true,"_content":"\n\n\n本文将会对图形系统常见概念作一个简单的介绍和分析。\n\n<!-- more -->\n\n\n\n# 1. 计算机图形系统\n\n一个计算机图形系统可以简单分为三个部分：\n\n- 图形输入设备（鼠标、键盘、扫描仪等）\n- CPU、GPU\n- 图形输出设备（显示器、打印机等）\n\n图像的显示过程可以简单总结为：CPU 负责计算数据，把计算好数据交给 GPU，然后 GPU 会对图形数据进行渲染，渲染完毕之后会数据放置到缓冲区当中，最后显示器负责取出缓冲区中的数据并呈现到屏幕上。\n\n\n\n# 2. 帧率\n\n帧率 (Frame rate)，一般是表示显示器上被称为帧的连续图形出现的速率，但是有时候也会用于表示渲染引擎输出帧的速率。单位一般用 fps(frames per second) 表示。\n\n\n\n# 3. 刷新率\n\n刷新率 (Refresh rate)，表示基于光栅的显示设备显示新图像的速率。单位一般用 HZ 表示。\n\n例如，一个 60HZ 的显示器，表示显示器可以每秒重新绘图 60 次，绘制一帧画面大约需要 $\\frac{1}{60}$ 秒 。\n\n一般来说，显示器的刷新率都是固定的，但现在有一些搭载 G-sync 和 freesync 的显示器可以动态调整自身的刷新率，以此适应显卡输出的速率。\n\n\n\n# 4. 逐行扫描\n\n逐行扫描是显示设备显示运动图像的方式。通俗地说，显示器输出一帧画面，是通过电子束按照从左到右，从上到下的顺序进行屏幕扫描，一行一行输出的。\n\n\n\n# 5. 画面撕裂\n\n画面撕裂 (Screen tearing)，指的是显示设备在一次画面绘制中展示了来自多个帧信息的错误显示现象。\n\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/0/03/Tearing_%28simulated%29.jpg\" alt=\"A typical video tearing artifact (simulated image)\" style=\"zoom:30%;\" />\n\n## 5.1 原因\n\n画面撕裂本质上是渲染引擎提供帧的速率和显示器刷新率不匹配造成的。\n\n例如，假设现在有一块缓冲区，显卡输出的帧率恒定为 100FPS，而显示器的刷新率恒定为 60HZ，那么会出现以下过程：\n\n1. 在第 $\\frac{1}{100}$(0.01) 秒，显卡向缓冲区输出了一帧画面 A；\n2. 在第 $\\frac{1}{60}$(0.016) 秒，显示器从缓冲区中读取数据并绘制画面 A，这个刷新过程会在第 $\\frac{2}{60}$(0.032) 秒完成；\n3. 在第 $\\frac{2}{100}$(0.02) 秒，显卡向缓冲区输出了一帧画面 B，此时由于只有一块缓冲区，那么画面 A 的数据会被画面 B 的数据覆盖。本来，显示器绘制画面 A 会在第 $\\frac{2}{60}$(0.032) 秒完成，但是缓冲区中画面 A 的数据已经被画面 B 的数据覆盖，因此接下来显示器绘制用的是画面 B 的数据。此时，屏幕上会出现了画面 A 的一部分以及画面 B 的一部分，这个现象就是画面撕裂。\n\n\n\n# 6. 画面撕裂的解决方法\n\n经过 [小节5.1] 的分析，我们知道，当渲染引擎提供帧的速率和显示器刷新率不匹配时，很容易导致显示器读取到 \"脏数据\"，从而导致画面撕裂的现象。\n\n显然，这个是数据同步问题。要彻底解决画面撕裂问题，就必须增加一些同步机制。\n\n## 6.1 垂直同步\n\n垂直同步 (Vertical synchronization)，是指在显示器的刷新期间，显卡被禁止修改显示内存的数据，只有当显示器完成当前的刷新周期之后，显卡才可以刷新显示内存的数据。\n\n以此保证显示器在刷新期间，当前显示帧的数据不会被修改，从而避免画面撕裂的问题。\n\n### 6.1.1 **垂直消隐间隔**\n\n垂直消隐间隔 (Vertical Blank Interval)，是指扫描当前帧最后一行的结束时间和扫描下一帧第一行的开始时间两者的时间差。\n\n在开启垂直同步之后，显卡会在此期间刷新缓冲区的数据。\n\n### 6.1.2 影响\n\n#### 6.1.2.1 渲染引擎的帧速率受限\n\n在开启垂直同步之后，由于在显示器的刷新期间显卡不能输出帧数据，所以显卡输出帧的速率会受限于显示器的刷新率。\n\n例如，假设显示器的刷新率是 60HZ，在使用单缓冲区的情况下，显卡输出帧的速率最高只能达到 60FPS。\n\n#### 6.1.2.2 输入延迟\n\n输入延迟 (Input lag)，通常是指一次输入与游戏或显示器对该输入作出反应之间的任何延迟。\n\n假设显示器的刷新率是 60HZ，在开启垂直同步之后，如果在显示器刷新过程中有输入，那么这次输入到显示就可能会有约 16ms 的延迟。\n\n## 6.2 可变刷新率\n\n可变刷新率 (variable refresh rate)，此技术可以使得显示器的刷新率适应显卡输出帧的速率，从而避免画面撕裂，以及减少显示器刷新率不匹配显卡输出帧的速率造成的画面卡顿现象。\n\n### 6.2.1 技术实现\n\n[Nvidia G-Sync](https://en.wikipedia.org/wiki/Nvidia_G-Sync)\n\n[FreeSync](https://en.wikipedia.org/wiki/FreeSync)\n\n\n\n# 7. 多重缓冲\n\n使用多重缓冲可以减少画面撕裂，提高工作效率。\n\n## 7.1 双缓冲\n\n双缓冲技术将缓冲区扩展到两块，渲染引擎所有绘制操作输出的数据结果将被存储于特定的内存区域，这块区域被称为 \"后缓冲区\"，而显示器获取帧数据的内存区域被称为 \"前缓冲区\"，前缓冲区和后缓冲区是两块不同的内存。\n\n当渲染引擎绘制完成后，后缓冲区的帧数据将被 \"复制\" 到前缓冲区，事实上这个操作是通过交换表示 \"前缓冲区\" 的引用和表示 \"后缓冲区\" 的引用来实现的，因此这个操作可视为瞬间完成。\n\n// TODO: 补充画图\n\n\n\n\n\n## \n\n\n\n# 参考\n\n[计算机图形学——计算机图形系统及硬件基础](https://www.cnblogs.com/wkfvawl/p/11559508.html)\n\n[Frame rate](https://en.wikipedia.org/wiki/Frame_rate)\n\n[Refresh rate](https://en.wikipedia.org/wiki/Refresh_rate)\n\n[Screen tearing](https://en.wikipedia.org/wiki/Screen_tearing)\n\n[Vertical blanking interval](https://en.wikipedia.org/wiki/Vertical_blanking_interval)\n\n[Input lag](https://en.wikipedia.org/wiki/Input_lag)\n\n[Multiple buffering](https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics)\n\n","source":"_drafts/graphics-basis.md","raw":"---\ntitle: 图形系统基础\ntags:\n- Basis\n- Graphics\ncategories:\n- [Graphics]\nmathjax: true\n---\n\n\n\n本文将会对图形系统常见概念作一个简单的介绍和分析。\n\n<!-- more -->\n\n\n\n# 1. 计算机图形系统\n\n一个计算机图形系统可以简单分为三个部分：\n\n- 图形输入设备（鼠标、键盘、扫描仪等）\n- CPU、GPU\n- 图形输出设备（显示器、打印机等）\n\n图像的显示过程可以简单总结为：CPU 负责计算数据，把计算好数据交给 GPU，然后 GPU 会对图形数据进行渲染，渲染完毕之后会数据放置到缓冲区当中，最后显示器负责取出缓冲区中的数据并呈现到屏幕上。\n\n\n\n# 2. 帧率\n\n帧率 (Frame rate)，一般是表示显示器上被称为帧的连续图形出现的速率，但是有时候也会用于表示渲染引擎输出帧的速率。单位一般用 fps(frames per second) 表示。\n\n\n\n# 3. 刷新率\n\n刷新率 (Refresh rate)，表示基于光栅的显示设备显示新图像的速率。单位一般用 HZ 表示。\n\n例如，一个 60HZ 的显示器，表示显示器可以每秒重新绘图 60 次，绘制一帧画面大约需要 $\\frac{1}{60}$ 秒 。\n\n一般来说，显示器的刷新率都是固定的，但现在有一些搭载 G-sync 和 freesync 的显示器可以动态调整自身的刷新率，以此适应显卡输出的速率。\n\n\n\n# 4. 逐行扫描\n\n逐行扫描是显示设备显示运动图像的方式。通俗地说，显示器输出一帧画面，是通过电子束按照从左到右，从上到下的顺序进行屏幕扫描，一行一行输出的。\n\n\n\n# 5. 画面撕裂\n\n画面撕裂 (Screen tearing)，指的是显示设备在一次画面绘制中展示了来自多个帧信息的错误显示现象。\n\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/0/03/Tearing_%28simulated%29.jpg\" alt=\"A typical video tearing artifact (simulated image)\" style=\"zoom:30%;\" />\n\n## 5.1 原因\n\n画面撕裂本质上是渲染引擎提供帧的速率和显示器刷新率不匹配造成的。\n\n例如，假设现在有一块缓冲区，显卡输出的帧率恒定为 100FPS，而显示器的刷新率恒定为 60HZ，那么会出现以下过程：\n\n1. 在第 $\\frac{1}{100}$(0.01) 秒，显卡向缓冲区输出了一帧画面 A；\n2. 在第 $\\frac{1}{60}$(0.016) 秒，显示器从缓冲区中读取数据并绘制画面 A，这个刷新过程会在第 $\\frac{2}{60}$(0.032) 秒完成；\n3. 在第 $\\frac{2}{100}$(0.02) 秒，显卡向缓冲区输出了一帧画面 B，此时由于只有一块缓冲区，那么画面 A 的数据会被画面 B 的数据覆盖。本来，显示器绘制画面 A 会在第 $\\frac{2}{60}$(0.032) 秒完成，但是缓冲区中画面 A 的数据已经被画面 B 的数据覆盖，因此接下来显示器绘制用的是画面 B 的数据。此时，屏幕上会出现了画面 A 的一部分以及画面 B 的一部分，这个现象就是画面撕裂。\n\n\n\n# 6. 画面撕裂的解决方法\n\n经过 [小节5.1] 的分析，我们知道，当渲染引擎提供帧的速率和显示器刷新率不匹配时，很容易导致显示器读取到 \"脏数据\"，从而导致画面撕裂的现象。\n\n显然，这个是数据同步问题。要彻底解决画面撕裂问题，就必须增加一些同步机制。\n\n## 6.1 垂直同步\n\n垂直同步 (Vertical synchronization)，是指在显示器的刷新期间，显卡被禁止修改显示内存的数据，只有当显示器完成当前的刷新周期之后，显卡才可以刷新显示内存的数据。\n\n以此保证显示器在刷新期间，当前显示帧的数据不会被修改，从而避免画面撕裂的问题。\n\n### 6.1.1 **垂直消隐间隔**\n\n垂直消隐间隔 (Vertical Blank Interval)，是指扫描当前帧最后一行的结束时间和扫描下一帧第一行的开始时间两者的时间差。\n\n在开启垂直同步之后，显卡会在此期间刷新缓冲区的数据。\n\n### 6.1.2 影响\n\n#### 6.1.2.1 渲染引擎的帧速率受限\n\n在开启垂直同步之后，由于在显示器的刷新期间显卡不能输出帧数据，所以显卡输出帧的速率会受限于显示器的刷新率。\n\n例如，假设显示器的刷新率是 60HZ，在使用单缓冲区的情况下，显卡输出帧的速率最高只能达到 60FPS。\n\n#### 6.1.2.2 输入延迟\n\n输入延迟 (Input lag)，通常是指一次输入与游戏或显示器对该输入作出反应之间的任何延迟。\n\n假设显示器的刷新率是 60HZ，在开启垂直同步之后，如果在显示器刷新过程中有输入，那么这次输入到显示就可能会有约 16ms 的延迟。\n\n## 6.2 可变刷新率\n\n可变刷新率 (variable refresh rate)，此技术可以使得显示器的刷新率适应显卡输出帧的速率，从而避免画面撕裂，以及减少显示器刷新率不匹配显卡输出帧的速率造成的画面卡顿现象。\n\n### 6.2.1 技术实现\n\n[Nvidia G-Sync](https://en.wikipedia.org/wiki/Nvidia_G-Sync)\n\n[FreeSync](https://en.wikipedia.org/wiki/FreeSync)\n\n\n\n# 7. 多重缓冲\n\n使用多重缓冲可以减少画面撕裂，提高工作效率。\n\n## 7.1 双缓冲\n\n双缓冲技术将缓冲区扩展到两块，渲染引擎所有绘制操作输出的数据结果将被存储于特定的内存区域，这块区域被称为 \"后缓冲区\"，而显示器获取帧数据的内存区域被称为 \"前缓冲区\"，前缓冲区和后缓冲区是两块不同的内存。\n\n当渲染引擎绘制完成后，后缓冲区的帧数据将被 \"复制\" 到前缓冲区，事实上这个操作是通过交换表示 \"前缓冲区\" 的引用和表示 \"后缓冲区\" 的引用来实现的，因此这个操作可视为瞬间完成。\n\n// TODO: 补充画图\n\n\n\n\n\n## \n\n\n\n# 参考\n\n[计算机图形学——计算机图形系统及硬件基础](https://www.cnblogs.com/wkfvawl/p/11559508.html)\n\n[Frame rate](https://en.wikipedia.org/wiki/Frame_rate)\n\n[Refresh rate](https://en.wikipedia.org/wiki/Refresh_rate)\n\n[Screen tearing](https://en.wikipedia.org/wiki/Screen_tearing)\n\n[Vertical blanking interval](https://en.wikipedia.org/wiki/Vertical_blanking_interval)\n\n[Input lag](https://en.wikipedia.org/wiki/Input_lag)\n\n[Multiple buffering](https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics)\n\n","slug":"graphics-basis","published":0,"date":"2021-03-29T09:27:18.242Z","updated":"2021-11-09T12:28:10.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvt7aq4m0003elpr3t86bkmy","content":"<p>本文将会对图形系统常见概念作一个简单的介绍和分析。</p>\n<a id=\"more\"></a>\n\n\n\n<h1 id=\"1-计算机图形系统\"><a href=\"#1-计算机图形系统\" class=\"headerlink\" title=\"1. 计算机图形系统\"></a>1. 计算机图形系统</h1><p>一个计算机图形系统可以简单分为三个部分：</p>\n<ul>\n<li>图形输入设备（鼠标、键盘、扫描仪等）</li>\n<li>CPU、GPU</li>\n<li>图形输出设备（显示器、打印机等）</li>\n</ul>\n<p>图像的显示过程可以简单总结为：CPU 负责计算数据，把计算好数据交给 GPU，然后 GPU 会对图形数据进行渲染，渲染完毕之后会数据放置到缓冲区当中，最后显示器负责取出缓冲区中的数据并呈现到屏幕上。</p>\n<h1 id=\"2-帧率\"><a href=\"#2-帧率\" class=\"headerlink\" title=\"2. 帧率\"></a>2. 帧率</h1><p>帧率 (Frame rate)，一般是表示显示器上被称为帧的连续图形出现的速率，但是有时候也会用于表示渲染引擎输出帧的速率。单位一般用 fps(frames per second) 表示。</p>\n<h1 id=\"3-刷新率\"><a href=\"#3-刷新率\" class=\"headerlink\" title=\"3. 刷新率\"></a>3. 刷新率</h1><p>刷新率 (Refresh rate)，表示基于光栅的显示设备显示新图像的速率。单位一般用 HZ 表示。</p>\n<p>例如，一个 60HZ 的显示器，表示显示器可以每秒重新绘图 60 次，绘制一帧画面大约需要 $\\frac{1}{60}$ 秒 。</p>\n<p>一般来说，显示器的刷新率都是固定的，但现在有一些搭载 G-sync 和 freesync 的显示器可以动态调整自身的刷新率，以此适应显卡输出的速率。</p>\n<h1 id=\"4-逐行扫描\"><a href=\"#4-逐行扫描\" class=\"headerlink\" title=\"4. 逐行扫描\"></a>4. 逐行扫描</h1><p>逐行扫描是显示设备显示运动图像的方式。通俗地说，显示器输出一帧画面，是通过电子束按照从左到右，从上到下的顺序进行屏幕扫描，一行一行输出的。</p>\n<h1 id=\"5-画面撕裂\"><a href=\"#5-画面撕裂\" class=\"headerlink\" title=\"5. 画面撕裂\"></a>5. 画面撕裂</h1><p>画面撕裂 (Screen tearing)，指的是显示设备在一次画面绘制中展示了来自多个帧信息的错误显示现象。</p>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/0/03/Tearing_%28simulated%29.jpg\" alt=\"A typical video tearing artifact (simulated image)\" style=\"zoom:30%;\" />\n\n<h2 id=\"5-1-原因\"><a href=\"#5-1-原因\" class=\"headerlink\" title=\"5.1 原因\"></a>5.1 原因</h2><p>画面撕裂本质上是渲染引擎提供帧的速率和显示器刷新率不匹配造成的。</p>\n<p>例如，假设现在有一块缓冲区，显卡输出的帧率恒定为 100FPS，而显示器的刷新率恒定为 60HZ，那么会出现以下过程：</p>\n<ol>\n<li>在第 $\\frac{1}{100}$(0.01) 秒，显卡向缓冲区输出了一帧画面 A；</li>\n<li>在第 $\\frac{1}{60}$(0.016) 秒，显示器从缓冲区中读取数据并绘制画面 A，这个刷新过程会在第 $\\frac{2}{60}$(0.032) 秒完成；</li>\n<li>在第 $\\frac{2}{100}$(0.02) 秒，显卡向缓冲区输出了一帧画面 B，此时由于只有一块缓冲区，那么画面 A 的数据会被画面 B 的数据覆盖。本来，显示器绘制画面 A 会在第 $\\frac{2}{60}$(0.032) 秒完成，但是缓冲区中画面 A 的数据已经被画面 B 的数据覆盖，因此接下来显示器绘制用的是画面 B 的数据。此时，屏幕上会出现了画面 A 的一部分以及画面 B 的一部分，这个现象就是画面撕裂。</li>\n</ol>\n<h1 id=\"6-画面撕裂的解决方法\"><a href=\"#6-画面撕裂的解决方法\" class=\"headerlink\" title=\"6. 画面撕裂的解决方法\"></a>6. 画面撕裂的解决方法</h1><p>经过 [小节5.1] 的分析，我们知道，当渲染引擎提供帧的速率和显示器刷新率不匹配时，很容易导致显示器读取到 “脏数据”，从而导致画面撕裂的现象。</p>\n<p>显然，这个是数据同步问题。要彻底解决画面撕裂问题，就必须增加一些同步机制。</p>\n<h2 id=\"6-1-垂直同步\"><a href=\"#6-1-垂直同步\" class=\"headerlink\" title=\"6.1 垂直同步\"></a>6.1 垂直同步</h2><p>垂直同步 (Vertical synchronization)，是指在显示器的刷新期间，显卡被禁止修改显示内存的数据，只有当显示器完成当前的刷新周期之后，显卡才可以刷新显示内存的数据。</p>\n<p>以此保证显示器在刷新期间，当前显示帧的数据不会被修改，从而避免画面撕裂的问题。</p>\n<h3 id=\"6-1-1-垂直消隐间隔\"><a href=\"#6-1-1-垂直消隐间隔\" class=\"headerlink\" title=\"6.1.1 垂直消隐间隔\"></a>6.1.1 <strong>垂直消隐间隔</strong></h3><p>垂直消隐间隔 (Vertical Blank Interval)，是指扫描当前帧最后一行的结束时间和扫描下一帧第一行的开始时间两者的时间差。</p>\n<p>在开启垂直同步之后，显卡会在此期间刷新缓冲区的数据。</p>\n<h3 id=\"6-1-2-影响\"><a href=\"#6-1-2-影响\" class=\"headerlink\" title=\"6.1.2 影响\"></a>6.1.2 影响</h3><h4 id=\"6-1-2-1-渲染引擎的帧速率受限\"><a href=\"#6-1-2-1-渲染引擎的帧速率受限\" class=\"headerlink\" title=\"6.1.2.1 渲染引擎的帧速率受限\"></a>6.1.2.1 渲染引擎的帧速率受限</h4><p>在开启垂直同步之后，由于在显示器的刷新期间显卡不能输出帧数据，所以显卡输出帧的速率会受限于显示器的刷新率。</p>\n<p>例如，假设显示器的刷新率是 60HZ，在使用单缓冲区的情况下，显卡输出帧的速率最高只能达到 60FPS。</p>\n<h4 id=\"6-1-2-2-输入延迟\"><a href=\"#6-1-2-2-输入延迟\" class=\"headerlink\" title=\"6.1.2.2 输入延迟\"></a>6.1.2.2 输入延迟</h4><p>输入延迟 (Input lag)，通常是指一次输入与游戏或显示器对该输入作出反应之间的任何延迟。</p>\n<p>假设显示器的刷新率是 60HZ，在开启垂直同步之后，如果在显示器刷新过程中有输入，那么这次输入到显示就可能会有约 16ms 的延迟。</p>\n<h2 id=\"6-2-可变刷新率\"><a href=\"#6-2-可变刷新率\" class=\"headerlink\" title=\"6.2 可变刷新率\"></a>6.2 可变刷新率</h2><p>可变刷新率 (variable refresh rate)，此技术可以使得显示器的刷新率适应显卡输出帧的速率，从而避免画面撕裂，以及减少显示器刷新率不匹配显卡输出帧的速率造成的画面卡顿现象。</p>\n<h3 id=\"6-2-1-技术实现\"><a href=\"#6-2-1-技术实现\" class=\"headerlink\" title=\"6.2.1 技术实现\"></a>6.2.1 技术实现</h3><p><a href=\"https://en.wikipedia.org/wiki/Nvidia_G-Sync\">Nvidia G-Sync</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/FreeSync\">FreeSync</a></p>\n<h1 id=\"7-多重缓冲\"><a href=\"#7-多重缓冲\" class=\"headerlink\" title=\"7. 多重缓冲\"></a>7. 多重缓冲</h1><p>使用多重缓冲可以减少画面撕裂，提高工作效率。</p>\n<h2 id=\"7-1-双缓冲\"><a href=\"#7-1-双缓冲\" class=\"headerlink\" title=\"7.1 双缓冲\"></a>7.1 双缓冲</h2><p>双缓冲技术将缓冲区扩展到两块，渲染引擎所有绘制操作输出的数据结果将被存储于特定的内存区域，这块区域被称为 “后缓冲区”，而显示器获取帧数据的内存区域被称为 “前缓冲区”，前缓冲区和后缓冲区是两块不同的内存。</p>\n<p>当渲染引擎绘制完成后，后缓冲区的帧数据将被 “复制” 到前缓冲区，事实上这个操作是通过交换表示 “前缓冲区” 的引用和表示 “后缓冲区” 的引用来实现的，因此这个操作可视为瞬间完成。</p>\n<p>// TODO: 补充画图</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.cnblogs.com/wkfvawl/p/11559508.html\">计算机图形学——计算机图形系统及硬件基础</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Frame_rate\">Frame rate</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Refresh_rate\">Refresh rate</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Screen_tearing\">Screen tearing</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Vertical_blanking_interval\">Vertical blanking interval</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Input_lag\">Input lag</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics\">Multiple buffering</a></p>\n","site":{"data":{}},"excerpt":"<p>本文将会对图形系统常见概念作一个简单的介绍和分析。</p>","more":"<h1 id=\"1-计算机图形系统\"><a href=\"#1-计算机图形系统\" class=\"headerlink\" title=\"1. 计算机图形系统\"></a>1. 计算机图形系统</h1><p>一个计算机图形系统可以简单分为三个部分：</p>\n<ul>\n<li>图形输入设备（鼠标、键盘、扫描仪等）</li>\n<li>CPU、GPU</li>\n<li>图形输出设备（显示器、打印机等）</li>\n</ul>\n<p>图像的显示过程可以简单总结为：CPU 负责计算数据，把计算好数据交给 GPU，然后 GPU 会对图形数据进行渲染，渲染完毕之后会数据放置到缓冲区当中，最后显示器负责取出缓冲区中的数据并呈现到屏幕上。</p>\n<h1 id=\"2-帧率\"><a href=\"#2-帧率\" class=\"headerlink\" title=\"2. 帧率\"></a>2. 帧率</h1><p>帧率 (Frame rate)，一般是表示显示器上被称为帧的连续图形出现的速率，但是有时候也会用于表示渲染引擎输出帧的速率。单位一般用 fps(frames per second) 表示。</p>\n<h1 id=\"3-刷新率\"><a href=\"#3-刷新率\" class=\"headerlink\" title=\"3. 刷新率\"></a>3. 刷新率</h1><p>刷新率 (Refresh rate)，表示基于光栅的显示设备显示新图像的速率。单位一般用 HZ 表示。</p>\n<p>例如，一个 60HZ 的显示器，表示显示器可以每秒重新绘图 60 次，绘制一帧画面大约需要 $\\frac{1}{60}$ 秒 。</p>\n<p>一般来说，显示器的刷新率都是固定的，但现在有一些搭载 G-sync 和 freesync 的显示器可以动态调整自身的刷新率，以此适应显卡输出的速率。</p>\n<h1 id=\"4-逐行扫描\"><a href=\"#4-逐行扫描\" class=\"headerlink\" title=\"4. 逐行扫描\"></a>4. 逐行扫描</h1><p>逐行扫描是显示设备显示运动图像的方式。通俗地说，显示器输出一帧画面，是通过电子束按照从左到右，从上到下的顺序进行屏幕扫描，一行一行输出的。</p>\n<h1 id=\"5-画面撕裂\"><a href=\"#5-画面撕裂\" class=\"headerlink\" title=\"5. 画面撕裂\"></a>5. 画面撕裂</h1><p>画面撕裂 (Screen tearing)，指的是显示设备在一次画面绘制中展示了来自多个帧信息的错误显示现象。</p>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/0/03/Tearing_%28simulated%29.jpg\" alt=\"A typical video tearing artifact (simulated image)\" style=\"zoom:30%;\" />\n\n<h2 id=\"5-1-原因\"><a href=\"#5-1-原因\" class=\"headerlink\" title=\"5.1 原因\"></a>5.1 原因</h2><p>画面撕裂本质上是渲染引擎提供帧的速率和显示器刷新率不匹配造成的。</p>\n<p>例如，假设现在有一块缓冲区，显卡输出的帧率恒定为 100FPS，而显示器的刷新率恒定为 60HZ，那么会出现以下过程：</p>\n<ol>\n<li>在第 $\\frac{1}{100}$(0.01) 秒，显卡向缓冲区输出了一帧画面 A；</li>\n<li>在第 $\\frac{1}{60}$(0.016) 秒，显示器从缓冲区中读取数据并绘制画面 A，这个刷新过程会在第 $\\frac{2}{60}$(0.032) 秒完成；</li>\n<li>在第 $\\frac{2}{100}$(0.02) 秒，显卡向缓冲区输出了一帧画面 B，此时由于只有一块缓冲区，那么画面 A 的数据会被画面 B 的数据覆盖。本来，显示器绘制画面 A 会在第 $\\frac{2}{60}$(0.032) 秒完成，但是缓冲区中画面 A 的数据已经被画面 B 的数据覆盖，因此接下来显示器绘制用的是画面 B 的数据。此时，屏幕上会出现了画面 A 的一部分以及画面 B 的一部分，这个现象就是画面撕裂。</li>\n</ol>\n<h1 id=\"6-画面撕裂的解决方法\"><a href=\"#6-画面撕裂的解决方法\" class=\"headerlink\" title=\"6. 画面撕裂的解决方法\"></a>6. 画面撕裂的解决方法</h1><p>经过 [小节5.1] 的分析，我们知道，当渲染引擎提供帧的速率和显示器刷新率不匹配时，很容易导致显示器读取到 “脏数据”，从而导致画面撕裂的现象。</p>\n<p>显然，这个是数据同步问题。要彻底解决画面撕裂问题，就必须增加一些同步机制。</p>\n<h2 id=\"6-1-垂直同步\"><a href=\"#6-1-垂直同步\" class=\"headerlink\" title=\"6.1 垂直同步\"></a>6.1 垂直同步</h2><p>垂直同步 (Vertical synchronization)，是指在显示器的刷新期间，显卡被禁止修改显示内存的数据，只有当显示器完成当前的刷新周期之后，显卡才可以刷新显示内存的数据。</p>\n<p>以此保证显示器在刷新期间，当前显示帧的数据不会被修改，从而避免画面撕裂的问题。</p>\n<h3 id=\"6-1-1-垂直消隐间隔\"><a href=\"#6-1-1-垂直消隐间隔\" class=\"headerlink\" title=\"6.1.1 垂直消隐间隔\"></a>6.1.1 <strong>垂直消隐间隔</strong></h3><p>垂直消隐间隔 (Vertical Blank Interval)，是指扫描当前帧最后一行的结束时间和扫描下一帧第一行的开始时间两者的时间差。</p>\n<p>在开启垂直同步之后，显卡会在此期间刷新缓冲区的数据。</p>\n<h3 id=\"6-1-2-影响\"><a href=\"#6-1-2-影响\" class=\"headerlink\" title=\"6.1.2 影响\"></a>6.1.2 影响</h3><h4 id=\"6-1-2-1-渲染引擎的帧速率受限\"><a href=\"#6-1-2-1-渲染引擎的帧速率受限\" class=\"headerlink\" title=\"6.1.2.1 渲染引擎的帧速率受限\"></a>6.1.2.1 渲染引擎的帧速率受限</h4><p>在开启垂直同步之后，由于在显示器的刷新期间显卡不能输出帧数据，所以显卡输出帧的速率会受限于显示器的刷新率。</p>\n<p>例如，假设显示器的刷新率是 60HZ，在使用单缓冲区的情况下，显卡输出帧的速率最高只能达到 60FPS。</p>\n<h4 id=\"6-1-2-2-输入延迟\"><a href=\"#6-1-2-2-输入延迟\" class=\"headerlink\" title=\"6.1.2.2 输入延迟\"></a>6.1.2.2 输入延迟</h4><p>输入延迟 (Input lag)，通常是指一次输入与游戏或显示器对该输入作出反应之间的任何延迟。</p>\n<p>假设显示器的刷新率是 60HZ，在开启垂直同步之后，如果在显示器刷新过程中有输入，那么这次输入到显示就可能会有约 16ms 的延迟。</p>\n<h2 id=\"6-2-可变刷新率\"><a href=\"#6-2-可变刷新率\" class=\"headerlink\" title=\"6.2 可变刷新率\"></a>6.2 可变刷新率</h2><p>可变刷新率 (variable refresh rate)，此技术可以使得显示器的刷新率适应显卡输出帧的速率，从而避免画面撕裂，以及减少显示器刷新率不匹配显卡输出帧的速率造成的画面卡顿现象。</p>\n<h3 id=\"6-2-1-技术实现\"><a href=\"#6-2-1-技术实现\" class=\"headerlink\" title=\"6.2.1 技术实现\"></a>6.2.1 技术实现</h3><p><a href=\"https://en.wikipedia.org/wiki/Nvidia_G-Sync\">Nvidia G-Sync</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/FreeSync\">FreeSync</a></p>\n<h1 id=\"7-多重缓冲\"><a href=\"#7-多重缓冲\" class=\"headerlink\" title=\"7. 多重缓冲\"></a>7. 多重缓冲</h1><p>使用多重缓冲可以减少画面撕裂，提高工作效率。</p>\n<h2 id=\"7-1-双缓冲\"><a href=\"#7-1-双缓冲\" class=\"headerlink\" title=\"7.1 双缓冲\"></a>7.1 双缓冲</h2><p>双缓冲技术将缓冲区扩展到两块，渲染引擎所有绘制操作输出的数据结果将被存储于特定的内存区域，这块区域被称为 “后缓冲区”，而显示器获取帧数据的内存区域被称为 “前缓冲区”，前缓冲区和后缓冲区是两块不同的内存。</p>\n<p>当渲染引擎绘制完成后，后缓冲区的帧数据将被 “复制” 到前缓冲区，事实上这个操作是通过交换表示 “前缓冲区” 的引用和表示 “后缓冲区” 的引用来实现的，因此这个操作可视为瞬间完成。</p>\n<p>// TODO: 补充画图</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.cnblogs.com/wkfvawl/p/11559508.html\">计算机图形学——计算机图形系统及硬件基础</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Frame_rate\">Frame rate</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Refresh_rate\">Refresh rate</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Screen_tearing\">Screen tearing</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Vertical_blanking_interval\">Vertical blanking interval</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Input_lag\">Input lag</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics\">Multiple buffering</a></p>"},{"title":"分析 init 进程的启动流程","date":"2021-07-10T08:28:09.000Z","_content":"\n\n\n> 本文基于源代码：android-security-10.0.0_r56\n\n\n\n# 1. 前言\n\n<!-- TODO: 关于 init 进程更好的概述 -->\n\nAndroid 基于 Linux 内核，在内核启动过程中会创建出 init 进程。\n\ninit 进程是用户空间的第一个进程，进程的 pid = 1。\n\n<!-- more -->\n\n\n\n# 2. 启动流程\n\n<!-- TODO: 总结 -->\n\n\n\n## 2.1 init 进程的入口\n\n<!-- TODO: 为什么是入口？ -->\n\n<!-- TODO: init 就是一个普通的命令行程序, 位置在 /system/core/init？ -->\n\n在 Android 9，init 进程的入口位于 `system/core/init/init.cpp` 中的 main 函数。\n\n在 Android 10 之后，init 进程的入口改到了 `system/core/init/main.cpp` 中的 main 函数。\n\n```c++\nint main(int argc, char** argv) {\n    ...\n\n    if (!strcmp(basename(argv[0]), \"ueventd\")) {\n        return ueventd_main(argc, argv);\n    }\n\n    if (argc > 1) {\n        if (!strcmp(argv[1], \"subcontext\")) {\n            android::base::InitLogging(argv, &android::base::KernelLogger);\n            const BuiltinFunctionMap& function_map = GetBuiltinFunctionMap();\n\n            return SubcontextMain(argc, argv, &function_map);\n        }\n\n        if (!strcmp(argv[1], \"selinux_setup\")) {\n            return SetupSelinux(argv);\n        }\n\n        if (!strcmp(argv[1], \"second_stage\")) {\n            return SecondStageMain(argc, argv);\n        }\n    }\n\n    return FirstStageMain(argc, argv);\n}\n```\n\n首先来了解其中使用到的两个库函数：`basename` 函数和 `strcmp` 函数。\n\n- `basename` 的函数原型为 `char* basename(char* __path)`，可以根据给定的一个路径，返回文件名。例如：传入参数 \"/system/bin/ueventd\"，函数会返回 \"ueventd\"。\n- `strcmp` 的函数原型为 `int strcmp(const char* __lhs, const char* __rhs)`，是一个字符串比较函数，返回值为整数。当两个字符串相等时，函数返回 0。\n\n再来分析 main 函数：函数的主要工作是根据参数 `argc` 和 `argv`，选择对应的执行方式。如果参数未匹配成功，则默认调用 `FirstStageMain` 函数。\n\n\n\n## 2.2 启动的第一阶段\n\n<!-- TODO: mkdir, mknod, tmpfs -->\n\n<!-- TODO: 所挂载的文件系统的用处 -->\n\n<!-- TODO: KernelLogging(/dev/kmsg) -->\n\n<!-- TODO: InstallRebootSignalHandlers -->\n\n调用 `int FirstStageMain(int argc, char** argv)` 进入启动的第一阶段，函数所在文件的路径为 `system/core/init/first_stage_init.cpp`：\n\n```c++\nint FirstStageMain(int argc, char** argv) {\n    ...\n\n    CHECKCALL(clearenv());\n    CHECKCALL(setenv(\"PATH\", _PATH_DEFPATH, 1));\n    // Get the basic filesystem setup we need put together in the initramdisk\n    // on / and then we'll let the rc file figure out the rest.\n    CHECKCALL(mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"));\n    CHECKCALL(mkdir(\"/dev/pts\", 0755));\n    CHECKCALL(mkdir(\"/dev/socket\", 0755));\n    CHECKCALL(mkdir(\"/dev/dm-user\", 0755));\n    CHECKCALL(mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL));\n#define MAKE_STR(x) __STRING(x)\n    CHECKCALL(mount(\"proc\", \"/proc\", \"proc\", 0, \"hidepid=2,gid=\" MAKE_STR(AID_READPROC)));\n#undef MAKE_STR\n\n    // Don't expose the raw commandline to unprivileged processes.\n    // 设置文件权限 [2.2.1]\n    CHECKCALL(chmod(\"/proc/cmdline\", 0440));\n    std::string cmdline;\n    android::base::ReadFileToString(\"/proc/cmdline\", &cmdline);\n    // Don't expose the raw bootconfig to unprivileged processes.\n    chmod(\"/proc/bootconfig\", 0440);\n    std::string bootconfig;\n    android::base::ReadFileToString(\"/proc/bootconfig\", &bootconfig);\n    gid_t groups[] = {AID_READPROC};\n    CHECKCALL(setgroups(arraysize(groups), groups));\n    CHECKCALL(mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL));\n    CHECKCALL(mount(\"selinuxfs\", \"/sys/fs/selinux\", \"selinuxfs\", 0, NULL));\n\n    CHECKCALL(mknod(\"/dev/kmsg\", S_IFCHR | 0600, makedev(1, 11)));\n\n    if constexpr (WORLD_WRITABLE_KMSG) {\n        CHECKCALL(mknod(\"/dev/kmsg_debug\", S_IFCHR | 0622, makedev(1, 11)));\n    }\n\n    CHECKCALL(mknod(\"/dev/random\", S_IFCHR | 0666, makedev(1, 8)));\n    CHECKCALL(mknod(\"/dev/urandom\", S_IFCHR | 0666, makedev(1, 9)));\n\n    // This is needed for log wrapper, which gets called before ueventd runs.\n    CHECKCALL(mknod(\"/dev/ptmx\", S_IFCHR | 0666, makedev(5, 2)));\n    CHECKCALL(mknod(\"/dev/null\", S_IFCHR | 0666, makedev(1, 3)));\n\n    // These below mounts are done in first stage init so that first stage mount can mount\n    // subdirectories of /mnt/{vendor,product}/.  Other mounts, not required by first stage mount,\n    // should be done in rc files.\n    // Mount staging areas for devices managed by vold\n    // See storage config details at http://source.android.com/devices/storage/\n    CHECKCALL(mount(\"tmpfs\", \"/mnt\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=1000\"));\n    // /mnt/vendor is used to mount vendor-specific partitions that can not be\n    // part of the vendor partition, e.g. because they are mounted read-write.\n    CHECKCALL(mkdir(\"/mnt/vendor\", 0755));\n    // /mnt/product is used to mount product-specific partitions that can not be\n    // part of the product partition, e.g. because they are mounted read-write.\n    CHECKCALL(mkdir(\"/mnt/product\", 0755));\n\n    // /debug_ramdisk is used to preserve additional files from the debug ramdisk\n    CHECKCALL(mount(\"tmpfs\", \"/debug_ramdisk\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=0\"));\n\n    // /second_stage_resources is used to preserve files from first to second\n    // stage init\n    CHECKCALL(mount(\"tmpfs\", kSecondStageRes, \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=0\"))\n#undef CHECKCALL\n\n    SetStdioToDevNull(argv);\n    // Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually\n    // talk to the outside world...\n    InitKernelLogging(argv);\n\n    if (!errors.empty()) {\n        for (const auto& [error_string, error_errno] : errors) {\n            LOG(ERROR) << error_string << \" \" << strerror(error_errno);\n        }\n        LOG(FATAL) << \"Init encountered errors starting first stage, aborting\";\n    }\n\n    LOG(INFO) << \"init first stage started!\";\n\n    ...\n\n    // 执行 /system/bin/init\n    // 注意到传入的参数是 selinux_setup, 因此接下来会调用 SetupSelinux 函数进行 SELinux 的初始化 [2.3]\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"selinux_setup\", nullptr};\n    auto fd = open(\"/dev/kmsg\", O_WRONLY | O_CLOEXEC);\n    dup2(fd, STDOUT_FILENO);\n    dup2(fd, STDERR_FILENO);\n    close(fd);\n    execv(path, const_cast<char**>(args));\n\n    // execv() only returns if an error happened, in which case we\n    // panic and never fall through this conditional.\n    PLOG(FATAL) << \"execv(\\\"\" << path << \"\\\") failed\";\n\n    return 1;\n}\n```\n\n此函数主要工作是挂载一些文件系统，然后执行 `/system/bin/init`，重新进入 main 函数，通过传入参数 `\"selinux_setup\"`，进而调用 SetupSelinux 函数，进行 SELinux 的初始化。\n\n\n\n### 2.2.1 设置文件或目录的权限\n\n在 Linux 系统上，`chmod` 命令用于控制用户对文件或者目录的权限，但只有文件所有者和超级用户可以修改文件或目录的权限。\n\n权限分为三类：读，写，执行。\n\n\n\n#### 2.2.1.1 符号表示法\n\n符号表示法用 10 位字符表示权限，其形式为：\n\n```\n-rwxrwxrwx\n```\n\n其中第一个字符表示文件类型，常见的符号有：\n\n- `-`，表示普通文件。\n- `d`，表示目录。\n- `c`，表示字符特殊文件。\n\n剩余的 9 个字符，每 3 个字符分为一组，分别表示文件所有者，用户组，其他用户的权限。\n\n3 个字符组成的字符串，第 1 位控制读权限，第 2 位控制写权限，第 3 位控制执行权限：\n\n- 如果拥有读权限，第 1 位字符为 `r`，否则为 `-`。\n- 如果拥有写权限，第 2 位字符为 `w`，否则为 `-`。\n- 如果拥有执行权限，第 3 位字符为 `x`，否则为 `-`。\n\n示例：`-rwxrw-r--` 表示一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。\n\n\n\n#### 2.2.1.2 数字表示法\n\n可以用 4 位八进制数字表示权限，第 1 位同样表示文件类型，剩余的 3 位数字，分别表示文件所有者，用户组，其他用户的权限。\n\n读，写，执行，这 3 类权限可以使用 3 位二进制数字表示，不同类型的权限单独对应二进制数字中一个位：\n\n|          数值          | 权限 |\n| :--------------------: | :--: |\n| 二进制：100，八进制：4 |  r   |\n| 二进制：010，八进制：2 |  w   |\n| 二进制：001，八进制：1 |  x   |\n| 二进制：000，八进制：0 |  -   |\n\n在各类权限对应的数值之和，可以代表一组特定的权限。由于和的数值范围为 0~7，因此可以通过一个八进制数字表示。示例：\n\n|          数值          | 权限 |\n| :--------------------: | :--: |\n| 二进制：111，八进制：7 | rwx  |\n| 二进制：110，八进制：6 | rw-  |\n| 二进制：101，八进制：5 | r-x  |\n| 二进制：000，八进制：0 | ---  |\n\n因此，用符号表示法表示的权限，同样可以使用数字表示法来表示，示例：\n\n| 符号表示法 | 数字表示法 |                             说明                             |\n| :--------: | :--------: | :----------------------------------------------------------: |\n| -rwxrwxrwx |    0777    | 一个普通文件，文件所有者，用户组，其他用户都有读，写，执行的权限 |\n| -rwxrw-r-- |    0764    | 一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。 |\n\n\n\n#### 2.2.1.3 分析源码中的权限设置\n\n```c++\n// Don't expose the raw commandline to unprivileged processes.\nCHECKCALL(chmod(\"/proc/cmdline\", 0440));\n\n// Don't expose the raw bootconfig to unprivileged processes.\nchmod(\"/proc/bootconfig\", 0440);\n```\n\n在源码中有两处使用到 `chmod` 命令，分别对文件 `/proc/cmdline`，`/proc/bootconfig` 设置了权限 `0440`，表明 root 用户 (文件所有者) 及其用户组也只有文件的读权限。\n\n\n\n## 2.3 初始化 SELinux\n\n<!-- TODO: 分析 SELinux -->\n\n调用 `int SetupSelinux(char** argv)` 进行 SELinux 的初始化，该函数所在文件的路径为 `system/core/init/selinux.cpp`：\n\n```c++\n// This function initializes SELinux then execs init to run in the init SELinux context.\nint SetupSelinux(char** argv) {\n    ...\n\n    // Set up SELinux, loading the SELinux policy.\n    // 初始化 SELinux\n    SelinuxSetupKernelLogging();\n    SelinuxInitialize();\n\n    ...\n\n    // 执行 /system/bin/init\n    // 注意到传入的参数是 second_stage, 因此接下来会调用 SecondStageMain 函数进入启动的第二阶段 [2.4]\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"second_stage\", nullptr};\n    execv(path, const_cast<char**>(args));\n\n    ...\n\n    return 1;\n}\n```\n\n函数首先初始化了 SELinux，然后执行 `/system/bin/init`，重新进入 main 函数，通过传入参数 `\"second_stage\"`，进而调用 SecondStageMain 函数，进入启动的第二阶段。\n\n\n\n## 2.4 启动的第二阶段\n\n<!-- TODO: property_load_boot_defaults -->\n\n<!-- TODO: 在编译的过程中, android 的各种系统参数会被汇总到 build.prop 文件中？ -->\n\n<!-- TODO: SELinux 相关代码的分析 -->\n\n<!-- TODO: keyctl_get_keyring_ID(KEY_SPEC_SESSION_KEYRING, 1) -->\n\n<!-- TODO: InitializeSubcontext() -->\n\n<!-- TODO: ActionManager 和 ServiceList 的作用 -->\n\n调用 `int SecondStageMain(int argc, char** argv)` 进入启动的第二阶段，函数所在文件的路径为 `system/core/init/init.cpp`：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n    ...\n\n    // Set init and its forked children's oom_adj.\n    // 设置 init 进程以及由其 fork 得到的子进程 oom_score_adj 的值\n    // 数值越小, 进程优先级越高\n    if (auto result = WriteFile(\"/proc/1/oom_score_adj\", \"-1000\"); !result) {\n        LOG(ERROR) << \"Unable to write -1000 to /proc/1/oom_score_adj: \" << result.error();\n    }\n\n    ...\n\n    // 初始化属性服务 [2.4.2.1]\n    property_init();\n\n    ...\n\n    // 初始化 epoll [2.4.1.1]\n    Epoll epoll;\n    if (auto result = epoll.Open(); !result) {\n        PLOG(FATAL) << result.error();\n    }\n\n    // 使用 epoll 对 init 子进程的信号进行监听 [2.4.3.1.3]\n    // 初始化子进程退出的信号处理函数\n    InstallSignalFdHandler(&epoll);\n\n    ...\n\n    // 开启属性服务 [2.4.2.2]\n    StartPropertyService(&epoll);\n\n    ...\n\n    ActionManager& am = ActionManager::GetInstance();\n    ServiceList& sm = ServiceList::GetInstance();\n\n    // 加载启动脚本 [2.4.4]\n    LoadBootScripts(am, sm);\n\n    ...\n\n    // 添加 Action [2.4.5.1]\n    am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\");\n    am.QueueEventTrigger(\"early-init\");\n    am.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\");\n    ...\n    am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\");\n\n    // 进入无限循环状态 [2.4.5]\n    while (true) {\n        auto epoll_timeout = std::optional<std::chrono::milliseconds>{};\n\n        if (do_shutdown && !shutting_down) {\n            do_shutdown = false;\n            if (HandlePowerctlMessage(shutdown_command)) {\n                shutting_down = true;\n            }\n        }\n\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            am.ExecuteOneCommand();\n        }\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            if (!shutting_down) {\n                auto next_process_action_time = HandleProcessActions();\n\n                if (next_process_action_time) {\n                    epoll_timeout = std::chrono::ceil<std::chrono::milliseconds>(\n                            *next_process_action_time - boot_clock::now());\n                    if (*epoll_timeout < 0ms) epoll_timeout = 0ms;\n                }\n            }\n\n            if (am.HasMoreCommands()) epoll_timeout = 0ms;\n        }\n\n        if (auto result = epoll.Wait(epoll_timeout); !result) {\n            LOG(ERROR) << result.error();\n        }\n    }\n\n    return 0;\n}\n```\n\n第二阶段的工作可以大致分为 5 个部分：\n\n- epoll\n\n- 属性服务\n\n- 信号\n\n- 加载启动脚本\n\n- 进入无限循环状态\n\n接下来将分别对这 5 个部分的工作进行分析。\n\n\n\n### 2.4.1 epoll\n\nepoll 是 Linux 提供的 I/O 事件通知机制。epoll 可以监听大量的文件描述符，检查其中某一个文件描述符是否进入就绪状态。\n\n\n\n#### 2.4.1.1 初始化\n\n在 init 进程中，epoll 通过以下代码初始化：\n\n```c++\nEpoll epoll;\nif (auto result = epoll.Open(); !result) {\n    PLOG(FATAL) << result.error();\n}\n```\n\n可以知道，epoll 实例是通过调用 Open 函数创建的，函数所在文件的路径为 `system/core/init/epoll.cpp`，来分析这个函数：\n\n```c++\nResult<Success> Epoll::Open() {\n    if (epoll_fd_ >= 0) return Success();\n\n    // 关键点\n    epoll_fd_.reset(epoll_create1(EPOLL_CLOEXEC));\n\n    if (epoll_fd_ == -1) {\n        return ErrnoError() << \"epoll_create1 failed\";\n    }\n    return Success();\n}\n```\n\n此函数的关键点在于调用 `epoll_create1`。`epoll_create1` 是一个系统调用，其新建了一个 epoll 实例并返回该实例文件描述符。\n\n\n\n#### 2.4.1.2 使用 epoll 监听文件描述符\n\n要使用 epoll 监听文件描述符，需要调用 RegisterHandler 函数，将文件描述符注册到 epoll。\n\n函数所在文件的路径为 `system/core/init/epoll.cpp`，此函数的关键点在于系统调用 epoll_ctl：\n\n```c++\nResult<Success> Epoll::RegisterHandler(int fd, std::function<void()> handler, uint32_t events) {\n    ...\n\n    // 关键点\n    if (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &ev) == -1) {\n\n        ...\n\n        return result;\n    }\n    return Success();\n}\n```\n\n首先来看下 epoll_ctl 这个系统调用。\n\n\n\n##### 2.4.1.2.1 系统调用 epoll_ctl\n\n**epoll_ctl** 是一个系统调用，函数原型为 `int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)`，用于对指定的文件描述符 fd 进行添加、修改或者删除操作。\n\n\n\n###### 2.4.1.2.1.1 参数\n\n首先来理解 epoll_ctl 的参数：\n\n- **epfd** 是 epoll 实例的文件描述符。\n\n- **op** 表示要执行的操作，有三种取值：\n\n  - **EPOLL_CTL_ADD**\n\n    添加指定的文件描述符到 epoll 的监控列表。\n\n  - **EPOLL_CTL_MOD**\n\n    修改 epoll 的监控列表中指定的文件描述符。\n\n  - **EPOLL_CTL_DEL**\n\n    从 epoll 的监控列表中删除指定的文件描述符。\n\n- **fd** 表示指定的文件描述符。\n\n- **event** 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，其定义如下：\n\n  ```c++\n  struct epoll_event {\n     uint32_t     events;      /* Epoll events */\n     epoll_data_t data;        /* User data variable */\n  };\n  ```\n\n  结构体成员 `events` 用于表示要监听的事件，可以由零个或者多个事件类型组成，下面列出部分常见的事件类型：\n\n  - \u0015\u0015**EPOLLIN**\n    表示关联的文件描述符可用于读操作。\n\n  - **EPOLLOUT**\n    表示关联的文件描述符可用于写操作。\n\n  - **EPOLLPRI**\n    表示关联的文件描述符出现异常情况。\n\n  - **EPOLLERR**\n    表示关联的文件描述符出现错误。\n\n  - **EPOLLHUP**\n    表示关联的文件描述符被挂断。\n\n  - **EPOLLONESHOT**\n    表示只监听文件描述符的一次事件。当事件触发之后，epoll 就会禁用此文件描述符。\n    如果想要继续监听该文件描述符的事件，需要再次调用 epoll_ctl，并执行 EPOLL_CTL_MOD 操作。\n\n  结构体成员 `data` 的作用是将其数据交给内核保存，当文件描述符就绪后，内核会返回保存的数据 [2.4.1.3]。`epoll_data_t` 是一个共用体，其定义如下：\n\n  ```c++\n  typedef union epoll_data {\n     void        *ptr;\n     int          fd;\n     uint32_t     u32;\n     uint64_t     u64;\n  } epoll_data_t;\n  ```\n\n\n\n###### 2.4.1.2.1.2 返回值\n\n最后来了解 epoll_ctl 的返回值：\n\n- 当操作成功时，返回值为 0。\n\n- 当发生错误时，返回值为 -1。\n\n\n\n##### 2.4.1.2.2 分析 RegisterHandler 函数\n\n在了解过系统调用 epoll_ctl 以后，现在开始分析 RegisterHandler 函数。首先来看函数在头文件中的声明，头文件的路径为 `system/core/init/epoll.h`：\n\n```c++\nclass Epoll {\n  public:\n    Result<Success> RegisterHandler(int fd, std::function<void()> handler,\n                                    uint32_t events = EPOLLIN);\n};\n```\n\n由函数原型可知，函数的第三个参数 `events` 有默认值 `EPOLLIN`，表示监听文件描述符的读操作是否可用。\n\n接下来分析 RegisterHandler 函数：\n\n```c++\nResult<Success> Epoll::RegisterHandler(int fd, std::function<void()> handler, uint32_t events) {\n    ...\n\n    // handler 是事件触发时的回调函数\n    auto [it, inserted] = epoll_handlers_.emplace(fd, std::move(handler));\n\n    ...\n\n    epoll_event ev;\n\n    // 设置要监听的事件类型\n    // 由于 events 有默认值 EPOLLIN, 因此默认监听的事件类型是读操作是否可用\n    ev.events = events;\n  \n    // 设置回调函数, 回调函数会在事件触发后被调用 [2.4.1.3.2]\n    ev.data.ptr = reinterpret_cast<void*>(&it->second);\n\n    // 发起 epoll_ctl 系统调用\n    // 注意到第二个参数传入的是 EPOLL_CTL_ADD, 因此对指定文件描述符执行的是添加操作\n    if (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &ev) == -1) {\n        Result<Success> result = ErrnoError() << \"epoll_ctl failed to add fd\";\n        epoll_handlers_.erase(fd);\n        return result;\n    }\n    return Success();\n}\n```\n\n经过分析，可以知道函数的主要工作是：设置文件描述符需要监听的事件类型 `events` 以及事件触发时的回调函数 `handler`，最后发起 `epoll_ctl` 系统调用，将文件描述符添加到 epoll 监控列表。\n\n\n\n#### 2.4.1.3 等待事件触发\n\n经过 epoll 的初始化以及将文件描述符注册到 epoll 之后，接下来就需要等待事件触发，然后处理事件。\n\n在 init 进程启动的第二阶段，最后一个步骤就是进入死循环，不断地等待事件触发。接下来看下这段逻辑：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n    ...\n\n    while (true) {\n        ...\n\n        // 关键点\n        if (auto result = epoll.Wait(epoll_timeout); !result) {\n            LOG(ERROR) << result.error();\n        }\n    }\n\n    return 0;\n}\n```\n\n这段逻辑的关键点在于 Wait 函数，接下来分析这个函数。\n\n\n\n##### 2.4.1.3.1 系统调用 epoll_wait\n\n在分析 Wait 函数之前，首先要了解系统调用 epoll_wait，这个系统调用是 Wait 函数的关键点。\n\n**epoll_wait** 是一个系统调用，函数原型为 `int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)`，用于等待 epoll 上的事件。\n\n调用 epoll_wait 便会进入阻塞状态，直至满足以下任一条件，调用才会返回：\n\n- 监听的文件描述符传递一个事件；\n- 调用被信号处理程序中断；\n- 等待超出超时时长。\n\n\n\n###### 2.4.1.3.1.1 参数\n\n首先来理解 epoll_wait 的参数：\n\n- **epfd** 是 epoll 实例的文件描述符。\n\n- **events** 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，在 [2.4.1.2.1] 一节已经详细介绍过。\n\n  当事件触发后，调用就会返回，此时可以从 events 中得到已触发事件的集合。集合中每一个事件结构体 epoll_event 的 data 字段和调用 epoll_ctl 为相应的文件描述符设置的 data 字段是相同的。意味着，当事件触发后，之前调用 epoll_ctl 给指定文件描述符设置的 event.data 会通过这个参数返回给 epoll_wait 的调用者。\n\n- **maxevents** 表示在一次调用中返回事件的最大数量。因此，从参数 events 中得到的事件数量不会大于 maxevents。\n\n- **timeout** 是此次调用的超时时长。当 timeout = -1 时，调用将会一直阻塞，直到有事件发生；当 timeout = 0 时，调用会立即返回，即使当前没有事件发生。\n\n\n\n###### 2.4.1.3.1.2 返回值\n\n最后来了解 epoll_wait 的返回值：\n\n- 当调用成功时，返回值为已就绪的文件描述符的数量，此时可以对这些文件描述符进行 I/O 操作。\n\n  需要注意的是，如果该调用是因为超出等待时长而返回的，则返回值为 0，表明没有已就绪的文件描述符。\n\n- 当调用失败时，返回值为 -1，并返回错误信息。\n\n\n\n##### 2.4.1.3.2 分析 Wait 函数\n\n在了解过系统调用 epoll_wait 以后，就可以开始分析 Wait 函数，函数所在文件的路径为 `system/core/init/epoll.cpp`：\n\n```c++\nResult<Success> Epoll::Wait(std::optional<std::chrono::milliseconds> timeout) {\n    // 超时时长默认值为 -1\n    int timeout_ms = -1;\n\n    if (timeout && timeout->count() < INT_MAX) {\n        // 当参数 timeout 满足不等于 0 和数值没有溢出时, 更新超时时长\n        timeout_ms = timeout->count();\n    }\n\n    epoll_event ev;\n\n    // 发起 epoll_wait 系统调用\n    // 注意到第三个参数传入的是 1, 表明每次调用最多返回 1 个事件\n    auto nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd_, &ev, 1, timeout_ms));\n\n    if (nr == -1) {\n        // 调用返回 -1, 表明此次调用失败\n        return ErrnoError() << \"epoll_wait failed\";\n    } else if (nr == 1) {\n        // 调用返回 1, 表明此次调用成功, 有 1 个事件触发\n        // ev.data.ptr 是之前调用 epoll_ctl 给指定文件描述符设置的回调函数, 因此事件最后交给回调函数进行处理\n        std::invoke(*reinterpret_cast<std::function<void()>*>(ev.data.ptr));\n    }\n    return Success();\n}\n```\n\n此函数设置了超时时长，然后发起 `epoll_wait` 系统调用，等待事件触发。当 `epoll_wait` 成功返回时，会从返回的数据里面取出之前通过 epoll_ctl 设置的回调函数，将事件交由回调函数处理。\n\n\n\n### 2.4.2 属性服务\n\n属性服务是 Android 提供的一个用于存取系统属性的服务，属性以 key-value 的形式存储在一块共享内存，所有进程都可以通过这个服务获取和设置属性。\n\n使用 adb，输入命令 `getprop`，可以查看一台设备上的属性，下面列举其中的一些输出：\n\n```\n[ro.product.brand]: [Redmi]\n[ro.product.manufacturer]: [Xiaomi]\n[ro.product.marketname]: [Redmi K30S Ultra]\n[ro.product.model]: [M2007J3SC]\n[ro.product.name]: [apollo]\n\n[ro.product.cpu.abi]: [arm64-v8a]\n[ro.product.cpu.abilist]: [arm64-v8a,armeabi-v7a,armeabi]\n[ro.product.cpu.abilist32]: [armeabi-v7a,armeabi]\n[ro.product.cpu.abilist64]: [arm64-v8a]\n\n[dalvik.vm.heapsize]: [512m]\n[dalvik.vm.heapstartsize]: [8m]\n```\n\n通过列举出的数据，可以看出属性里面包含了很多重要的信息：机型信息，CPU 架构，虚拟机分配的内存大小等等。\n\n在 Java 代码中，可以调用 `SystemProperties.get(String, String)` 方法获取系统属性。例如，在 ActivityManager 中就有这样的代码：\n\n```java\nstatic public int staticGetLargeMemoryClass() {\n    // 通过获取系统属性 dalvik.vm.heapsize, 得出应用可用堆内存的最大值\n    String vmHeapSize = SystemProperties.get(\"dalvik.vm.heapsize\", \"16m\");\n\n    return Integer.parseInt(vmHeapSize.substring(0, vmHeapSize.length() - 1));\n}\n```\n\n类似地，调用 `SystemProperties.set(String, String)` 方法可以设置系统属性。例如，在 ActivityManagerService 中就有这样的代码：\n\n```java\nfinal void finishBooting() {\n    ...\n\n    synchronized (this) {\n\n        ...\n\n        // Tell anyone interested that we are done booting!\n        // 通过设置属性 sys.boot_completed = 1, 标记系统已经启动完成\n        SystemProperties.set(\"sys.boot_completed\", \"1\");\n\n        ...\n    }\n\n    ...\n}\n```\n\n\n\n#### 2.4.2.1 初始化\n\n<!-- TODO: 如何创建内存区域？ -->\n\n<!-- TODO: 进程是怎样获取共享内存中的属性？ -->\n\n<!-- TODO: 进程为什么不能直接设置共享内存中的属性？ -->\n\n<!-- TODO: CreateSerializedPropertyInfo() -->\n\n<!-- TODO: property_info_area.LoadDefaultPath() -->\n\n属性服务初始化时，调用的是 property_init 函数，文件路径为 `system/core/init/property_service.cpp`。\n\n```c++\nvoid property_init() {\n    mkdir(\"/dev/__properties__\", S_IRWXU | S_IXGRP | S_IXOTH);\n    CreateSerializedPropertyInfo();\n\n    // 创建内存区域\n    if (__system_property_area_init()) {\n        LOG(FATAL) << \"Failed to initialize property area\";\n    }\n\n    if (!property_info_area.LoadDefaultPath()) {\n        LOG(FATAL) << \"Failed to load serialized property info file\";\n    }\n}\n```\n\n函数最主要的工作是通过调用 `__system_property_area_init` 函数，创建用于存储属性的内存区域。\n\n\n\n#### 2.4.2.2 启动\n\n<!-- TODO: socket 的创建过程 -->\n\n<!-- TODO: listen(property_set_fd, 8) -->\n\n<!-- TODO: 一个进程是怎样向 init 进程发起属性设置的请求？ -->\n\n属性服务启动时，调用的是 StartPropertyService 函数，文件路径为 `system/core/init/property_service.cpp`：\n\n```c++\nvoid StartPropertyService(Epoll* epoll) {\n\n    ...\n\n    // 创建 socket 并返回其文件描述符, 其中 PROP_SERVICE_NAME = \"property_service\"\n    property_set_fd = CreateSocket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,\n                                   false, 0666, 0, 0, nullptr);\n    if (property_set_fd == -1) {\n        PLOG(FATAL) << \"start_property_service socket creation failed\";\n    }\n\n    listen(property_set_fd, 8);\n\n    // 将 socket 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]\n    // handle_property_set_fd 是可读事件触发时的回调函数 [2.4.2.3]\n    if (auto result = epoll->RegisterHandler(property_set_fd, handle_property_set_fd); !result) {\n        PLOG(FATAL) << result.error();\n    }\n}\n```\n\n此函数首先创建名称为 property_service 的 socket，然后将 socket 文件描述符注册到 epoll，监听其可读事件。\n\n当可读事件触发时，会进入回调函数 `handle_property_set_fd`，接着来分析这个回调函数。\n\n\n\n#### 2.4.2.3 回调函数 handle_property_set_fd\n\n<!-- TODO: ucred cr; socklen_t cr_size = sizeof(cr); -->\n\n<!-- TODO: 设置属性的具体实现 -->\n\n<!-- TODO: 除了通过向 init 进程发出请求设置属性以外, 在其他地方是否也有属性的设置？ -->\n\n<!-- TODO: 属性的同步问题 -->\n\n函数所在文件的路径为 `system/core/init/property_service.cpp`：\n\n```c++\nstatic void handle_property_set_fd() {\n    // 2000ms\n    static constexpr uint32_t kDefaultSocketTimeout = 2000; /* ms */\n\n    ...\n\n    SocketConnection socket(s, cr);\n\n    // 设置 2000ms 的超时时长\n    uint32_t timeout_ms = kDefaultSocketTimeout;\n\n    uint32_t cmd = 0;\n    if (!socket.RecvUint32(&cmd, &timeout_ms)) {\n        PLOG(ERROR) << \"sys_prop: error while reading command from the socket\";\n        socket.SendUint32(PROP_ERROR_READ_CMD);\n        return;\n    }\n\n    switch (cmd) {\n    // 处理 PROP_MSG_SETPROP 命令\n    case PROP_MSG_SETPROP: {\n        // PROP_NAME_MAX = 32\n        char prop_name[PROP_NAME_MAX];\n        char prop_value[PROP_VALUE_MAX];\n\n        // 接收属性名和属性值, 分别存储于字符数组 prop_name 和 prop_value 中\n        if (!socket.RecvChars(prop_name, PROP_NAME_MAX, &timeout_ms) ||\n            !socket.RecvChars(prop_value, PROP_VALUE_MAX, &timeout_ms)) {\n          PLOG(ERROR) << \"sys_prop(PROP_MSG_SETPROP): error while reading name/value from the socket\";\n          return;\n        }\n\n        // 将字符数组中最后的一个元素设置为 0\n        prop_name[PROP_NAME_MAX-1] = 0;\n        prop_value[PROP_VALUE_MAX-1] = 0;\n\n        const auto& cr = socket.cred();\n        std::string error;\n\n        // 设置属性\n        uint32_t result =\n            HandlePropertySet(prop_name, prop_value, socket.source_context(), cr, &error);\n\n        if (result != PROP_SUCCESS) {\n            LOG(ERROR) << \"Unable to set property '\" << prop_name << \"' to '\" << prop_value\n                       << \"' from uid:\" << cr.uid << \" gid:\" << cr.gid << \" pid:\" << cr.pid << \": \"\n                       << error;\n        }\n\n        break;\n      }\n\n    // 处理 PROP_MSG_SETPROP2 命令\n    case PROP_MSG_SETPROP2: {\n        std::string name;\n        std::string value;\n\n        // 接收字符串类型的属性名和属性值\n        if (!socket.RecvString(&name, &timeout_ms) ||\n            !socket.RecvString(&value, &timeout_ms)) {\n          PLOG(ERROR) << \"sys_prop(PROP_MSG_SETPROP2): error while reading name/value from the socket\";\n          socket.SendUint32(PROP_ERROR_READ_DATA);\n          return;\n        }\n\n        const auto& cr = socket.cred();\n        std::string error;\n\n        // 设置属性\n        uint32_t result = HandlePropertySet(name, value, socket.source_context(), cr, &error);\n\n        if (result != PROP_SUCCESS) {\n            LOG(ERROR) << \"Unable to set property '\" << name << \"' to '\" << value\n                       << \"' from uid:\" << cr.uid << \" gid:\" << cr.gid << \" pid:\" << cr.pid << \": \"\n                       << error;\n        }\n        socket.SendUint32(result);\n        break;\n      }\n\n    default:\n        LOG(ERROR) << \"sys_prop: invalid command \" << cmd;\n        socket.SendUint32(PROP_ERROR_INVALID_CMD);\n        break;\n    }\n}\n```\n\n函数初始化了 socket 接收事件的超时时长，然后对接收到的 `cmd` 做相应的操作：\n\n- 对于 `PROP_MSG_SETPROP` 命令，使用两个长度为 `PROP_NAME_MAX` 的字符数组保存接收到的属性名和属性值。值得注意的是，最后会将字符数组中最后的一个元素设为 0，因此接收的属性名和属性值的最大长度不应超过 `PROP_NAME_MAX - 1` 。\n- 对于 `PROP_MSG_SETPROP2` 命令，使用两个 `std::string` 保存接收到的属性名和属性值。\n\n最后，不论是 `PROP_MSG_SETPROP` 命令还是 `PROP_MSG_SETPROP2` 命令，都会调用 `HandlePropertySet` 函数来设置属性。\n\n\n\n### 2.4.3 信号\n\n**信号 (Signals)** 属于 IPC 的一种方式，用于向一个进程或者进程中的特定线程发送事件通知。\n\n信号是一个**异步的**通信机制，一个进程可以不需要等待信号的到达。在信号未产生时，进程会正常执行；当信号产生后，系统可以中断目标进程的任何非原子操作，此时进程的正常执行流程会被中断，进而对信号进行处理。\n\n\n\n#### 2.4.3.1 处理信号\n\n在 Linux，一个子进程终结后，内核依然会为其维护关于此进程的最小信息集 (PID、终结状态、资源使用信息)，以便父进程获取有关子进程的信息。如果父进程没有为该子进程发起 wait、waitpid 或者 waitid 系统调用，那么子进程的信息就会一直占据着内核进程表的空间。在这种情况下，这个子进程就成为了一个**僵尸进程 (Zombie process)**。\n\n一般情况下，对于一个僵尸进程，如果其父进程终结了，那么 init 进程就会自动成为僵尸进程的父进程。此时，为了避免僵尸进程一直占据着系统资源，init 进程需要为僵尸进程释放占据的空间。\n\n而且，在加载启动脚本 [2.4.4] 这一步骤中，init 进程会 fork 得到一些子进程，例如：servicemanager 进程、zygote 进程。这些子进程对 Android 而言非常重要，在这些进程退出后，init 进程需要有相应的动作将其重启。\n\n于是，为了管理这些子进程，init 进程需要接收子进程终结的信号并进行相应的处理。\n\n在 Android，信号处理基于 Linux 的信号机制。\n\n\n\n##### 2.4.3.1.1 信号的处理方式\n\n<!-- 更正: 注册信号处理函数 -->\n\n信号的处理方式有以下三种：\n\n- **忽略该信号**\n- **按信号的默认行为处理该信号**\n- **使用自定义的信号处理函数来处理该信号**\n\ninit 进程使用的是第三种处理方式：使用自定义的信号处理函数来处理该信号。进程注册了一个信号处理函数，当目标信号产生时，信号会被捕获，并调用注册的函数进行处理。\n\n接下来分析这个过程。\n\n\n\n##### 2.4.3.1.2 系统调用 sigaction\n\n在分析 init 进程注册函数的过程之前，首先来了解系统调用 sigaction，这个系统调用是此过程的一个关键点。\n\n**sigaction** 是一个系统调用，函数原型为 `int sigaction(int signum, const struct sigaction *restrict act, struct sigaction *restrict oldact)`，用于更改进程在收到指定信号后的行为。\n\n\n\n###### 2.4.3.1.2.1 参数\n\n首先来理解 sigaction 的参数：\n\n- **signum** 是指定信号的编号。\n\n  同一个信号在不同的架构上可能有不同的编号。在 Android，ARM 架构的信号编号定义在 `bionic/libc/kernel/uapi/asm-arm/asm/signal.h` 文件上。\n\n- **act** 是一个 sigaction 类型的指针，而 sigaction 是一个结构体，其定义如下：\n\n  ```c++\n  struct sigaction {\n     void     (*sa_handler)(int);\n     void     (*sa_sigaction)(int, siginfo_t *, void *);\n     sigset_t   sa_mask;\n     int        sa_flags;\n     void     (*sa_restorer)(void);\n  };\n  ```\n\n  关注结构体中两个较为重要的成员 `sa_handler` 和 `sa_flags`。\n\n  成员 `sa_handler` 用于指定信号产生时的行为，可以是以下这些值之一：\n\n  - **SIG_DFL**\n\n    表示执行该信号的默认行为。\n\n  - **SIG_IGN**\n\n    表示忽略该信号。\n\n  - **一个指向信号处理函数的指针**\n\n    信号编号 signum 将作为函数的唯一参数传入。当目标信号产生时，会自动调用此函数进行处理。\n\n  成员 `sa_flags` 是标志位，可以由零个或者多个标志组成。下面列出其中的一些标志：\n\n  - **SA_NOCLDSTOP**\n\n    只有当 signum = SIGCHLD 时才有意义。表示进程不接收子进程停止或者恢复时产生的信号，只接收子进程终结的信号。\n\n  - **SA_RESETHAND**\n\n    当信号已经由信号处理函数处理过后，将信号恢复为使用默认行为进行处理。\n\n  - **SA_SIGINFO**\n\n    不再通过结构体成员 sa_handler 设置信号处理函数，而是使用成员 sa_sigaction。此时，函数的入参有三个。\n\n- **oldact** 同样是一个 sigaction 类型的指针，用于保存上一个 sigaction 调用所传入的参数 act，可以为空。\n\n\n\n###### 2.4.3.1.2.2 返回值\n\n最后来了解 sigaction 的返回值：\n\n- 当操作成功时，返回值为 0。\n\n- 当发生错误时，返回值为 -1。\n\n\n\n##### 2.4.3.1.3 init 进程注册信号处理函数\n\n在了解过系统调用 sigaction 以后，现在可以开始分析 init 进程注册信号处理函数的过程。\n\n\n\n###### 2.4.3.1.3.1 发起系统调用 sigaction\n\ninit 进程通过调用 InstallSignalFdHandler 函数实现注册信号处理函数，函数所在文件的路径为 `system/core/init/init.cpp`，首先来关注函数前半部分所做的工作：\n\n```c++\nstatic void InstallSignalFdHandler(Epoll* epoll) {\n    // 构建结构体 sigaction\n    // 成员 sa_handler 用于指定信号产生时的行为, 令 sa_handler = SIG_DFL 表明当信号产生时按默认行为对信号进行处理\n    // 成员 sa_flags 是标志位, 令 sa_flags = SA_NOCLDSTOP 表明 init 进程不接收子进程被中断或者被中断后恢复时产生的信号, 只接收子进程终结的信号\n    const struct sigaction act { .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDSTOP };\n\n    // sigaction 是一个系统调用, 用于更改进程在收到指定的信号时所执行的操作 [2.4.3.1.2]\n    // 注意到第一个参数传入的是 SIGCHLD, 表明目标信号是 SIGCHLD, 当子进程终结, 被中断, 或者被中断后恢复时, 就会产生此信号\n    sigaction(SIGCHLD, &act, nullptr);\n\n    ...\n\n}\n```\n\n函数前半部分所做的工作是：发起系统调用 sigaction，针对子进程产生的 `SIGCHLD` 信号，当进程在收到信号时，按默认行为对信号进行处理，而 `SIGCHLD` 信号的默认行为就是忽略该信号。\n\n值得注意的是，当子进程终结、被中断或者被中断后恢复时，都会产生 `SIGCHLD` 信号，而添加标志位 `SA_NOCLDSTOP` 可以使得 init 进程只接收子进程终结的信号。\n\n显然，在函数前半部分所做的工作中，并没有实现按自定义行为对信号进行处理。事实上，init 进程是通过监听 signal 文件描述符来实现按自定义行为来处理信号的。接下来分析 InstallSignalFdHandler 函数后半部分所做的工作。\n\n\n\n###### 2.4.3.1.3.2 监听 signal 文件描述符\n\n之前提到，信号是一个异步的通信机制。进程可以注册一个信号处理函数，接着就能继续进行其他的工作，只有当目标信号发送到进程时，才回调处理函数进行处理，这里就体现出异步的性质。\n\n除了异步的方式以外，进程还可以通过同步的方式接收信号。Linux 提供了系统调用 signalfd，用于创建一个接收指定信号的文件描述符。对文件描述符执行读操作会进入阻塞状态，直到目标信号产生并传递给进程。\n\ninit 进程就是通过这种方式来同步接收信号的，接下来分析这个过程：\n\n```c++\nstatic void InstallSignalFdHandler(Epoll* epoll) {\n\n    ...\n\n    // mask 是一个信号集, 用于指定想要接收的信号\n    // 在这里, 目标信号就是 SIGCHLD\n    sigset_t mask;\n    sigemptyset(&mask);\n    sigaddset(&mask, SIGCHLD);\n\n    ...\n\n    // 获取 signal 文件描述符\n    // 注意到, 在发起系统调用 signalfd 时, 传入的第一个参数是 -1, 则调用会创建一个新的文件描述符\n    signal_fd = signalfd(-1, &mask, SFD_CLOEXEC);\n\n    if (signal_fd == -1) {\n        PLOG(FATAL) << \"failed to create signalfd\";\n    }\n\n    // 将 signal 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]\n    // HandleSignalFd 是可读事件触发时的回调函数 [2.4.3.1.4]\n    if (auto result = epoll->RegisterHandler(signal_fd, HandleSignalFd); !result) {\n        LOG(FATAL) << result.error();\n    }\n}\n```\n\n函数后半部分所做的工作是：创建信号集，信号集里面包含了信号 `SIGCHLD`，然后新建一个与信号集关联的 signal 文件描述符，最后将文件描述符注册到 epoll。\n\n当 signal 文件描述符的可读事件触发时，就会调用 HandleSignalFd 函数，接下来分析这个函数。\n\n\n\n##### 2.4.3.1.4 回调函数 HandleSignalFd\n\n函数所在文件的路径为 `system/core/init/init.cpp`：\n\n```c++\nstatic void HandleSignalFd() {\n    signalfd_siginfo siginfo;\n\n    // 从 signal 文件描述符中读取结构体 signalfd_siginfo, 每次读取一个\n    ssize_t bytes_read = TEMP_FAILURE_RETRY(read(signal_fd, &siginfo, sizeof(siginfo)));\n\n    if (bytes_read != sizeof(siginfo)) {\n        PLOG(ERROR) << \"Failed to read siginfo from signal_fd\";\n        return;\n    }\n\n    // 根据信号编号执行相应的操作\n    switch (siginfo.ssi_signo) {\n        case SIGCHLD:\n            ReapAnyOutstandingChildren();\n            break;\n        case SIGTERM:\n            HandleSigtermSignal(siginfo);\n            break;\n        default:\n            PLOG(ERROR) << \"signal_fd: received unexpected signal \" << siginfo.ssi_signo;\n            break;\n    }\n}\n```\n\n当目标信号产生并传递给进程时，signal 文件描述符的可读事件就会触发，返回一个或者多个结构体 signalfd_siginfo。而函数 HandleSignalFd 负责从 signal 文件描述符中读出一个结构体 signalfd_siginfo，并根据信号编号执行相应的操作。\n\n在这里，我们关心的信号是 `SIGCHLD`。当此信号产生后，会调用 ReapAnyOutstandingChildren 函数，接着来分析这个函数。\n\n\n\n###### 2.4.3.1.4.1 分析 ReapAnyOutstandingChildren 函数\n\n函数所在文件的路径为 `system/core/init/sigchld_handler.cpp`：\n\n```c++\nvoid ReapAnyOutstandingChildren() {\n    while (ReapOneProcess()) {\n    }\n}\n```\n\n此函数循环调用 ReapOneProcess 函数，只有当函数 ReapOneProcess 返回 false 时，循环才会停止。接着来看 ReapOneProcess 函数做了什么工作。\n\n\n\n###### 2.4.3.1.4.2 分析 ReapOneProcess 函数\n\n<!-- TODO: 分析 service->flags() -->\n\n<!-- TODO: 分析 ServiceList::GetInstance().RemoveService(*service) -->\n\n函数所在文件的路径为 `system/core/init/sigchld_handler.cpp`：\n\n```c++\nstatic bool ReapOneProcess() {\n    siginfo_t siginfo = {};\n\n    // 发起系统调用 waitid, 此系统调用用于获取子进程状态的变更和相关的信息\n    // 由于 init 进程只接收子进程终结的信号, 因此这里获取到的都是已进入僵尸状态的子进程的相关信息, 信息保存在 siginfo 当中\n    if (TEMP_FAILURE_RETRY(waitid(P_ALL, 0, &siginfo, WEXITED | WNOHANG | WNOWAIT)) != 0) {\n        // 失败, 函数返回 false\n        PLOG(ERROR) << \"waitid failed\";\n        return false;\n    }\n\n    // 获取子进程的 pid\n    auto pid = siginfo.si_pid;\n\n    // 子进程的 pid 不存在, 函数返回 false\n    if (pid == 0) return false;\n\n    ...\n\n    std::string name;\n    std::string wait_string;\n    Service* service = nullptr;\n\n    if (PropertyChildReap(pid)) {\n        name = \"Async property child\";\n    } else if (SubcontextChildReap(pid)) {\n        name = \"Subcontext\";\n    } else {\n        // 根据 pid 查询相应的 service\n        service = ServiceList::GetInstance().FindService(pid, &Service::pid);\n\n        if (service) {\n            name = StringPrintf(\"Service '%s' (pid %d)\", service->name().c_str(), pid);\n\n            ...\n\n        } else {\n            name = StringPrintf(\"Untracked pid %d\", pid);\n        }\n    }\n\n    ...\n\n    // 没有找到对应的 service, 函数返回 true\n    if (!service) return true;\n\n    // 调用 service 的 Reap 函数\n    service->Reap(siginfo);\n\n    ...\n\n    return true;\n}\n```\n\n经分析可知，ReapOneProcess 函数的主要工作是：为每个进入终结状态的子进程发起系统调用 waitid，从而避免已进入僵尸状态的子进程一直占据着系统资源。最后，函数会根据子进程 pid 查找是否存在相应的 service，如果 service 存在，还会调用 service 的 Reap 函数。接着来分析 Reap 函数。\n\n\n\n###### 2.4.3.1.4.3 分析 Reap 函数\n\n函数所在文件的路径为 `system/core/init/service.cpp`：\n\n```c++\nvoid Service::Reap(const siginfo_t& siginfo) {\n    if (!(flags_ & SVC_ONESHOT) || (flags_ & SVC_RESTART)) {\n        // 如果服务的标志位同时不带有 SVC_ONESHOT 和 SVC_RESTART, 则直接杀死服务所在的进程组\n        KillProcessGroup(SIGKILL);\n    }\n\n    ...\n\n    // 如果服务的标志位带有 SVC_TEMPORARY, 则直接返回\n    if (flags_ & SVC_TEMPORARY) return;\n\n    // 重置状态\n    pid_ = 0;\n    flags_ &= (~SVC_RUNNING);\n    start_order_ = 0;\n\n    if ((flags_ & SVC_ONESHOT) && !(flags_ & SVC_RESTART) && !(flags_ & SVC_RESET)) {\n        // 将带有 SVC_ONESHOT 的服务设为不可用状态\n        flags_ |= SVC_DISABLED;\n    }\n\n    if (flags_ & (SVC_DISABLED | SVC_RESET))  {\n        // 如果服务的标志位带有 SVC_DISABLED 或者 SVC_RESET, 则使其进入 stopped 状态, 不会自动重启\n        NotifyStateChange(\"stopped\");\n        return;\n    }\n\n    // 带有标志位 SVC_CRITICAL 的服务会被标记为系统关键服务\n    // 如果服务在 4 分钟之内崩溃 4 次以上, 又或者服务崩溃时系统处于未完全启动状态\n    // 则设备会重启并进入 bootloader 或者设置崩溃相关的属性\n    boot_clock::time_point now = boot_clock::now();\n    if (((flags_ & SVC_CRITICAL) || !pre_apexd_) && !(flags_ & SVC_RESTART)) {\n        bool boot_completed = android::base::GetBoolProperty(\"sys.boot_completed\", false);\n        if (now < time_crashed_ + 4min || !boot_completed) {\n            if (++crash_count_ > 4) {\n                if (flags_ & SVC_CRITICAL) {\n                    // Aborts into bootloader\n                    LOG(FATAL) << \"critical process '\" << name_ << \"' exited 4 times \"\n                               << (boot_completed ? \"in 4 minutes\" : \"before boot completed\");\n                } else {\n                    LOG(ERROR) << \"updatable process '\" << name_ << \"' exited 4 times \"\n                               << (boot_completed ? \"in 4 minutes\" : \"before boot completed\");\n                    // Notifies update_verifier and apexd\n                    property_set(\"ro.init.updatable_crashing\", \"1\");\n                }\n            }\n        } else {\n            time_crashed_ = now;\n            crash_count_ = 1;\n        }\n    }\n\n    // 添加标志位 SVC_RESTARTING, init 进程会重启带有此标志位的服务 [2.4.5.2]\n    flags_ &= (~SVC_RESTART);\n    flags_ |= SVC_RESTARTING;\n\n    // 执行当前 service 中所有 onrestart 命令\n    onrestart_.ExecuteAllCommands();\n\n    // 使服务进入 restarting 状态\n    NotifyStateChange(\"restarting\");\n    return;\n}\n```\n\nReap 函数最主要的工作就是重启有需要的服务。注意到，改变服务状态是通过调用 NotifyStateChange 函数实现的，来看看这个函数。\n\n\n\n###### 2.4.3.1.4.4 分析 NotifyStateChange 函数\n\n函数所在文件的路径为 `system/core/init/service.cpp`：\n\n```c++\nvoid Service::NotifyStateChange(const std::string& new_state) const {\n    if ((flags_ & SVC_TEMPORARY) != 0) {\n        // 如果服务的标志位中带有 SVC_TEMPORARY, 则不会使用属性服务来记录它的状态\n        return;\n    }\n\n    // 使用属性服务来记录服务当前的状态\n    std::string prop_name = \"init.svc.\" + name_;\n    property_set(prop_name, new_state);\n\n    ...\n}\n```\n\n通过分析这个函数，可以知道，系统会使用属性服务以 key-value 的形式存储服务当前的状态，其中 key 的取值为 init.svc.[service_name]，value 是服务当前的状态。因此，可以使用 adb，输入命令 `getprop | grep init.svc.`，查看设备上 service 的运行状态，以下是其中的一些输出：\n\n```\n[init.svc.adbd]: [running]\n[init.svc.alarm-hal-1-0]: [running]\n[init.svc.android.thermal-hal]: [running]\n[init.svc.apexd]: [stopped]\n[init.svc.apexd-bootstrap]: [stopped]\n[init.svc.apexd-snapshotde]: [stopped]\n[init.svc.audioserver]: [running]\n[init.svc.wifidisplayhalservice]: [running]\n[init.svc.wpa_supplicant]: [running]\n[init.svc.zygote]: [running]\n[init.svc.zygote_secondary]: [running]\n```\n\n\n\n### 2.4.4 加载启动脚本\n\n<!-- TODO: 分析函数 CreateParser -->\n\n<!-- TODO: .rc 文件的解析过程 -->\n\n<!-- TODO: 属性的变更如何触发脚本中的属性触发器？ -->\n\n<!-- TODO: /system/etc/init -->\n\n<!-- TODO: /odm/etc/init -->\n\n<!-- TODO: /vendor/etc/init -->\n\n调用 LoadBootScripts 函数加载启动脚本，函数所在文件的路径为 `system/core/init/init.cpp`。\n\n```c++\nstatic void LoadBootScripts(ActionManager& action_manager, ServiceList& service_list) {\n    Parser parser = CreateParser(action_manager, service_list);\n\n    std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\");\n    if (bootscript.empty()) {\n        // 加载 init.rc 脚本文件 [2.4.4.1]\n        parser.ParseConfig(\"/init.rc\");\n\n        // 加载 /system/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/system/etc/init\")) {\n            late_import_paths.emplace_back(\"/system/etc/init\");\n        }\n\n        // 加载 /product/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/product/etc/init\")) {\n            late_import_paths.emplace_back(\"/product/etc/init\");\n        }\n\n        // 加载 /product_services/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/product_services/etc/init\")) {\n            late_import_paths.emplace_back(\"/product_services/etc/init\");\n        }\n\n        // 加载 /odm/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/odm/etc/init\")) {\n            late_import_paths.emplace_back(\"/odm/etc/init\");\n        }\n\n        // 加载 /vendor/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/vendor/etc/init\")) {\n            late_import_paths.emplace_back(\"/vendor/etc/init\");\n        }\n    } else {\n        parser.ParseConfig(bootscript);\n    }\n}\n```\n\n一般情况下，此函数会去加载一些指定的脚本，其中：\n\n- `init.rc` 是主要的 .rc 文件。\n- `/system/etc/init/` 包含了核心的系统项目，例如：SurfaceFlinger, MediaService, logcatd。\n- `/vendor/etc/init/` 包含了 SoC 供应商项目，例如：核心 SoC 功能所需的操作或守护进程。\n- `/odm/etc/init/` 包含了设备制造商项目，例如：运动传感器或其他外围设备所需的操作或守护进程。\n\ninit.rc 是最主要脚本文件，接下来将对这个脚本进行分析。\n\n\n\n#### 2.4.4.1 init.rc 脚本\n\n在 Android，后缀为 .rc 的文件由 Android Init Language 编写，[关于 Android Init Language 的详细说明](https://cs.android.com/android/platform/superproject/+/android-security-10.0.0_r56:system/core/init/README.md) 可以在 AOSP 上找到，路径为 `system/core/init/README.md`。\n\n在分析脚本之前，首先来了解这种语言的语法。\n\n\n\n##### 2.4.4.1.1 Android Init Language\n\nAndroid Init Language 由五大类表达式组成：`Actions`，`Commands`，`Services`，`Options`，`Imports`。\n\n其语法规则有：\n\n- 每一行都是一条语句，一条语句由多个 token 组成，token 之间以空格分开。\n- 如果一个 token 包含了空格，可以跟 c 语言类似，使用反斜杠 `\\` 作为转义字符，又或者使用双引号包裹整个 token。\n- 在行的末尾使用反斜杠 `\\`，可以将语句换行。\n- 以符号 `#` 开头的行是注释行。\n- 系统属性的值可以通过语法 `${property.name}` 获取，例如：`import /init.recovery.${ro.hardware}.rc`。\n- 一个文件可以分为多个 section，必须使用 `Actions` 或者 `Services` 来声明一个新的 section。所有的 `Commands` 和 `Options` 都是属于最近声明的那一个 section。如果在一个 section 之前声明了 `Commands` 或者 `Options` ，则声明会被忽略。\n- `Services` 的名称必须是唯一的，如果存在多个重名的 `Services` ，除了第一个以外，其他的都会被忽略，并且会输出错误日志。\n\n接下来列出一些较为重要的表达式。\n\n\n\n###### 2.4.4.1.1.1 Actions\n\n`Actions` 由 一系列 `Commands` 组成，同时 `Triggers` 决定了 `Actions` 的触发时机，其形式为：\n\n```\non <trigger> [&& <trigger>]*\n   <command>\n   <command>\n   <command>\n```\n\n当一个事件触发后，如果此事件能够匹配上 `Actions` 的  `Triggers`，那么 `Actions` 会被添加到待执行队列的尾部。\n\n之后，待执行队列中的 `Actions` 会按照加入顺序出队，并且执行该 `Actions` 中的 `Commands`。\n\n以启动 Zygote 作为示例：\n\n```\non zygote-start && property:ro.crypto.state=unencrypted\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n```\n\n简单分析这个脚本：\n\n这个 `Actions` 拥有两个 `Triggers`，分别是 `zygote-start` 和 `property:ro.crypto.state=unencrypted`，从第二行开始，每一行都是一个 `Command`。\n\n当事件 `zygote-start` 和 `property:ro.crypto.state=unencrypted` 触发后，`Actions` 会被加入到待执行队列。在执行到该 `Actions` 时，会按照 `Commands` 定义的先后顺序，依次执行 `Actions` 中的 `Commands`。\n\n\n\n###### 2.4.4.1.1.2 Triggers\n\n`Triggers` 是字符串，用于匹配某些类型的事件并触发 `Actions` 中的 `Commands`。\n\nTriggers 可以分为两类：\n\n- **Event triggers**\n\n  事件触发器，这类触发器所匹配的事件由命令 `trigger`  触发，又或者通过调用 `QueueEventTrigger()` 函数触发。\n\n- **Property triggers**\n\n  属性触发器，这类触发器所匹配的事件是：属性是否满足某个值，形式为 `property:<key>=<value>`。这里的属性就是之前提到的属性服务管理的属性。\n\n注意，每一个 `Actions` 可以有多个属性触发器，但只能有一个事件触发器。\n\n例如：\n\n`on init && property:a=b`，`on property:a=b && property:c=d` 是合法的。\n\n`on boot && on init` 是不合法的。\n\n\n\n###### 2.4.4.1.1.3 Commands\n\n下面列举一些常见的 `Commands`：\n\n- **trigger <event>**\n\n  触发一个事件。\n\n- **write <path> <content>**\n\n  按 path 打开文件，往文件中写入内容。\n\n- **chown <owner> <group> <path>**\n\n  更改文件所有者和组。\n\n- **mkdir <path> [mode] [owner] [group]**\n\n  在路径上创建一个目录，可以选择使用给定的权限，所有者，用户组。 \n\n  如果未指定权限，所有者，用户组，则新建的目录默认具有权限 755，并由 root 用户和 root 组拥有。\n\n  当指定权限，所有者，用户组时，如果目录已经存在，则权限，所有者，用户组将被更新。\n\n- **start <service>**\n\n  当指定的服务未在运行时，启动该服务。\n\n- **exec_start <service>**\n\n  启动指定的服务，在该命令返回之前暂停处理其他命令。\n\n- **setprop <name> <value>**\n\n  给系统属性赋值，这里的属性是之前提到的属性服务中的属性。\n\n- **symlink <target> <path>**\n\n  在 path 上创建一个连接到 target 的符号链接。\n\n\n\n###### 2.4.4.1.1.4 Services\n\n`Services` 是由 init 进程启动的程序，一般运行在 init 进程的一个子进程，因此 init 进程在启动一个 `Services` 时会通过 fork 的方式生成子进程。\n\n默认情况下，`Services` 退出后会重启。\n\n`Services` 的形式如下：\n\n```\nservice <name> <pathname> [ <argument> ]*\n   <option>\n   <option>\n   ...\n```\n\n以启动 Zygote 64 位进程的脚本作为示例：\n\n```\nservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server\n    class main\n    priority -20\n    user root\n    group root readproc reserved_disk\n    socket zygote stream 660 root system\n    socket usap_pool_primary stream 660 root system\n    onrestart write /sys/android_power/request_state wake\n    onrestart write /sys/power/state on\n    onrestart restart audioserver\n    onrestart restart cameraserver\n    onrestart restart media\n    onrestart restart netd\n    onrestart restart wificond\n    writepid /dev/cpuset/foreground/tasks\n```\n\n简单分析这个脚本：`zygote` 是 `Services` 的名称，`/system/bin/app_process64` 是可执行文件的路径，`-Xzygote /system/bin --zygote --start-system-server` 是启动参数，从第二行开始，每一行都是一个 `Options`。\n\n\n\n###### 2.4.4.1.1.5 Options\n\n`Options` 是 `Services` 的配置项，用于控制 init 进程运行 `Services` 的方式和时间。\n\n 下面列举一些常见的 `Options`：\n\n- **class <name> [ <name>\\* ]**\n\n  指定 `Services` 的类名。当 `Services` 所属类开启 (退出) 时，`Services` 也会开启 (退出) 。默认值为 default。\n\n- **class_start <serviceclass>**\n\n  启动所有未在运行的，类名被指定为 `serviceclass` 的 `Services`。\n\n- **priority <priority>**\n\n  设置 `Services` 进程的优先级。取值范围是 -20 ~ 19。默认值为 0。\n\n- **user <username>**\n\n  设置执行 `Services` 的用户。一般情况下，默认值为 root。\n\n- **group <groupname> [ <groupname>\\* ]**\n\n  设置执行 `Services` 的用户组。一般情况下，默认值为 root。\n\n- **socket <name> <type> <perm> [ <user> [ <group> [ <seclabel> ] ] ]**\n\n  创建一个 unix 域的 socket，命名为 `/dev/socket/<name>`，并将 socket 的文件描述符传递给创建的进程。\n\n- **onrestart**\n\n  当 `Services` 重启时执行一个 `Commands`。\n\n- **oneshot**\n\n  当 `Services` 退出后不再重启。\n\n- **writepid <file> [ <file>\\* ]**\n\n  在进程 fork 之后，将子进程的 pid 写入指定的文件。\n\n\n\n##### 2.4.4.1.2 加载 init.rc 脚本\n\n脚本文件 init.rc 负责系统的初始设置，文件的路径为 `system/core/rootdir/init.rc`。\n\n在了解到脚本的编写语法之后，可以知道脚本的内容都是由  `Actions` 和 `Services` 构成的，而在 init.rc 脚本中绝大部分都是 `Actions`。在 [2.4.4.1.1.2] 中曾经提到，调用 `QueueEventTrigger()` 函数可以触发一个事件，当事件匹配上  `Actions` 的  `Triggers`，就会开始执行该 `Actions`。 接下来回到进程启动的第二阶段，寻找事件的触发点。\n\n\n\n###### 2.4.4.1.2.1 源码中事件的触发点\n\n回到 init 进程启动的第二阶段，对应源代码 `system/core/init/init.cpp` 的 SecondStageMain 函数：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n\n    ...\n\n    ActionManager& am = ActionManager::GetInstance();\n\n    ...\n\n    // 将触发事件 early-init 的操作加入到 ActionManager\n    am.QueueEventTrigger(\"early-init\");\n\n    ...\n\n    // Trigger all the boot actions to get us started.\n    // 将触发事件 init 的操作加入到 ActionManager\n    am.QueueEventTrigger(\"init\");\n\n    ...\n\n    // Don't mount filesystems or start core system services in charger mode.\n    std::string bootmode = GetProperty(\"ro.bootmode\", \"\");\n    if (bootmode == \"charger\") {\n        // 如果当前处于充电模式, 则将触发事件 charger 的操作加入到 ActionManager\n        // 在充电模式下, 不会挂载文件系统和启动核心系统服务\n        am.QueueEventTrigger(\"charger\");\n    } else {\n        // 如果当前处于非充电模式, 则将触发事件 late-init 的操作加入到 ActionManager\n        am.QueueEventTrigger(\"late-init\");\n    }\n\n    ...\n\n    return 0;\n}\n```\n\nActionManager 会按操作加入的顺序逐一执行 [2.4.5.x]，由此可知事件的触发顺序：\n\n- 非充电模式：early-init -> init -> late-init\n- 充电模式：early-init -> init -> charger\n\n由于在充电模式下，系统可能未完全启动，接下来将选取非充电模式下的流程进行分析。\n\n\n\n###### 2.4.4.1.2.2 init.rc 脚本的执行过程\n\n<!-- TODO: trigger boot -->\n\n现在结合事件的触发顺序，分析脚本执行过程中的一些关键点：\n\n```\non early-init\n    ...\n\n    # 以 start 方式启动 ueventd\n    start ueventd\n\n    # 以 exec_start 方式运行 apexd-bootstrap, 在该命令返回之前暂停处理其他命令, 从而保证后续流程中 APEX 的可用性\n    exec_start apexd-bootstrap\n\non init\n    ...\n\n    # 以 start 方式启动基本服务\n    # 启动 servicemanager [2.4.4.1.2.3]\n    start servicemanager\n    start hwservicemanager\n    start vndservicemanager\n\n# 挂载文件和启动核心系统服务\n# 其中 trigger 用于触发一个事件 [2.4.4.1.1.2]\non late-init\n    trigger early-fs\n    trigger fs\n    trigger post-fs\n    trigger late-fs\n    trigger post-fs-data\n    trigger load_persist_props_action\n\n    # 触发事件 zygote-start, 启动 zygote [2.4.4.1.2.4]\n    trigger zygote-start\n\n    trigger firmware_mounts_complete\n    trigger early-boot\n    trigger boot\n```\n\n经过分析，现在已经大致了解脚本的执行过程，接下来分析 servicemanager 和 zygote 的启动。\n\n\n\n###### 2.4.4.1.2.3 启动 servicemanager\n\nservicemanager 启动脚本的路径为 `frameworks/native/cmds/servicemanager/servicemanager.rc`，分析这个脚本：\n\n```\n# servicemanager 是 Services 的名称\n# /system/bin/servicemanager 是可执行文件的路径\nservice servicemanager /system/bin/servicemanager\n    # 指定类名为 core 和 animation\n    # 当 core 或者 animation 开启 (关闭) 时, servicemanager 也将开启 (关闭)\n    class core animation\n\n    # 设置用户为 system\n    user system\n\n    # 设置用户组为 system 和 readproc\n    group system readproc\n\n    # 将其标记为设备的关键服务\n    # 如果此服务在规定时间内不断重启, 则设备会重启并进入 bootloader\n    critical\n\n    # 设置服务重启后执行的操作\n    # 每一个操作都是一个 Commands\n    onrestart restart healthd\n    onrestart restart zygote\n    onrestart restart audioserver\n    onrestart restart media\n    onrestart restart surfaceflinger\n    onrestart restart inputflinger\n    onrestart restart drm\n    onrestart restart cameraserver\n    onrestart restart keystore\n    onrestart restart gatekeeperd\n    onrestart restart thermalservice\n\n    # 在进程执行 fork 操作之后，将子进程的 pid 写入文件 /dev/cpuset/system-background/tasks\n    writepid /dev/cpuset/system-background/tasks\n\n    # 设置服务的关闭行为\n    # shutdown critical 表示此服务在关闭期间不会被杀死, 当关闭超时后才会被杀死\n    shutdown critical\n```\n\n启动 servicemanager 之后，便会进入 `frameworks/native/cmds/servicemanager/service_manager.c` 的 main 函数。\n\n\n\n###### 2.4.4.1.2.4 启动 zygote\n\n在 init.rc 脚本中，事件 `zygote-start` 有 3 个对应的 `Actions`：\n\n```\non zygote-start && property:ro.crypto.state=unencrypted\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n\non zygote-start && property:ro.crypto.state=unsupported\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n\non zygote-start && property:ro.crypto.state=encrypted && property:ro.crypto.type=file\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n```\n\n其中，zygote 通过以下语句导入：\n\n```\nimport /init.${ro.zygote}.rc\n```\n\n此语句会根据属性 `ro.zygote`，导入相应的文件，其中包括：\n\n```\nsystem/core/rootdir/init.zygote32.rc\nsystem/core/rootdir/init.zygote32_64.rc\nsystem/core/rootdir/init.zygote64.rc\nsystem/core/rootdir/init.zygote64_32.rc\n```\n\nzygote 的启动除了依赖事件 `zygote-start` 以外，还需要某些属性满足特定的值。当上面列出的三个 `Actions` 中的其中一个满足条件后，便会启动 zygote。\n\n这里分析启动 Zygote 64 位进程的脚本，脚本文件的路径为 `system/core/rootdir/init.zygote64.rc`：\n\n```\n# zygote 是 Services 的名称\n# /system/bin/app_process64 是可执行文件的路径\n# -Xzygote /system/bin --zygote --start-system-server 是启动参数\nservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server\n    # 指定类名为 main\n    # 当 main 开启 (关闭) 时, zygote 也将开启 (关闭)\n    class main\n\n    # 进程优先级为 -20\n    # 由于优先级的取值范围是 -20 ~ 19, 数值越小, 优先级越高, 因此 zygote 进程拥有最高的优先级\n    priority -20\n\n    # 用户和用户组都是 root\n    user root\n    group root readproc reserved_disk\n\n    # 创建 socket\n    socket zygote stream 660 root system\n    socket usap_pool_primary stream 660 root system\n\n    # 设置服务重启后执行的操作\n    # 每一个操作都是一个 Commands\n    onrestart write /sys/android_power/request_state wake\n    onrestart write /sys/power/state on\n    onrestart restart audioserver\n    onrestart restart cameraserver\n    onrestart restart media\n    onrestart restart netd\n    onrestart restart wificond\n\n    # 在 zygote 进程执行 fork 操作之后，将子进程的 pid 写入文件 /dev/cpuset/foreground/tasks\n    writepid /dev/cpuset/foreground/tasks\n```\n\n启动 zygote 之后，便会进入 `frameworks/base/cmds/app_process/app_main.cpp` 的 main 函数。\n\n\n\n### 2.4.5 进入无限循环状态\n\ninit 进程启动完成之后，进程就会一直存活，而保持存活的方法就是进入无限循环状态。接下来分析这个过程，源代码的路径为 `system/core/init/init.cpp`：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n\n    ...\n\n    while (true) {\n        // 设置等待 epoll 事件的超时时长\n        // 默认情况下会一直处于阻塞状态, 直到有事件发生, 此时 epoll_timeout 取值为 -1\n        auto epoll_timeout = std::optional<std::chrono::milliseconds>{};\n\n        ...\n\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            // am 是一个引用, 指向 ActionManager 实例\n            // 按顺序执行 ActionManager 中的一个命令 [2.4.5.1]\n            am.ExecuteOneCommand();\n        }\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            if (!shutting_down) {\n                // 获取下一次 HandleProcessActions 的时间点 [2.4.5.2]\n                auto next_process_action_time = HandleProcessActions();\n\n                if (next_process_action_time) {\n                    // 计算出 next_process_action_time 与当前时间的差值\n                    epoll_timeout = std::chrono::ceil<std::chrono::milliseconds>(\n                            *next_process_action_time - boot_clock::now());\n\n                    // 如果差值小于 0, 说明需要立即进行下一次的循环\n                    // 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程\n                    if (*epoll_timeout < 0ms) epoll_timeout = 0ms;\n                }\n            }\n\n            // 如果 ActionManager 中仍有待执行的命令, 那么 init 进程不会进入阻塞状态, 并立即再次唤起\n            // 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程\n            if (am.HasMoreCommands()) epoll_timeout = 0ms;\n        }\n\n        // 调用 Wait 函数, 等待事件触发 [2.4.1.3]\n        if (auto result = epoll.Wait(epoll_timeout); !result) {\n            LOG(ERROR) << result.error();\n        }\n    }\n\n    return 0;\n}\n```\n\n经分析可知，init 进程进入循环状态后主要的工作有 3 个：\n\n- 执行 ActionManager 中的命令。\n- 重启服务。\n- 等待 epoll 事件，当事件触发后，调用相应的函数进行处理。结合前面的分析，可知等待的事件有：一个进程通过请求 init 进程向属性服务写入属性，以及 init 进程接收到 `SIGCHLD` 信号。\n\n\n\n#### 2.4.5.1 ActionManager\n\n<!-- TODO: 什么是 Action? -->\n\n<!-- TODO: Action 和脚本中的 Actions 有没有关系 -->\n\n<!-- TODO: 添加和执行过程 -->\n\nActionManager 是 Action 的管理器，它提供了对 Action 的添加、执行、清空等操作。\n\n\n\n##### 2.4.5.1.1 添加 Action\n\n<!-- TODO: 详细分析 Action 的作用 -->\n\n在 init 进程启动的第二阶段中添加了一些 Action，简单看下其中部分 Action 的作用：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n    ...\n\n    // am 是一个引用, 指向 ActionManager 实例\n    ActionManager& am = ActionManager::GetInstance();\n\n    ...\n\n    am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\");\n\n    // 添加 Action: 触发事件 early-init [2.4.4.1.2.1]\n    am.QueueEventTrigger(\"early-init\");\n\n    // 添加 Action: 等待 coldboot 完成\n    am.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\");\n\n    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\");\n    am.QueueBuiltinAction(SetMmapRndBitsAction, \"SetMmapRndBits\");\n    am.QueueBuiltinAction(SetKptrRestrictAction, \"SetKptrRestrict\");\n    Keychords keychords;\n    am.QueueBuiltinAction(\n        [&epoll, &keychords](const BuiltinArguments& args) -> Result<Success> {\n            for (const auto& svc : ServiceList::GetInstance()) {\n                keychords.Register(svc->keycodes());\n            }\n            keychords.Start(&epoll, HandleKeychord);\n            return Success();\n        },\n        \"KeychordInit\");\n    am.QueueBuiltinAction(console_init_action, \"console_init\");\n\n    // 添加 Action: 触发事件 init [2.4.4.1.2.1]\n    am.QueueEventTrigger(\"init\");\n\n    am.QueueBuiltinAction(StartBoringSslSelfTest, \"StartBoringSslSelfTest\");\n    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\");\n\n    // 添加 Action: 为 init 进程初始化 binder\n    am.QueueBuiltinAction(InitBinder, \"InitBinder\");\n\n    std::string bootmode = GetProperty(\"ro.bootmode\", \"\");\n    if (bootmode == \"charger\") {\n        // 在充电模式下, 添加 Action: 触发事件 charger [2.4.4.1.2.1]\n        am.QueueEventTrigger(\"charger\");\n    } else {\n        // 否则, 添加 Action: 触发事件 late-init [2.4.4.1.2.1]\n        am.QueueEventTrigger(\"late-init\");\n    }\n\n    // 添加 Action: 触发当前所有的属性触发器\n    am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\");\n\n    ...\n\n}\n```\n\n此外，在解析脚本或者属性值改变的时候，也会使用 ActionManager 添加 Action。\n\n\n\n#### 2.4.5.2 HandleProcessActions\n\n<!-- ((s->flags() & SVC_RUNNING) && s->timeout_period()) -->\n\n<!-- 详细分析 service 的重启过程 -->\n\n```c++\nstatic std::optional<boot_clock::time_point> HandleProcessActions() {\n    std::optional<boot_clock::time_point> next_process_action_time;\n\n    // 遍历 ServiceList\n    for (const auto& s : ServiceList::GetInstance()) {\n        // 判断服务是否处于运行中状态, 以及是否有超时时长\n        if ((s->flags() & SVC_RUNNING) && s->timeout_period()) {\n            // 计算出服务启动的超时时间\n            auto timeout_time = s->time_started() + *s->timeout_period();\n\n            if (boot_clock::now() > timeout_time) {\n                // 如果当前时间已大于服务启动的超时时间, 说明服务启动已超时\n                s->Timeout();\n            } else {\n                // 更新 next_process_action_time\n                // 此时, next_process_action_time 表示最近的, 需要检查服务是否启动成功的时间点\n                if (!next_process_action_time || timeout_time < *next_process_action_time) {\n                    next_process_action_time = timeout_time;\n                }\n            }\n        }\n\n        // 如果服务不带有标志位 SVC_RESTARTING, 则不需要重启, 继续 for 循环\n        if (!(s->flags() & SVC_RESTARTING)) continue;\n\n        // 计算出服务启动的超时时间\n        auto restart_time = s->time_started() + s->restart_period();\n\n        // 现在服务需要重启, 接下来重启已满足重启条件的服务\n        if (boot_clock::now() > restart_time) {\n            // 如果当前时间已大于服务的重启时间, 那么立即启动服务\n            if (auto result = s->Start(); !result) {\n                LOG(ERROR) << \"Could not restart process '\" << s->name() << \"': \" << result.error();\n            }\n        } else {\n            // 更新 next_process_action_time\n            // 此时, next_process_action_time 表示最近的, 需要对服务进行重启操作的时间点\n            if (!next_process_action_time || restart_time < *next_process_action_time) {\n                next_process_action_time = restart_time;\n            }\n        }\n    }\n    return next_process_action_time;\n}\n```\n\n此函数的工作有：\n\n1. 检查带有标志位 `SVC_RUNNING` 的服务是否超时，如果服务启动超时，则调用 `Timeout` 函数，否则更新下次检查的时间点。\n2. 当服务带有标志位 `SVC_RESTARTING` 时，说明服务需要重启。如果当前时间已大于服务的重启时间，则立即重启服务；否则，更新下次重启的时间点。 \n\n经分析可知，`next_process_action_time` 可能表示下一次的检查服务是否启动超时的时间点，也可能表示下一次为某个服务重启的时间点。\n\n注意到，在之前的分析信号 [2.4.3.1.4.3] 提到过，当 init 收到子进程终结的信号之后，会为有重启需要的服务添加标志位 `SVC_RESTARTING`。那么现在可以知道，在 init 进程进入无限循环状态后，就会处理这些带有标志位 `SVC_RESTARTING` 的服务，重启满足条件的服务。\n\n\n\n# 参考\n\n[Android系统启动-综述](http://gityuan.com/2016/02/01/android-booting/)\n\n[Android系统启动-Init篇](http://gityuan.com/2016/02/05/android-init/)\n\n[epoll(7)](https://man7.org/linux/man-pages/man7/epoll.7.html)\n\n[Signal](https://en.wikipedia.org/wiki/Signal_(IPC))\n\n[signal(7)](https://man7.org/linux/man-pages/man7/signal.7.html)\n\n[wait(2)](https://man7.org/linux/man-pages/man2/wait.2.html)\n\n[signalfd(2)](https://man7.org/linux/man-pages/man2/signalfd.2.html)\n\n","source":"_posts/2021-07-10-exploring-init-process-startup-process.md","raw":"---\ntitle: 分析 init 进程的启动流程\ndate: 2021-07-10 16:28:09\ncategories:\n- [Android]\n---\n\n\n\n> 本文基于源代码：android-security-10.0.0_r56\n\n\n\n# 1. 前言\n\n<!-- TODO: 关于 init 进程更好的概述 -->\n\nAndroid 基于 Linux 内核，在内核启动过程中会创建出 init 进程。\n\ninit 进程是用户空间的第一个进程，进程的 pid = 1。\n\n<!-- more -->\n\n\n\n# 2. 启动流程\n\n<!-- TODO: 总结 -->\n\n\n\n## 2.1 init 进程的入口\n\n<!-- TODO: 为什么是入口？ -->\n\n<!-- TODO: init 就是一个普通的命令行程序, 位置在 /system/core/init？ -->\n\n在 Android 9，init 进程的入口位于 `system/core/init/init.cpp` 中的 main 函数。\n\n在 Android 10 之后，init 进程的入口改到了 `system/core/init/main.cpp` 中的 main 函数。\n\n```c++\nint main(int argc, char** argv) {\n    ...\n\n    if (!strcmp(basename(argv[0]), \"ueventd\")) {\n        return ueventd_main(argc, argv);\n    }\n\n    if (argc > 1) {\n        if (!strcmp(argv[1], \"subcontext\")) {\n            android::base::InitLogging(argv, &android::base::KernelLogger);\n            const BuiltinFunctionMap& function_map = GetBuiltinFunctionMap();\n\n            return SubcontextMain(argc, argv, &function_map);\n        }\n\n        if (!strcmp(argv[1], \"selinux_setup\")) {\n            return SetupSelinux(argv);\n        }\n\n        if (!strcmp(argv[1], \"second_stage\")) {\n            return SecondStageMain(argc, argv);\n        }\n    }\n\n    return FirstStageMain(argc, argv);\n}\n```\n\n首先来了解其中使用到的两个库函数：`basename` 函数和 `strcmp` 函数。\n\n- `basename` 的函数原型为 `char* basename(char* __path)`，可以根据给定的一个路径，返回文件名。例如：传入参数 \"/system/bin/ueventd\"，函数会返回 \"ueventd\"。\n- `strcmp` 的函数原型为 `int strcmp(const char* __lhs, const char* __rhs)`，是一个字符串比较函数，返回值为整数。当两个字符串相等时，函数返回 0。\n\n再来分析 main 函数：函数的主要工作是根据参数 `argc` 和 `argv`，选择对应的执行方式。如果参数未匹配成功，则默认调用 `FirstStageMain` 函数。\n\n\n\n## 2.2 启动的第一阶段\n\n<!-- TODO: mkdir, mknod, tmpfs -->\n\n<!-- TODO: 所挂载的文件系统的用处 -->\n\n<!-- TODO: KernelLogging(/dev/kmsg) -->\n\n<!-- TODO: InstallRebootSignalHandlers -->\n\n调用 `int FirstStageMain(int argc, char** argv)` 进入启动的第一阶段，函数所在文件的路径为 `system/core/init/first_stage_init.cpp`：\n\n```c++\nint FirstStageMain(int argc, char** argv) {\n    ...\n\n    CHECKCALL(clearenv());\n    CHECKCALL(setenv(\"PATH\", _PATH_DEFPATH, 1));\n    // Get the basic filesystem setup we need put together in the initramdisk\n    // on / and then we'll let the rc file figure out the rest.\n    CHECKCALL(mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"));\n    CHECKCALL(mkdir(\"/dev/pts\", 0755));\n    CHECKCALL(mkdir(\"/dev/socket\", 0755));\n    CHECKCALL(mkdir(\"/dev/dm-user\", 0755));\n    CHECKCALL(mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL));\n#define MAKE_STR(x) __STRING(x)\n    CHECKCALL(mount(\"proc\", \"/proc\", \"proc\", 0, \"hidepid=2,gid=\" MAKE_STR(AID_READPROC)));\n#undef MAKE_STR\n\n    // Don't expose the raw commandline to unprivileged processes.\n    // 设置文件权限 [2.2.1]\n    CHECKCALL(chmod(\"/proc/cmdline\", 0440));\n    std::string cmdline;\n    android::base::ReadFileToString(\"/proc/cmdline\", &cmdline);\n    // Don't expose the raw bootconfig to unprivileged processes.\n    chmod(\"/proc/bootconfig\", 0440);\n    std::string bootconfig;\n    android::base::ReadFileToString(\"/proc/bootconfig\", &bootconfig);\n    gid_t groups[] = {AID_READPROC};\n    CHECKCALL(setgroups(arraysize(groups), groups));\n    CHECKCALL(mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL));\n    CHECKCALL(mount(\"selinuxfs\", \"/sys/fs/selinux\", \"selinuxfs\", 0, NULL));\n\n    CHECKCALL(mknod(\"/dev/kmsg\", S_IFCHR | 0600, makedev(1, 11)));\n\n    if constexpr (WORLD_WRITABLE_KMSG) {\n        CHECKCALL(mknod(\"/dev/kmsg_debug\", S_IFCHR | 0622, makedev(1, 11)));\n    }\n\n    CHECKCALL(mknod(\"/dev/random\", S_IFCHR | 0666, makedev(1, 8)));\n    CHECKCALL(mknod(\"/dev/urandom\", S_IFCHR | 0666, makedev(1, 9)));\n\n    // This is needed for log wrapper, which gets called before ueventd runs.\n    CHECKCALL(mknod(\"/dev/ptmx\", S_IFCHR | 0666, makedev(5, 2)));\n    CHECKCALL(mknod(\"/dev/null\", S_IFCHR | 0666, makedev(1, 3)));\n\n    // These below mounts are done in first stage init so that first stage mount can mount\n    // subdirectories of /mnt/{vendor,product}/.  Other mounts, not required by first stage mount,\n    // should be done in rc files.\n    // Mount staging areas for devices managed by vold\n    // See storage config details at http://source.android.com/devices/storage/\n    CHECKCALL(mount(\"tmpfs\", \"/mnt\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=1000\"));\n    // /mnt/vendor is used to mount vendor-specific partitions that can not be\n    // part of the vendor partition, e.g. because they are mounted read-write.\n    CHECKCALL(mkdir(\"/mnt/vendor\", 0755));\n    // /mnt/product is used to mount product-specific partitions that can not be\n    // part of the product partition, e.g. because they are mounted read-write.\n    CHECKCALL(mkdir(\"/mnt/product\", 0755));\n\n    // /debug_ramdisk is used to preserve additional files from the debug ramdisk\n    CHECKCALL(mount(\"tmpfs\", \"/debug_ramdisk\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=0\"));\n\n    // /second_stage_resources is used to preserve files from first to second\n    // stage init\n    CHECKCALL(mount(\"tmpfs\", kSecondStageRes, \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV,\n                    \"mode=0755,uid=0,gid=0\"))\n#undef CHECKCALL\n\n    SetStdioToDevNull(argv);\n    // Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually\n    // talk to the outside world...\n    InitKernelLogging(argv);\n\n    if (!errors.empty()) {\n        for (const auto& [error_string, error_errno] : errors) {\n            LOG(ERROR) << error_string << \" \" << strerror(error_errno);\n        }\n        LOG(FATAL) << \"Init encountered errors starting first stage, aborting\";\n    }\n\n    LOG(INFO) << \"init first stage started!\";\n\n    ...\n\n    // 执行 /system/bin/init\n    // 注意到传入的参数是 selinux_setup, 因此接下来会调用 SetupSelinux 函数进行 SELinux 的初始化 [2.3]\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"selinux_setup\", nullptr};\n    auto fd = open(\"/dev/kmsg\", O_WRONLY | O_CLOEXEC);\n    dup2(fd, STDOUT_FILENO);\n    dup2(fd, STDERR_FILENO);\n    close(fd);\n    execv(path, const_cast<char**>(args));\n\n    // execv() only returns if an error happened, in which case we\n    // panic and never fall through this conditional.\n    PLOG(FATAL) << \"execv(\\\"\" << path << \"\\\") failed\";\n\n    return 1;\n}\n```\n\n此函数主要工作是挂载一些文件系统，然后执行 `/system/bin/init`，重新进入 main 函数，通过传入参数 `\"selinux_setup\"`，进而调用 SetupSelinux 函数，进行 SELinux 的初始化。\n\n\n\n### 2.2.1 设置文件或目录的权限\n\n在 Linux 系统上，`chmod` 命令用于控制用户对文件或者目录的权限，但只有文件所有者和超级用户可以修改文件或目录的权限。\n\n权限分为三类：读，写，执行。\n\n\n\n#### 2.2.1.1 符号表示法\n\n符号表示法用 10 位字符表示权限，其形式为：\n\n```\n-rwxrwxrwx\n```\n\n其中第一个字符表示文件类型，常见的符号有：\n\n- `-`，表示普通文件。\n- `d`，表示目录。\n- `c`，表示字符特殊文件。\n\n剩余的 9 个字符，每 3 个字符分为一组，分别表示文件所有者，用户组，其他用户的权限。\n\n3 个字符组成的字符串，第 1 位控制读权限，第 2 位控制写权限，第 3 位控制执行权限：\n\n- 如果拥有读权限，第 1 位字符为 `r`，否则为 `-`。\n- 如果拥有写权限，第 2 位字符为 `w`，否则为 `-`。\n- 如果拥有执行权限，第 3 位字符为 `x`，否则为 `-`。\n\n示例：`-rwxrw-r--` 表示一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。\n\n\n\n#### 2.2.1.2 数字表示法\n\n可以用 4 位八进制数字表示权限，第 1 位同样表示文件类型，剩余的 3 位数字，分别表示文件所有者，用户组，其他用户的权限。\n\n读，写，执行，这 3 类权限可以使用 3 位二进制数字表示，不同类型的权限单独对应二进制数字中一个位：\n\n|          数值          | 权限 |\n| :--------------------: | :--: |\n| 二进制：100，八进制：4 |  r   |\n| 二进制：010，八进制：2 |  w   |\n| 二进制：001，八进制：1 |  x   |\n| 二进制：000，八进制：0 |  -   |\n\n在各类权限对应的数值之和，可以代表一组特定的权限。由于和的数值范围为 0~7，因此可以通过一个八进制数字表示。示例：\n\n|          数值          | 权限 |\n| :--------------------: | :--: |\n| 二进制：111，八进制：7 | rwx  |\n| 二进制：110，八进制：6 | rw-  |\n| 二进制：101，八进制：5 | r-x  |\n| 二进制：000，八进制：0 | ---  |\n\n因此，用符号表示法表示的权限，同样可以使用数字表示法来表示，示例：\n\n| 符号表示法 | 数字表示法 |                             说明                             |\n| :--------: | :--------: | :----------------------------------------------------------: |\n| -rwxrwxrwx |    0777    | 一个普通文件，文件所有者，用户组，其他用户都有读，写，执行的权限 |\n| -rwxrw-r-- |    0764    | 一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。 |\n\n\n\n#### 2.2.1.3 分析源码中的权限设置\n\n```c++\n// Don't expose the raw commandline to unprivileged processes.\nCHECKCALL(chmod(\"/proc/cmdline\", 0440));\n\n// Don't expose the raw bootconfig to unprivileged processes.\nchmod(\"/proc/bootconfig\", 0440);\n```\n\n在源码中有两处使用到 `chmod` 命令，分别对文件 `/proc/cmdline`，`/proc/bootconfig` 设置了权限 `0440`，表明 root 用户 (文件所有者) 及其用户组也只有文件的读权限。\n\n\n\n## 2.3 初始化 SELinux\n\n<!-- TODO: 分析 SELinux -->\n\n调用 `int SetupSelinux(char** argv)` 进行 SELinux 的初始化，该函数所在文件的路径为 `system/core/init/selinux.cpp`：\n\n```c++\n// This function initializes SELinux then execs init to run in the init SELinux context.\nint SetupSelinux(char** argv) {\n    ...\n\n    // Set up SELinux, loading the SELinux policy.\n    // 初始化 SELinux\n    SelinuxSetupKernelLogging();\n    SelinuxInitialize();\n\n    ...\n\n    // 执行 /system/bin/init\n    // 注意到传入的参数是 second_stage, 因此接下来会调用 SecondStageMain 函数进入启动的第二阶段 [2.4]\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"second_stage\", nullptr};\n    execv(path, const_cast<char**>(args));\n\n    ...\n\n    return 1;\n}\n```\n\n函数首先初始化了 SELinux，然后执行 `/system/bin/init`，重新进入 main 函数，通过传入参数 `\"second_stage\"`，进而调用 SecondStageMain 函数，进入启动的第二阶段。\n\n\n\n## 2.4 启动的第二阶段\n\n<!-- TODO: property_load_boot_defaults -->\n\n<!-- TODO: 在编译的过程中, android 的各种系统参数会被汇总到 build.prop 文件中？ -->\n\n<!-- TODO: SELinux 相关代码的分析 -->\n\n<!-- TODO: keyctl_get_keyring_ID(KEY_SPEC_SESSION_KEYRING, 1) -->\n\n<!-- TODO: InitializeSubcontext() -->\n\n<!-- TODO: ActionManager 和 ServiceList 的作用 -->\n\n调用 `int SecondStageMain(int argc, char** argv)` 进入启动的第二阶段，函数所在文件的路径为 `system/core/init/init.cpp`：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n    ...\n\n    // Set init and its forked children's oom_adj.\n    // 设置 init 进程以及由其 fork 得到的子进程 oom_score_adj 的值\n    // 数值越小, 进程优先级越高\n    if (auto result = WriteFile(\"/proc/1/oom_score_adj\", \"-1000\"); !result) {\n        LOG(ERROR) << \"Unable to write -1000 to /proc/1/oom_score_adj: \" << result.error();\n    }\n\n    ...\n\n    // 初始化属性服务 [2.4.2.1]\n    property_init();\n\n    ...\n\n    // 初始化 epoll [2.4.1.1]\n    Epoll epoll;\n    if (auto result = epoll.Open(); !result) {\n        PLOG(FATAL) << result.error();\n    }\n\n    // 使用 epoll 对 init 子进程的信号进行监听 [2.4.3.1.3]\n    // 初始化子进程退出的信号处理函数\n    InstallSignalFdHandler(&epoll);\n\n    ...\n\n    // 开启属性服务 [2.4.2.2]\n    StartPropertyService(&epoll);\n\n    ...\n\n    ActionManager& am = ActionManager::GetInstance();\n    ServiceList& sm = ServiceList::GetInstance();\n\n    // 加载启动脚本 [2.4.4]\n    LoadBootScripts(am, sm);\n\n    ...\n\n    // 添加 Action [2.4.5.1]\n    am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\");\n    am.QueueEventTrigger(\"early-init\");\n    am.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\");\n    ...\n    am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\");\n\n    // 进入无限循环状态 [2.4.5]\n    while (true) {\n        auto epoll_timeout = std::optional<std::chrono::milliseconds>{};\n\n        if (do_shutdown && !shutting_down) {\n            do_shutdown = false;\n            if (HandlePowerctlMessage(shutdown_command)) {\n                shutting_down = true;\n            }\n        }\n\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            am.ExecuteOneCommand();\n        }\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            if (!shutting_down) {\n                auto next_process_action_time = HandleProcessActions();\n\n                if (next_process_action_time) {\n                    epoll_timeout = std::chrono::ceil<std::chrono::milliseconds>(\n                            *next_process_action_time - boot_clock::now());\n                    if (*epoll_timeout < 0ms) epoll_timeout = 0ms;\n                }\n            }\n\n            if (am.HasMoreCommands()) epoll_timeout = 0ms;\n        }\n\n        if (auto result = epoll.Wait(epoll_timeout); !result) {\n            LOG(ERROR) << result.error();\n        }\n    }\n\n    return 0;\n}\n```\n\n第二阶段的工作可以大致分为 5 个部分：\n\n- epoll\n\n- 属性服务\n\n- 信号\n\n- 加载启动脚本\n\n- 进入无限循环状态\n\n接下来将分别对这 5 个部分的工作进行分析。\n\n\n\n### 2.4.1 epoll\n\nepoll 是 Linux 提供的 I/O 事件通知机制。epoll 可以监听大量的文件描述符，检查其中某一个文件描述符是否进入就绪状态。\n\n\n\n#### 2.4.1.1 初始化\n\n在 init 进程中，epoll 通过以下代码初始化：\n\n```c++\nEpoll epoll;\nif (auto result = epoll.Open(); !result) {\n    PLOG(FATAL) << result.error();\n}\n```\n\n可以知道，epoll 实例是通过调用 Open 函数创建的，函数所在文件的路径为 `system/core/init/epoll.cpp`，来分析这个函数：\n\n```c++\nResult<Success> Epoll::Open() {\n    if (epoll_fd_ >= 0) return Success();\n\n    // 关键点\n    epoll_fd_.reset(epoll_create1(EPOLL_CLOEXEC));\n\n    if (epoll_fd_ == -1) {\n        return ErrnoError() << \"epoll_create1 failed\";\n    }\n    return Success();\n}\n```\n\n此函数的关键点在于调用 `epoll_create1`。`epoll_create1` 是一个系统调用，其新建了一个 epoll 实例并返回该实例文件描述符。\n\n\n\n#### 2.4.1.2 使用 epoll 监听文件描述符\n\n要使用 epoll 监听文件描述符，需要调用 RegisterHandler 函数，将文件描述符注册到 epoll。\n\n函数所在文件的路径为 `system/core/init/epoll.cpp`，此函数的关键点在于系统调用 epoll_ctl：\n\n```c++\nResult<Success> Epoll::RegisterHandler(int fd, std::function<void()> handler, uint32_t events) {\n    ...\n\n    // 关键点\n    if (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &ev) == -1) {\n\n        ...\n\n        return result;\n    }\n    return Success();\n}\n```\n\n首先来看下 epoll_ctl 这个系统调用。\n\n\n\n##### 2.4.1.2.1 系统调用 epoll_ctl\n\n**epoll_ctl** 是一个系统调用，函数原型为 `int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)`，用于对指定的文件描述符 fd 进行添加、修改或者删除操作。\n\n\n\n###### 2.4.1.2.1.1 参数\n\n首先来理解 epoll_ctl 的参数：\n\n- **epfd** 是 epoll 实例的文件描述符。\n\n- **op** 表示要执行的操作，有三种取值：\n\n  - **EPOLL_CTL_ADD**\n\n    添加指定的文件描述符到 epoll 的监控列表。\n\n  - **EPOLL_CTL_MOD**\n\n    修改 epoll 的监控列表中指定的文件描述符。\n\n  - **EPOLL_CTL_DEL**\n\n    从 epoll 的监控列表中删除指定的文件描述符。\n\n- **fd** 表示指定的文件描述符。\n\n- **event** 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，其定义如下：\n\n  ```c++\n  struct epoll_event {\n     uint32_t     events;      /* Epoll events */\n     epoll_data_t data;        /* User data variable */\n  };\n  ```\n\n  结构体成员 `events` 用于表示要监听的事件，可以由零个或者多个事件类型组成，下面列出部分常见的事件类型：\n\n  - \u0015\u0015**EPOLLIN**\n    表示关联的文件描述符可用于读操作。\n\n  - **EPOLLOUT**\n    表示关联的文件描述符可用于写操作。\n\n  - **EPOLLPRI**\n    表示关联的文件描述符出现异常情况。\n\n  - **EPOLLERR**\n    表示关联的文件描述符出现错误。\n\n  - **EPOLLHUP**\n    表示关联的文件描述符被挂断。\n\n  - **EPOLLONESHOT**\n    表示只监听文件描述符的一次事件。当事件触发之后，epoll 就会禁用此文件描述符。\n    如果想要继续监听该文件描述符的事件，需要再次调用 epoll_ctl，并执行 EPOLL_CTL_MOD 操作。\n\n  结构体成员 `data` 的作用是将其数据交给内核保存，当文件描述符就绪后，内核会返回保存的数据 [2.4.1.3]。`epoll_data_t` 是一个共用体，其定义如下：\n\n  ```c++\n  typedef union epoll_data {\n     void        *ptr;\n     int          fd;\n     uint32_t     u32;\n     uint64_t     u64;\n  } epoll_data_t;\n  ```\n\n\n\n###### 2.4.1.2.1.2 返回值\n\n最后来了解 epoll_ctl 的返回值：\n\n- 当操作成功时，返回值为 0。\n\n- 当发生错误时，返回值为 -1。\n\n\n\n##### 2.4.1.2.2 分析 RegisterHandler 函数\n\n在了解过系统调用 epoll_ctl 以后，现在开始分析 RegisterHandler 函数。首先来看函数在头文件中的声明，头文件的路径为 `system/core/init/epoll.h`：\n\n```c++\nclass Epoll {\n  public:\n    Result<Success> RegisterHandler(int fd, std::function<void()> handler,\n                                    uint32_t events = EPOLLIN);\n};\n```\n\n由函数原型可知，函数的第三个参数 `events` 有默认值 `EPOLLIN`，表示监听文件描述符的读操作是否可用。\n\n接下来分析 RegisterHandler 函数：\n\n```c++\nResult<Success> Epoll::RegisterHandler(int fd, std::function<void()> handler, uint32_t events) {\n    ...\n\n    // handler 是事件触发时的回调函数\n    auto [it, inserted] = epoll_handlers_.emplace(fd, std::move(handler));\n\n    ...\n\n    epoll_event ev;\n\n    // 设置要监听的事件类型\n    // 由于 events 有默认值 EPOLLIN, 因此默认监听的事件类型是读操作是否可用\n    ev.events = events;\n  \n    // 设置回调函数, 回调函数会在事件触发后被调用 [2.4.1.3.2]\n    ev.data.ptr = reinterpret_cast<void*>(&it->second);\n\n    // 发起 epoll_ctl 系统调用\n    // 注意到第二个参数传入的是 EPOLL_CTL_ADD, 因此对指定文件描述符执行的是添加操作\n    if (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &ev) == -1) {\n        Result<Success> result = ErrnoError() << \"epoll_ctl failed to add fd\";\n        epoll_handlers_.erase(fd);\n        return result;\n    }\n    return Success();\n}\n```\n\n经过分析，可以知道函数的主要工作是：设置文件描述符需要监听的事件类型 `events` 以及事件触发时的回调函数 `handler`，最后发起 `epoll_ctl` 系统调用，将文件描述符添加到 epoll 监控列表。\n\n\n\n#### 2.4.1.3 等待事件触发\n\n经过 epoll 的初始化以及将文件描述符注册到 epoll 之后，接下来就需要等待事件触发，然后处理事件。\n\n在 init 进程启动的第二阶段，最后一个步骤就是进入死循环，不断地等待事件触发。接下来看下这段逻辑：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n    ...\n\n    while (true) {\n        ...\n\n        // 关键点\n        if (auto result = epoll.Wait(epoll_timeout); !result) {\n            LOG(ERROR) << result.error();\n        }\n    }\n\n    return 0;\n}\n```\n\n这段逻辑的关键点在于 Wait 函数，接下来分析这个函数。\n\n\n\n##### 2.4.1.3.1 系统调用 epoll_wait\n\n在分析 Wait 函数之前，首先要了解系统调用 epoll_wait，这个系统调用是 Wait 函数的关键点。\n\n**epoll_wait** 是一个系统调用，函数原型为 `int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)`，用于等待 epoll 上的事件。\n\n调用 epoll_wait 便会进入阻塞状态，直至满足以下任一条件，调用才会返回：\n\n- 监听的文件描述符传递一个事件；\n- 调用被信号处理程序中断；\n- 等待超出超时时长。\n\n\n\n###### 2.4.1.3.1.1 参数\n\n首先来理解 epoll_wait 的参数：\n\n- **epfd** 是 epoll 实例的文件描述符。\n\n- **events** 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，在 [2.4.1.2.1] 一节已经详细介绍过。\n\n  当事件触发后，调用就会返回，此时可以从 events 中得到已触发事件的集合。集合中每一个事件结构体 epoll_event 的 data 字段和调用 epoll_ctl 为相应的文件描述符设置的 data 字段是相同的。意味着，当事件触发后，之前调用 epoll_ctl 给指定文件描述符设置的 event.data 会通过这个参数返回给 epoll_wait 的调用者。\n\n- **maxevents** 表示在一次调用中返回事件的最大数量。因此，从参数 events 中得到的事件数量不会大于 maxevents。\n\n- **timeout** 是此次调用的超时时长。当 timeout = -1 时，调用将会一直阻塞，直到有事件发生；当 timeout = 0 时，调用会立即返回，即使当前没有事件发生。\n\n\n\n###### 2.4.1.3.1.2 返回值\n\n最后来了解 epoll_wait 的返回值：\n\n- 当调用成功时，返回值为已就绪的文件描述符的数量，此时可以对这些文件描述符进行 I/O 操作。\n\n  需要注意的是，如果该调用是因为超出等待时长而返回的，则返回值为 0，表明没有已就绪的文件描述符。\n\n- 当调用失败时，返回值为 -1，并返回错误信息。\n\n\n\n##### 2.4.1.3.2 分析 Wait 函数\n\n在了解过系统调用 epoll_wait 以后，就可以开始分析 Wait 函数，函数所在文件的路径为 `system/core/init/epoll.cpp`：\n\n```c++\nResult<Success> Epoll::Wait(std::optional<std::chrono::milliseconds> timeout) {\n    // 超时时长默认值为 -1\n    int timeout_ms = -1;\n\n    if (timeout && timeout->count() < INT_MAX) {\n        // 当参数 timeout 满足不等于 0 和数值没有溢出时, 更新超时时长\n        timeout_ms = timeout->count();\n    }\n\n    epoll_event ev;\n\n    // 发起 epoll_wait 系统调用\n    // 注意到第三个参数传入的是 1, 表明每次调用最多返回 1 个事件\n    auto nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd_, &ev, 1, timeout_ms));\n\n    if (nr == -1) {\n        // 调用返回 -1, 表明此次调用失败\n        return ErrnoError() << \"epoll_wait failed\";\n    } else if (nr == 1) {\n        // 调用返回 1, 表明此次调用成功, 有 1 个事件触发\n        // ev.data.ptr 是之前调用 epoll_ctl 给指定文件描述符设置的回调函数, 因此事件最后交给回调函数进行处理\n        std::invoke(*reinterpret_cast<std::function<void()>*>(ev.data.ptr));\n    }\n    return Success();\n}\n```\n\n此函数设置了超时时长，然后发起 `epoll_wait` 系统调用，等待事件触发。当 `epoll_wait` 成功返回时，会从返回的数据里面取出之前通过 epoll_ctl 设置的回调函数，将事件交由回调函数处理。\n\n\n\n### 2.4.2 属性服务\n\n属性服务是 Android 提供的一个用于存取系统属性的服务，属性以 key-value 的形式存储在一块共享内存，所有进程都可以通过这个服务获取和设置属性。\n\n使用 adb，输入命令 `getprop`，可以查看一台设备上的属性，下面列举其中的一些输出：\n\n```\n[ro.product.brand]: [Redmi]\n[ro.product.manufacturer]: [Xiaomi]\n[ro.product.marketname]: [Redmi K30S Ultra]\n[ro.product.model]: [M2007J3SC]\n[ro.product.name]: [apollo]\n\n[ro.product.cpu.abi]: [arm64-v8a]\n[ro.product.cpu.abilist]: [arm64-v8a,armeabi-v7a,armeabi]\n[ro.product.cpu.abilist32]: [armeabi-v7a,armeabi]\n[ro.product.cpu.abilist64]: [arm64-v8a]\n\n[dalvik.vm.heapsize]: [512m]\n[dalvik.vm.heapstartsize]: [8m]\n```\n\n通过列举出的数据，可以看出属性里面包含了很多重要的信息：机型信息，CPU 架构，虚拟机分配的内存大小等等。\n\n在 Java 代码中，可以调用 `SystemProperties.get(String, String)` 方法获取系统属性。例如，在 ActivityManager 中就有这样的代码：\n\n```java\nstatic public int staticGetLargeMemoryClass() {\n    // 通过获取系统属性 dalvik.vm.heapsize, 得出应用可用堆内存的最大值\n    String vmHeapSize = SystemProperties.get(\"dalvik.vm.heapsize\", \"16m\");\n\n    return Integer.parseInt(vmHeapSize.substring(0, vmHeapSize.length() - 1));\n}\n```\n\n类似地，调用 `SystemProperties.set(String, String)` 方法可以设置系统属性。例如，在 ActivityManagerService 中就有这样的代码：\n\n```java\nfinal void finishBooting() {\n    ...\n\n    synchronized (this) {\n\n        ...\n\n        // Tell anyone interested that we are done booting!\n        // 通过设置属性 sys.boot_completed = 1, 标记系统已经启动完成\n        SystemProperties.set(\"sys.boot_completed\", \"1\");\n\n        ...\n    }\n\n    ...\n}\n```\n\n\n\n#### 2.4.2.1 初始化\n\n<!-- TODO: 如何创建内存区域？ -->\n\n<!-- TODO: 进程是怎样获取共享内存中的属性？ -->\n\n<!-- TODO: 进程为什么不能直接设置共享内存中的属性？ -->\n\n<!-- TODO: CreateSerializedPropertyInfo() -->\n\n<!-- TODO: property_info_area.LoadDefaultPath() -->\n\n属性服务初始化时，调用的是 property_init 函数，文件路径为 `system/core/init/property_service.cpp`。\n\n```c++\nvoid property_init() {\n    mkdir(\"/dev/__properties__\", S_IRWXU | S_IXGRP | S_IXOTH);\n    CreateSerializedPropertyInfo();\n\n    // 创建内存区域\n    if (__system_property_area_init()) {\n        LOG(FATAL) << \"Failed to initialize property area\";\n    }\n\n    if (!property_info_area.LoadDefaultPath()) {\n        LOG(FATAL) << \"Failed to load serialized property info file\";\n    }\n}\n```\n\n函数最主要的工作是通过调用 `__system_property_area_init` 函数，创建用于存储属性的内存区域。\n\n\n\n#### 2.4.2.2 启动\n\n<!-- TODO: socket 的创建过程 -->\n\n<!-- TODO: listen(property_set_fd, 8) -->\n\n<!-- TODO: 一个进程是怎样向 init 进程发起属性设置的请求？ -->\n\n属性服务启动时，调用的是 StartPropertyService 函数，文件路径为 `system/core/init/property_service.cpp`：\n\n```c++\nvoid StartPropertyService(Epoll* epoll) {\n\n    ...\n\n    // 创建 socket 并返回其文件描述符, 其中 PROP_SERVICE_NAME = \"property_service\"\n    property_set_fd = CreateSocket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,\n                                   false, 0666, 0, 0, nullptr);\n    if (property_set_fd == -1) {\n        PLOG(FATAL) << \"start_property_service socket creation failed\";\n    }\n\n    listen(property_set_fd, 8);\n\n    // 将 socket 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]\n    // handle_property_set_fd 是可读事件触发时的回调函数 [2.4.2.3]\n    if (auto result = epoll->RegisterHandler(property_set_fd, handle_property_set_fd); !result) {\n        PLOG(FATAL) << result.error();\n    }\n}\n```\n\n此函数首先创建名称为 property_service 的 socket，然后将 socket 文件描述符注册到 epoll，监听其可读事件。\n\n当可读事件触发时，会进入回调函数 `handle_property_set_fd`，接着来分析这个回调函数。\n\n\n\n#### 2.4.2.3 回调函数 handle_property_set_fd\n\n<!-- TODO: ucred cr; socklen_t cr_size = sizeof(cr); -->\n\n<!-- TODO: 设置属性的具体实现 -->\n\n<!-- TODO: 除了通过向 init 进程发出请求设置属性以外, 在其他地方是否也有属性的设置？ -->\n\n<!-- TODO: 属性的同步问题 -->\n\n函数所在文件的路径为 `system/core/init/property_service.cpp`：\n\n```c++\nstatic void handle_property_set_fd() {\n    // 2000ms\n    static constexpr uint32_t kDefaultSocketTimeout = 2000; /* ms */\n\n    ...\n\n    SocketConnection socket(s, cr);\n\n    // 设置 2000ms 的超时时长\n    uint32_t timeout_ms = kDefaultSocketTimeout;\n\n    uint32_t cmd = 0;\n    if (!socket.RecvUint32(&cmd, &timeout_ms)) {\n        PLOG(ERROR) << \"sys_prop: error while reading command from the socket\";\n        socket.SendUint32(PROP_ERROR_READ_CMD);\n        return;\n    }\n\n    switch (cmd) {\n    // 处理 PROP_MSG_SETPROP 命令\n    case PROP_MSG_SETPROP: {\n        // PROP_NAME_MAX = 32\n        char prop_name[PROP_NAME_MAX];\n        char prop_value[PROP_VALUE_MAX];\n\n        // 接收属性名和属性值, 分别存储于字符数组 prop_name 和 prop_value 中\n        if (!socket.RecvChars(prop_name, PROP_NAME_MAX, &timeout_ms) ||\n            !socket.RecvChars(prop_value, PROP_VALUE_MAX, &timeout_ms)) {\n          PLOG(ERROR) << \"sys_prop(PROP_MSG_SETPROP): error while reading name/value from the socket\";\n          return;\n        }\n\n        // 将字符数组中最后的一个元素设置为 0\n        prop_name[PROP_NAME_MAX-1] = 0;\n        prop_value[PROP_VALUE_MAX-1] = 0;\n\n        const auto& cr = socket.cred();\n        std::string error;\n\n        // 设置属性\n        uint32_t result =\n            HandlePropertySet(prop_name, prop_value, socket.source_context(), cr, &error);\n\n        if (result != PROP_SUCCESS) {\n            LOG(ERROR) << \"Unable to set property '\" << prop_name << \"' to '\" << prop_value\n                       << \"' from uid:\" << cr.uid << \" gid:\" << cr.gid << \" pid:\" << cr.pid << \": \"\n                       << error;\n        }\n\n        break;\n      }\n\n    // 处理 PROP_MSG_SETPROP2 命令\n    case PROP_MSG_SETPROP2: {\n        std::string name;\n        std::string value;\n\n        // 接收字符串类型的属性名和属性值\n        if (!socket.RecvString(&name, &timeout_ms) ||\n            !socket.RecvString(&value, &timeout_ms)) {\n          PLOG(ERROR) << \"sys_prop(PROP_MSG_SETPROP2): error while reading name/value from the socket\";\n          socket.SendUint32(PROP_ERROR_READ_DATA);\n          return;\n        }\n\n        const auto& cr = socket.cred();\n        std::string error;\n\n        // 设置属性\n        uint32_t result = HandlePropertySet(name, value, socket.source_context(), cr, &error);\n\n        if (result != PROP_SUCCESS) {\n            LOG(ERROR) << \"Unable to set property '\" << name << \"' to '\" << value\n                       << \"' from uid:\" << cr.uid << \" gid:\" << cr.gid << \" pid:\" << cr.pid << \": \"\n                       << error;\n        }\n        socket.SendUint32(result);\n        break;\n      }\n\n    default:\n        LOG(ERROR) << \"sys_prop: invalid command \" << cmd;\n        socket.SendUint32(PROP_ERROR_INVALID_CMD);\n        break;\n    }\n}\n```\n\n函数初始化了 socket 接收事件的超时时长，然后对接收到的 `cmd` 做相应的操作：\n\n- 对于 `PROP_MSG_SETPROP` 命令，使用两个长度为 `PROP_NAME_MAX` 的字符数组保存接收到的属性名和属性值。值得注意的是，最后会将字符数组中最后的一个元素设为 0，因此接收的属性名和属性值的最大长度不应超过 `PROP_NAME_MAX - 1` 。\n- 对于 `PROP_MSG_SETPROP2` 命令，使用两个 `std::string` 保存接收到的属性名和属性值。\n\n最后，不论是 `PROP_MSG_SETPROP` 命令还是 `PROP_MSG_SETPROP2` 命令，都会调用 `HandlePropertySet` 函数来设置属性。\n\n\n\n### 2.4.3 信号\n\n**信号 (Signals)** 属于 IPC 的一种方式，用于向一个进程或者进程中的特定线程发送事件通知。\n\n信号是一个**异步的**通信机制，一个进程可以不需要等待信号的到达。在信号未产生时，进程会正常执行；当信号产生后，系统可以中断目标进程的任何非原子操作，此时进程的正常执行流程会被中断，进而对信号进行处理。\n\n\n\n#### 2.4.3.1 处理信号\n\n在 Linux，一个子进程终结后，内核依然会为其维护关于此进程的最小信息集 (PID、终结状态、资源使用信息)，以便父进程获取有关子进程的信息。如果父进程没有为该子进程发起 wait、waitpid 或者 waitid 系统调用，那么子进程的信息就会一直占据着内核进程表的空间。在这种情况下，这个子进程就成为了一个**僵尸进程 (Zombie process)**。\n\n一般情况下，对于一个僵尸进程，如果其父进程终结了，那么 init 进程就会自动成为僵尸进程的父进程。此时，为了避免僵尸进程一直占据着系统资源，init 进程需要为僵尸进程释放占据的空间。\n\n而且，在加载启动脚本 [2.4.4] 这一步骤中，init 进程会 fork 得到一些子进程，例如：servicemanager 进程、zygote 进程。这些子进程对 Android 而言非常重要，在这些进程退出后，init 进程需要有相应的动作将其重启。\n\n于是，为了管理这些子进程，init 进程需要接收子进程终结的信号并进行相应的处理。\n\n在 Android，信号处理基于 Linux 的信号机制。\n\n\n\n##### 2.4.3.1.1 信号的处理方式\n\n<!-- 更正: 注册信号处理函数 -->\n\n信号的处理方式有以下三种：\n\n- **忽略该信号**\n- **按信号的默认行为处理该信号**\n- **使用自定义的信号处理函数来处理该信号**\n\ninit 进程使用的是第三种处理方式：使用自定义的信号处理函数来处理该信号。进程注册了一个信号处理函数，当目标信号产生时，信号会被捕获，并调用注册的函数进行处理。\n\n接下来分析这个过程。\n\n\n\n##### 2.4.3.1.2 系统调用 sigaction\n\n在分析 init 进程注册函数的过程之前，首先来了解系统调用 sigaction，这个系统调用是此过程的一个关键点。\n\n**sigaction** 是一个系统调用，函数原型为 `int sigaction(int signum, const struct sigaction *restrict act, struct sigaction *restrict oldact)`，用于更改进程在收到指定信号后的行为。\n\n\n\n###### 2.4.3.1.2.1 参数\n\n首先来理解 sigaction 的参数：\n\n- **signum** 是指定信号的编号。\n\n  同一个信号在不同的架构上可能有不同的编号。在 Android，ARM 架构的信号编号定义在 `bionic/libc/kernel/uapi/asm-arm/asm/signal.h` 文件上。\n\n- **act** 是一个 sigaction 类型的指针，而 sigaction 是一个结构体，其定义如下：\n\n  ```c++\n  struct sigaction {\n     void     (*sa_handler)(int);\n     void     (*sa_sigaction)(int, siginfo_t *, void *);\n     sigset_t   sa_mask;\n     int        sa_flags;\n     void     (*sa_restorer)(void);\n  };\n  ```\n\n  关注结构体中两个较为重要的成员 `sa_handler` 和 `sa_flags`。\n\n  成员 `sa_handler` 用于指定信号产生时的行为，可以是以下这些值之一：\n\n  - **SIG_DFL**\n\n    表示执行该信号的默认行为。\n\n  - **SIG_IGN**\n\n    表示忽略该信号。\n\n  - **一个指向信号处理函数的指针**\n\n    信号编号 signum 将作为函数的唯一参数传入。当目标信号产生时，会自动调用此函数进行处理。\n\n  成员 `sa_flags` 是标志位，可以由零个或者多个标志组成。下面列出其中的一些标志：\n\n  - **SA_NOCLDSTOP**\n\n    只有当 signum = SIGCHLD 时才有意义。表示进程不接收子进程停止或者恢复时产生的信号，只接收子进程终结的信号。\n\n  - **SA_RESETHAND**\n\n    当信号已经由信号处理函数处理过后，将信号恢复为使用默认行为进行处理。\n\n  - **SA_SIGINFO**\n\n    不再通过结构体成员 sa_handler 设置信号处理函数，而是使用成员 sa_sigaction。此时，函数的入参有三个。\n\n- **oldact** 同样是一个 sigaction 类型的指针，用于保存上一个 sigaction 调用所传入的参数 act，可以为空。\n\n\n\n###### 2.4.3.1.2.2 返回值\n\n最后来了解 sigaction 的返回值：\n\n- 当操作成功时，返回值为 0。\n\n- 当发生错误时，返回值为 -1。\n\n\n\n##### 2.4.3.1.3 init 进程注册信号处理函数\n\n在了解过系统调用 sigaction 以后，现在可以开始分析 init 进程注册信号处理函数的过程。\n\n\n\n###### 2.4.3.1.3.1 发起系统调用 sigaction\n\ninit 进程通过调用 InstallSignalFdHandler 函数实现注册信号处理函数，函数所在文件的路径为 `system/core/init/init.cpp`，首先来关注函数前半部分所做的工作：\n\n```c++\nstatic void InstallSignalFdHandler(Epoll* epoll) {\n    // 构建结构体 sigaction\n    // 成员 sa_handler 用于指定信号产生时的行为, 令 sa_handler = SIG_DFL 表明当信号产生时按默认行为对信号进行处理\n    // 成员 sa_flags 是标志位, 令 sa_flags = SA_NOCLDSTOP 表明 init 进程不接收子进程被中断或者被中断后恢复时产生的信号, 只接收子进程终结的信号\n    const struct sigaction act { .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDSTOP };\n\n    // sigaction 是一个系统调用, 用于更改进程在收到指定的信号时所执行的操作 [2.4.3.1.2]\n    // 注意到第一个参数传入的是 SIGCHLD, 表明目标信号是 SIGCHLD, 当子进程终结, 被中断, 或者被中断后恢复时, 就会产生此信号\n    sigaction(SIGCHLD, &act, nullptr);\n\n    ...\n\n}\n```\n\n函数前半部分所做的工作是：发起系统调用 sigaction，针对子进程产生的 `SIGCHLD` 信号，当进程在收到信号时，按默认行为对信号进行处理，而 `SIGCHLD` 信号的默认行为就是忽略该信号。\n\n值得注意的是，当子进程终结、被中断或者被中断后恢复时，都会产生 `SIGCHLD` 信号，而添加标志位 `SA_NOCLDSTOP` 可以使得 init 进程只接收子进程终结的信号。\n\n显然，在函数前半部分所做的工作中，并没有实现按自定义行为对信号进行处理。事实上，init 进程是通过监听 signal 文件描述符来实现按自定义行为来处理信号的。接下来分析 InstallSignalFdHandler 函数后半部分所做的工作。\n\n\n\n###### 2.4.3.1.3.2 监听 signal 文件描述符\n\n之前提到，信号是一个异步的通信机制。进程可以注册一个信号处理函数，接着就能继续进行其他的工作，只有当目标信号发送到进程时，才回调处理函数进行处理，这里就体现出异步的性质。\n\n除了异步的方式以外，进程还可以通过同步的方式接收信号。Linux 提供了系统调用 signalfd，用于创建一个接收指定信号的文件描述符。对文件描述符执行读操作会进入阻塞状态，直到目标信号产生并传递给进程。\n\ninit 进程就是通过这种方式来同步接收信号的，接下来分析这个过程：\n\n```c++\nstatic void InstallSignalFdHandler(Epoll* epoll) {\n\n    ...\n\n    // mask 是一个信号集, 用于指定想要接收的信号\n    // 在这里, 目标信号就是 SIGCHLD\n    sigset_t mask;\n    sigemptyset(&mask);\n    sigaddset(&mask, SIGCHLD);\n\n    ...\n\n    // 获取 signal 文件描述符\n    // 注意到, 在发起系统调用 signalfd 时, 传入的第一个参数是 -1, 则调用会创建一个新的文件描述符\n    signal_fd = signalfd(-1, &mask, SFD_CLOEXEC);\n\n    if (signal_fd == -1) {\n        PLOG(FATAL) << \"failed to create signalfd\";\n    }\n\n    // 将 signal 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]\n    // HandleSignalFd 是可读事件触发时的回调函数 [2.4.3.1.4]\n    if (auto result = epoll->RegisterHandler(signal_fd, HandleSignalFd); !result) {\n        LOG(FATAL) << result.error();\n    }\n}\n```\n\n函数后半部分所做的工作是：创建信号集，信号集里面包含了信号 `SIGCHLD`，然后新建一个与信号集关联的 signal 文件描述符，最后将文件描述符注册到 epoll。\n\n当 signal 文件描述符的可读事件触发时，就会调用 HandleSignalFd 函数，接下来分析这个函数。\n\n\n\n##### 2.4.3.1.4 回调函数 HandleSignalFd\n\n函数所在文件的路径为 `system/core/init/init.cpp`：\n\n```c++\nstatic void HandleSignalFd() {\n    signalfd_siginfo siginfo;\n\n    // 从 signal 文件描述符中读取结构体 signalfd_siginfo, 每次读取一个\n    ssize_t bytes_read = TEMP_FAILURE_RETRY(read(signal_fd, &siginfo, sizeof(siginfo)));\n\n    if (bytes_read != sizeof(siginfo)) {\n        PLOG(ERROR) << \"Failed to read siginfo from signal_fd\";\n        return;\n    }\n\n    // 根据信号编号执行相应的操作\n    switch (siginfo.ssi_signo) {\n        case SIGCHLD:\n            ReapAnyOutstandingChildren();\n            break;\n        case SIGTERM:\n            HandleSigtermSignal(siginfo);\n            break;\n        default:\n            PLOG(ERROR) << \"signal_fd: received unexpected signal \" << siginfo.ssi_signo;\n            break;\n    }\n}\n```\n\n当目标信号产生并传递给进程时，signal 文件描述符的可读事件就会触发，返回一个或者多个结构体 signalfd_siginfo。而函数 HandleSignalFd 负责从 signal 文件描述符中读出一个结构体 signalfd_siginfo，并根据信号编号执行相应的操作。\n\n在这里，我们关心的信号是 `SIGCHLD`。当此信号产生后，会调用 ReapAnyOutstandingChildren 函数，接着来分析这个函数。\n\n\n\n###### 2.4.3.1.4.1 分析 ReapAnyOutstandingChildren 函数\n\n函数所在文件的路径为 `system/core/init/sigchld_handler.cpp`：\n\n```c++\nvoid ReapAnyOutstandingChildren() {\n    while (ReapOneProcess()) {\n    }\n}\n```\n\n此函数循环调用 ReapOneProcess 函数，只有当函数 ReapOneProcess 返回 false 时，循环才会停止。接着来看 ReapOneProcess 函数做了什么工作。\n\n\n\n###### 2.4.3.1.4.2 分析 ReapOneProcess 函数\n\n<!-- TODO: 分析 service->flags() -->\n\n<!-- TODO: 分析 ServiceList::GetInstance().RemoveService(*service) -->\n\n函数所在文件的路径为 `system/core/init/sigchld_handler.cpp`：\n\n```c++\nstatic bool ReapOneProcess() {\n    siginfo_t siginfo = {};\n\n    // 发起系统调用 waitid, 此系统调用用于获取子进程状态的变更和相关的信息\n    // 由于 init 进程只接收子进程终结的信号, 因此这里获取到的都是已进入僵尸状态的子进程的相关信息, 信息保存在 siginfo 当中\n    if (TEMP_FAILURE_RETRY(waitid(P_ALL, 0, &siginfo, WEXITED | WNOHANG | WNOWAIT)) != 0) {\n        // 失败, 函数返回 false\n        PLOG(ERROR) << \"waitid failed\";\n        return false;\n    }\n\n    // 获取子进程的 pid\n    auto pid = siginfo.si_pid;\n\n    // 子进程的 pid 不存在, 函数返回 false\n    if (pid == 0) return false;\n\n    ...\n\n    std::string name;\n    std::string wait_string;\n    Service* service = nullptr;\n\n    if (PropertyChildReap(pid)) {\n        name = \"Async property child\";\n    } else if (SubcontextChildReap(pid)) {\n        name = \"Subcontext\";\n    } else {\n        // 根据 pid 查询相应的 service\n        service = ServiceList::GetInstance().FindService(pid, &Service::pid);\n\n        if (service) {\n            name = StringPrintf(\"Service '%s' (pid %d)\", service->name().c_str(), pid);\n\n            ...\n\n        } else {\n            name = StringPrintf(\"Untracked pid %d\", pid);\n        }\n    }\n\n    ...\n\n    // 没有找到对应的 service, 函数返回 true\n    if (!service) return true;\n\n    // 调用 service 的 Reap 函数\n    service->Reap(siginfo);\n\n    ...\n\n    return true;\n}\n```\n\n经分析可知，ReapOneProcess 函数的主要工作是：为每个进入终结状态的子进程发起系统调用 waitid，从而避免已进入僵尸状态的子进程一直占据着系统资源。最后，函数会根据子进程 pid 查找是否存在相应的 service，如果 service 存在，还会调用 service 的 Reap 函数。接着来分析 Reap 函数。\n\n\n\n###### 2.4.3.1.4.3 分析 Reap 函数\n\n函数所在文件的路径为 `system/core/init/service.cpp`：\n\n```c++\nvoid Service::Reap(const siginfo_t& siginfo) {\n    if (!(flags_ & SVC_ONESHOT) || (flags_ & SVC_RESTART)) {\n        // 如果服务的标志位同时不带有 SVC_ONESHOT 和 SVC_RESTART, 则直接杀死服务所在的进程组\n        KillProcessGroup(SIGKILL);\n    }\n\n    ...\n\n    // 如果服务的标志位带有 SVC_TEMPORARY, 则直接返回\n    if (flags_ & SVC_TEMPORARY) return;\n\n    // 重置状态\n    pid_ = 0;\n    flags_ &= (~SVC_RUNNING);\n    start_order_ = 0;\n\n    if ((flags_ & SVC_ONESHOT) && !(flags_ & SVC_RESTART) && !(flags_ & SVC_RESET)) {\n        // 将带有 SVC_ONESHOT 的服务设为不可用状态\n        flags_ |= SVC_DISABLED;\n    }\n\n    if (flags_ & (SVC_DISABLED | SVC_RESET))  {\n        // 如果服务的标志位带有 SVC_DISABLED 或者 SVC_RESET, 则使其进入 stopped 状态, 不会自动重启\n        NotifyStateChange(\"stopped\");\n        return;\n    }\n\n    // 带有标志位 SVC_CRITICAL 的服务会被标记为系统关键服务\n    // 如果服务在 4 分钟之内崩溃 4 次以上, 又或者服务崩溃时系统处于未完全启动状态\n    // 则设备会重启并进入 bootloader 或者设置崩溃相关的属性\n    boot_clock::time_point now = boot_clock::now();\n    if (((flags_ & SVC_CRITICAL) || !pre_apexd_) && !(flags_ & SVC_RESTART)) {\n        bool boot_completed = android::base::GetBoolProperty(\"sys.boot_completed\", false);\n        if (now < time_crashed_ + 4min || !boot_completed) {\n            if (++crash_count_ > 4) {\n                if (flags_ & SVC_CRITICAL) {\n                    // Aborts into bootloader\n                    LOG(FATAL) << \"critical process '\" << name_ << \"' exited 4 times \"\n                               << (boot_completed ? \"in 4 minutes\" : \"before boot completed\");\n                } else {\n                    LOG(ERROR) << \"updatable process '\" << name_ << \"' exited 4 times \"\n                               << (boot_completed ? \"in 4 minutes\" : \"before boot completed\");\n                    // Notifies update_verifier and apexd\n                    property_set(\"ro.init.updatable_crashing\", \"1\");\n                }\n            }\n        } else {\n            time_crashed_ = now;\n            crash_count_ = 1;\n        }\n    }\n\n    // 添加标志位 SVC_RESTARTING, init 进程会重启带有此标志位的服务 [2.4.5.2]\n    flags_ &= (~SVC_RESTART);\n    flags_ |= SVC_RESTARTING;\n\n    // 执行当前 service 中所有 onrestart 命令\n    onrestart_.ExecuteAllCommands();\n\n    // 使服务进入 restarting 状态\n    NotifyStateChange(\"restarting\");\n    return;\n}\n```\n\nReap 函数最主要的工作就是重启有需要的服务。注意到，改变服务状态是通过调用 NotifyStateChange 函数实现的，来看看这个函数。\n\n\n\n###### 2.4.3.1.4.4 分析 NotifyStateChange 函数\n\n函数所在文件的路径为 `system/core/init/service.cpp`：\n\n```c++\nvoid Service::NotifyStateChange(const std::string& new_state) const {\n    if ((flags_ & SVC_TEMPORARY) != 0) {\n        // 如果服务的标志位中带有 SVC_TEMPORARY, 则不会使用属性服务来记录它的状态\n        return;\n    }\n\n    // 使用属性服务来记录服务当前的状态\n    std::string prop_name = \"init.svc.\" + name_;\n    property_set(prop_name, new_state);\n\n    ...\n}\n```\n\n通过分析这个函数，可以知道，系统会使用属性服务以 key-value 的形式存储服务当前的状态，其中 key 的取值为 init.svc.[service_name]，value 是服务当前的状态。因此，可以使用 adb，输入命令 `getprop | grep init.svc.`，查看设备上 service 的运行状态，以下是其中的一些输出：\n\n```\n[init.svc.adbd]: [running]\n[init.svc.alarm-hal-1-0]: [running]\n[init.svc.android.thermal-hal]: [running]\n[init.svc.apexd]: [stopped]\n[init.svc.apexd-bootstrap]: [stopped]\n[init.svc.apexd-snapshotde]: [stopped]\n[init.svc.audioserver]: [running]\n[init.svc.wifidisplayhalservice]: [running]\n[init.svc.wpa_supplicant]: [running]\n[init.svc.zygote]: [running]\n[init.svc.zygote_secondary]: [running]\n```\n\n\n\n### 2.4.4 加载启动脚本\n\n<!-- TODO: 分析函数 CreateParser -->\n\n<!-- TODO: .rc 文件的解析过程 -->\n\n<!-- TODO: 属性的变更如何触发脚本中的属性触发器？ -->\n\n<!-- TODO: /system/etc/init -->\n\n<!-- TODO: /odm/etc/init -->\n\n<!-- TODO: /vendor/etc/init -->\n\n调用 LoadBootScripts 函数加载启动脚本，函数所在文件的路径为 `system/core/init/init.cpp`。\n\n```c++\nstatic void LoadBootScripts(ActionManager& action_manager, ServiceList& service_list) {\n    Parser parser = CreateParser(action_manager, service_list);\n\n    std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\");\n    if (bootscript.empty()) {\n        // 加载 init.rc 脚本文件 [2.4.4.1]\n        parser.ParseConfig(\"/init.rc\");\n\n        // 加载 /system/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/system/etc/init\")) {\n            late_import_paths.emplace_back(\"/system/etc/init\");\n        }\n\n        // 加载 /product/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/product/etc/init\")) {\n            late_import_paths.emplace_back(\"/product/etc/init\");\n        }\n\n        // 加载 /product_services/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/product_services/etc/init\")) {\n            late_import_paths.emplace_back(\"/product_services/etc/init\");\n        }\n\n        // 加载 /odm/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/odm/etc/init\")) {\n            late_import_paths.emplace_back(\"/odm/etc/init\");\n        }\n\n        // 加载 /vendor/etc/init 目录下的所有脚本文件\n        if (!parser.ParseConfig(\"/vendor/etc/init\")) {\n            late_import_paths.emplace_back(\"/vendor/etc/init\");\n        }\n    } else {\n        parser.ParseConfig(bootscript);\n    }\n}\n```\n\n一般情况下，此函数会去加载一些指定的脚本，其中：\n\n- `init.rc` 是主要的 .rc 文件。\n- `/system/etc/init/` 包含了核心的系统项目，例如：SurfaceFlinger, MediaService, logcatd。\n- `/vendor/etc/init/` 包含了 SoC 供应商项目，例如：核心 SoC 功能所需的操作或守护进程。\n- `/odm/etc/init/` 包含了设备制造商项目，例如：运动传感器或其他外围设备所需的操作或守护进程。\n\ninit.rc 是最主要脚本文件，接下来将对这个脚本进行分析。\n\n\n\n#### 2.4.4.1 init.rc 脚本\n\n在 Android，后缀为 .rc 的文件由 Android Init Language 编写，[关于 Android Init Language 的详细说明](https://cs.android.com/android/platform/superproject/+/android-security-10.0.0_r56:system/core/init/README.md) 可以在 AOSP 上找到，路径为 `system/core/init/README.md`。\n\n在分析脚本之前，首先来了解这种语言的语法。\n\n\n\n##### 2.4.4.1.1 Android Init Language\n\nAndroid Init Language 由五大类表达式组成：`Actions`，`Commands`，`Services`，`Options`，`Imports`。\n\n其语法规则有：\n\n- 每一行都是一条语句，一条语句由多个 token 组成，token 之间以空格分开。\n- 如果一个 token 包含了空格，可以跟 c 语言类似，使用反斜杠 `\\` 作为转义字符，又或者使用双引号包裹整个 token。\n- 在行的末尾使用反斜杠 `\\`，可以将语句换行。\n- 以符号 `#` 开头的行是注释行。\n- 系统属性的值可以通过语法 `${property.name}` 获取，例如：`import /init.recovery.${ro.hardware}.rc`。\n- 一个文件可以分为多个 section，必须使用 `Actions` 或者 `Services` 来声明一个新的 section。所有的 `Commands` 和 `Options` 都是属于最近声明的那一个 section。如果在一个 section 之前声明了 `Commands` 或者 `Options` ，则声明会被忽略。\n- `Services` 的名称必须是唯一的，如果存在多个重名的 `Services` ，除了第一个以外，其他的都会被忽略，并且会输出错误日志。\n\n接下来列出一些较为重要的表达式。\n\n\n\n###### 2.4.4.1.1.1 Actions\n\n`Actions` 由 一系列 `Commands` 组成，同时 `Triggers` 决定了 `Actions` 的触发时机，其形式为：\n\n```\non <trigger> [&& <trigger>]*\n   <command>\n   <command>\n   <command>\n```\n\n当一个事件触发后，如果此事件能够匹配上 `Actions` 的  `Triggers`，那么 `Actions` 会被添加到待执行队列的尾部。\n\n之后，待执行队列中的 `Actions` 会按照加入顺序出队，并且执行该 `Actions` 中的 `Commands`。\n\n以启动 Zygote 作为示例：\n\n```\non zygote-start && property:ro.crypto.state=unencrypted\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n```\n\n简单分析这个脚本：\n\n这个 `Actions` 拥有两个 `Triggers`，分别是 `zygote-start` 和 `property:ro.crypto.state=unencrypted`，从第二行开始，每一行都是一个 `Command`。\n\n当事件 `zygote-start` 和 `property:ro.crypto.state=unencrypted` 触发后，`Actions` 会被加入到待执行队列。在执行到该 `Actions` 时，会按照 `Commands` 定义的先后顺序，依次执行 `Actions` 中的 `Commands`。\n\n\n\n###### 2.4.4.1.1.2 Triggers\n\n`Triggers` 是字符串，用于匹配某些类型的事件并触发 `Actions` 中的 `Commands`。\n\nTriggers 可以分为两类：\n\n- **Event triggers**\n\n  事件触发器，这类触发器所匹配的事件由命令 `trigger`  触发，又或者通过调用 `QueueEventTrigger()` 函数触发。\n\n- **Property triggers**\n\n  属性触发器，这类触发器所匹配的事件是：属性是否满足某个值，形式为 `property:<key>=<value>`。这里的属性就是之前提到的属性服务管理的属性。\n\n注意，每一个 `Actions` 可以有多个属性触发器，但只能有一个事件触发器。\n\n例如：\n\n`on init && property:a=b`，`on property:a=b && property:c=d` 是合法的。\n\n`on boot && on init` 是不合法的。\n\n\n\n###### 2.4.4.1.1.3 Commands\n\n下面列举一些常见的 `Commands`：\n\n- **trigger <event>**\n\n  触发一个事件。\n\n- **write <path> <content>**\n\n  按 path 打开文件，往文件中写入内容。\n\n- **chown <owner> <group> <path>**\n\n  更改文件所有者和组。\n\n- **mkdir <path> [mode] [owner] [group]**\n\n  在路径上创建一个目录，可以选择使用给定的权限，所有者，用户组。 \n\n  如果未指定权限，所有者，用户组，则新建的目录默认具有权限 755，并由 root 用户和 root 组拥有。\n\n  当指定权限，所有者，用户组时，如果目录已经存在，则权限，所有者，用户组将被更新。\n\n- **start <service>**\n\n  当指定的服务未在运行时，启动该服务。\n\n- **exec_start <service>**\n\n  启动指定的服务，在该命令返回之前暂停处理其他命令。\n\n- **setprop <name> <value>**\n\n  给系统属性赋值，这里的属性是之前提到的属性服务中的属性。\n\n- **symlink <target> <path>**\n\n  在 path 上创建一个连接到 target 的符号链接。\n\n\n\n###### 2.4.4.1.1.4 Services\n\n`Services` 是由 init 进程启动的程序，一般运行在 init 进程的一个子进程，因此 init 进程在启动一个 `Services` 时会通过 fork 的方式生成子进程。\n\n默认情况下，`Services` 退出后会重启。\n\n`Services` 的形式如下：\n\n```\nservice <name> <pathname> [ <argument> ]*\n   <option>\n   <option>\n   ...\n```\n\n以启动 Zygote 64 位进程的脚本作为示例：\n\n```\nservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server\n    class main\n    priority -20\n    user root\n    group root readproc reserved_disk\n    socket zygote stream 660 root system\n    socket usap_pool_primary stream 660 root system\n    onrestart write /sys/android_power/request_state wake\n    onrestart write /sys/power/state on\n    onrestart restart audioserver\n    onrestart restart cameraserver\n    onrestart restart media\n    onrestart restart netd\n    onrestart restart wificond\n    writepid /dev/cpuset/foreground/tasks\n```\n\n简单分析这个脚本：`zygote` 是 `Services` 的名称，`/system/bin/app_process64` 是可执行文件的路径，`-Xzygote /system/bin --zygote --start-system-server` 是启动参数，从第二行开始，每一行都是一个 `Options`。\n\n\n\n###### 2.4.4.1.1.5 Options\n\n`Options` 是 `Services` 的配置项，用于控制 init 进程运行 `Services` 的方式和时间。\n\n 下面列举一些常见的 `Options`：\n\n- **class <name> [ <name>\\* ]**\n\n  指定 `Services` 的类名。当 `Services` 所属类开启 (退出) 时，`Services` 也会开启 (退出) 。默认值为 default。\n\n- **class_start <serviceclass>**\n\n  启动所有未在运行的，类名被指定为 `serviceclass` 的 `Services`。\n\n- **priority <priority>**\n\n  设置 `Services` 进程的优先级。取值范围是 -20 ~ 19。默认值为 0。\n\n- **user <username>**\n\n  设置执行 `Services` 的用户。一般情况下，默认值为 root。\n\n- **group <groupname> [ <groupname>\\* ]**\n\n  设置执行 `Services` 的用户组。一般情况下，默认值为 root。\n\n- **socket <name> <type> <perm> [ <user> [ <group> [ <seclabel> ] ] ]**\n\n  创建一个 unix 域的 socket，命名为 `/dev/socket/<name>`，并将 socket 的文件描述符传递给创建的进程。\n\n- **onrestart**\n\n  当 `Services` 重启时执行一个 `Commands`。\n\n- **oneshot**\n\n  当 `Services` 退出后不再重启。\n\n- **writepid <file> [ <file>\\* ]**\n\n  在进程 fork 之后，将子进程的 pid 写入指定的文件。\n\n\n\n##### 2.4.4.1.2 加载 init.rc 脚本\n\n脚本文件 init.rc 负责系统的初始设置，文件的路径为 `system/core/rootdir/init.rc`。\n\n在了解到脚本的编写语法之后，可以知道脚本的内容都是由  `Actions` 和 `Services` 构成的，而在 init.rc 脚本中绝大部分都是 `Actions`。在 [2.4.4.1.1.2] 中曾经提到，调用 `QueueEventTrigger()` 函数可以触发一个事件，当事件匹配上  `Actions` 的  `Triggers`，就会开始执行该 `Actions`。 接下来回到进程启动的第二阶段，寻找事件的触发点。\n\n\n\n###### 2.4.4.1.2.1 源码中事件的触发点\n\n回到 init 进程启动的第二阶段，对应源代码 `system/core/init/init.cpp` 的 SecondStageMain 函数：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n\n    ...\n\n    ActionManager& am = ActionManager::GetInstance();\n\n    ...\n\n    // 将触发事件 early-init 的操作加入到 ActionManager\n    am.QueueEventTrigger(\"early-init\");\n\n    ...\n\n    // Trigger all the boot actions to get us started.\n    // 将触发事件 init 的操作加入到 ActionManager\n    am.QueueEventTrigger(\"init\");\n\n    ...\n\n    // Don't mount filesystems or start core system services in charger mode.\n    std::string bootmode = GetProperty(\"ro.bootmode\", \"\");\n    if (bootmode == \"charger\") {\n        // 如果当前处于充电模式, 则将触发事件 charger 的操作加入到 ActionManager\n        // 在充电模式下, 不会挂载文件系统和启动核心系统服务\n        am.QueueEventTrigger(\"charger\");\n    } else {\n        // 如果当前处于非充电模式, 则将触发事件 late-init 的操作加入到 ActionManager\n        am.QueueEventTrigger(\"late-init\");\n    }\n\n    ...\n\n    return 0;\n}\n```\n\nActionManager 会按操作加入的顺序逐一执行 [2.4.5.x]，由此可知事件的触发顺序：\n\n- 非充电模式：early-init -> init -> late-init\n- 充电模式：early-init -> init -> charger\n\n由于在充电模式下，系统可能未完全启动，接下来将选取非充电模式下的流程进行分析。\n\n\n\n###### 2.4.4.1.2.2 init.rc 脚本的执行过程\n\n<!-- TODO: trigger boot -->\n\n现在结合事件的触发顺序，分析脚本执行过程中的一些关键点：\n\n```\non early-init\n    ...\n\n    # 以 start 方式启动 ueventd\n    start ueventd\n\n    # 以 exec_start 方式运行 apexd-bootstrap, 在该命令返回之前暂停处理其他命令, 从而保证后续流程中 APEX 的可用性\n    exec_start apexd-bootstrap\n\non init\n    ...\n\n    # 以 start 方式启动基本服务\n    # 启动 servicemanager [2.4.4.1.2.3]\n    start servicemanager\n    start hwservicemanager\n    start vndservicemanager\n\n# 挂载文件和启动核心系统服务\n# 其中 trigger 用于触发一个事件 [2.4.4.1.1.2]\non late-init\n    trigger early-fs\n    trigger fs\n    trigger post-fs\n    trigger late-fs\n    trigger post-fs-data\n    trigger load_persist_props_action\n\n    # 触发事件 zygote-start, 启动 zygote [2.4.4.1.2.4]\n    trigger zygote-start\n\n    trigger firmware_mounts_complete\n    trigger early-boot\n    trigger boot\n```\n\n经过分析，现在已经大致了解脚本的执行过程，接下来分析 servicemanager 和 zygote 的启动。\n\n\n\n###### 2.4.4.1.2.3 启动 servicemanager\n\nservicemanager 启动脚本的路径为 `frameworks/native/cmds/servicemanager/servicemanager.rc`，分析这个脚本：\n\n```\n# servicemanager 是 Services 的名称\n# /system/bin/servicemanager 是可执行文件的路径\nservice servicemanager /system/bin/servicemanager\n    # 指定类名为 core 和 animation\n    # 当 core 或者 animation 开启 (关闭) 时, servicemanager 也将开启 (关闭)\n    class core animation\n\n    # 设置用户为 system\n    user system\n\n    # 设置用户组为 system 和 readproc\n    group system readproc\n\n    # 将其标记为设备的关键服务\n    # 如果此服务在规定时间内不断重启, 则设备会重启并进入 bootloader\n    critical\n\n    # 设置服务重启后执行的操作\n    # 每一个操作都是一个 Commands\n    onrestart restart healthd\n    onrestart restart zygote\n    onrestart restart audioserver\n    onrestart restart media\n    onrestart restart surfaceflinger\n    onrestart restart inputflinger\n    onrestart restart drm\n    onrestart restart cameraserver\n    onrestart restart keystore\n    onrestart restart gatekeeperd\n    onrestart restart thermalservice\n\n    # 在进程执行 fork 操作之后，将子进程的 pid 写入文件 /dev/cpuset/system-background/tasks\n    writepid /dev/cpuset/system-background/tasks\n\n    # 设置服务的关闭行为\n    # shutdown critical 表示此服务在关闭期间不会被杀死, 当关闭超时后才会被杀死\n    shutdown critical\n```\n\n启动 servicemanager 之后，便会进入 `frameworks/native/cmds/servicemanager/service_manager.c` 的 main 函数。\n\n\n\n###### 2.4.4.1.2.4 启动 zygote\n\n在 init.rc 脚本中，事件 `zygote-start` 有 3 个对应的 `Actions`：\n\n```\non zygote-start && property:ro.crypto.state=unencrypted\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n\non zygote-start && property:ro.crypto.state=unsupported\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n\non zygote-start && property:ro.crypto.state=encrypted && property:ro.crypto.type=file\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n```\n\n其中，zygote 通过以下语句导入：\n\n```\nimport /init.${ro.zygote}.rc\n```\n\n此语句会根据属性 `ro.zygote`，导入相应的文件，其中包括：\n\n```\nsystem/core/rootdir/init.zygote32.rc\nsystem/core/rootdir/init.zygote32_64.rc\nsystem/core/rootdir/init.zygote64.rc\nsystem/core/rootdir/init.zygote64_32.rc\n```\n\nzygote 的启动除了依赖事件 `zygote-start` 以外，还需要某些属性满足特定的值。当上面列出的三个 `Actions` 中的其中一个满足条件后，便会启动 zygote。\n\n这里分析启动 Zygote 64 位进程的脚本，脚本文件的路径为 `system/core/rootdir/init.zygote64.rc`：\n\n```\n# zygote 是 Services 的名称\n# /system/bin/app_process64 是可执行文件的路径\n# -Xzygote /system/bin --zygote --start-system-server 是启动参数\nservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server\n    # 指定类名为 main\n    # 当 main 开启 (关闭) 时, zygote 也将开启 (关闭)\n    class main\n\n    # 进程优先级为 -20\n    # 由于优先级的取值范围是 -20 ~ 19, 数值越小, 优先级越高, 因此 zygote 进程拥有最高的优先级\n    priority -20\n\n    # 用户和用户组都是 root\n    user root\n    group root readproc reserved_disk\n\n    # 创建 socket\n    socket zygote stream 660 root system\n    socket usap_pool_primary stream 660 root system\n\n    # 设置服务重启后执行的操作\n    # 每一个操作都是一个 Commands\n    onrestart write /sys/android_power/request_state wake\n    onrestart write /sys/power/state on\n    onrestart restart audioserver\n    onrestart restart cameraserver\n    onrestart restart media\n    onrestart restart netd\n    onrestart restart wificond\n\n    # 在 zygote 进程执行 fork 操作之后，将子进程的 pid 写入文件 /dev/cpuset/foreground/tasks\n    writepid /dev/cpuset/foreground/tasks\n```\n\n启动 zygote 之后，便会进入 `frameworks/base/cmds/app_process/app_main.cpp` 的 main 函数。\n\n\n\n### 2.4.5 进入无限循环状态\n\ninit 进程启动完成之后，进程就会一直存活，而保持存活的方法就是进入无限循环状态。接下来分析这个过程，源代码的路径为 `system/core/init/init.cpp`：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n\n    ...\n\n    while (true) {\n        // 设置等待 epoll 事件的超时时长\n        // 默认情况下会一直处于阻塞状态, 直到有事件发生, 此时 epoll_timeout 取值为 -1\n        auto epoll_timeout = std::optional<std::chrono::milliseconds>{};\n\n        ...\n\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            // am 是一个引用, 指向 ActionManager 实例\n            // 按顺序执行 ActionManager 中的一个命令 [2.4.5.1]\n            am.ExecuteOneCommand();\n        }\n        if (!(waiting_for_prop || Service::is_exec_service_running())) {\n            if (!shutting_down) {\n                // 获取下一次 HandleProcessActions 的时间点 [2.4.5.2]\n                auto next_process_action_time = HandleProcessActions();\n\n                if (next_process_action_time) {\n                    // 计算出 next_process_action_time 与当前时间的差值\n                    epoll_timeout = std::chrono::ceil<std::chrono::milliseconds>(\n                            *next_process_action_time - boot_clock::now());\n\n                    // 如果差值小于 0, 说明需要立即进行下一次的循环\n                    // 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程\n                    if (*epoll_timeout < 0ms) epoll_timeout = 0ms;\n                }\n            }\n\n            // 如果 ActionManager 中仍有待执行的命令, 那么 init 进程不会进入阻塞状态, 并立即再次唤起\n            // 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程\n            if (am.HasMoreCommands()) epoll_timeout = 0ms;\n        }\n\n        // 调用 Wait 函数, 等待事件触发 [2.4.1.3]\n        if (auto result = epoll.Wait(epoll_timeout); !result) {\n            LOG(ERROR) << result.error();\n        }\n    }\n\n    return 0;\n}\n```\n\n经分析可知，init 进程进入循环状态后主要的工作有 3 个：\n\n- 执行 ActionManager 中的命令。\n- 重启服务。\n- 等待 epoll 事件，当事件触发后，调用相应的函数进行处理。结合前面的分析，可知等待的事件有：一个进程通过请求 init 进程向属性服务写入属性，以及 init 进程接收到 `SIGCHLD` 信号。\n\n\n\n#### 2.4.5.1 ActionManager\n\n<!-- TODO: 什么是 Action? -->\n\n<!-- TODO: Action 和脚本中的 Actions 有没有关系 -->\n\n<!-- TODO: 添加和执行过程 -->\n\nActionManager 是 Action 的管理器，它提供了对 Action 的添加、执行、清空等操作。\n\n\n\n##### 2.4.5.1.1 添加 Action\n\n<!-- TODO: 详细分析 Action 的作用 -->\n\n在 init 进程启动的第二阶段中添加了一些 Action，简单看下其中部分 Action 的作用：\n\n```c++\nint SecondStageMain(int argc, char** argv) {\n    ...\n\n    // am 是一个引用, 指向 ActionManager 实例\n    ActionManager& am = ActionManager::GetInstance();\n\n    ...\n\n    am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\");\n\n    // 添加 Action: 触发事件 early-init [2.4.4.1.2.1]\n    am.QueueEventTrigger(\"early-init\");\n\n    // 添加 Action: 等待 coldboot 完成\n    am.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\");\n\n    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\");\n    am.QueueBuiltinAction(SetMmapRndBitsAction, \"SetMmapRndBits\");\n    am.QueueBuiltinAction(SetKptrRestrictAction, \"SetKptrRestrict\");\n    Keychords keychords;\n    am.QueueBuiltinAction(\n        [&epoll, &keychords](const BuiltinArguments& args) -> Result<Success> {\n            for (const auto& svc : ServiceList::GetInstance()) {\n                keychords.Register(svc->keycodes());\n            }\n            keychords.Start(&epoll, HandleKeychord);\n            return Success();\n        },\n        \"KeychordInit\");\n    am.QueueBuiltinAction(console_init_action, \"console_init\");\n\n    // 添加 Action: 触发事件 init [2.4.4.1.2.1]\n    am.QueueEventTrigger(\"init\");\n\n    am.QueueBuiltinAction(StartBoringSslSelfTest, \"StartBoringSslSelfTest\");\n    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\");\n\n    // 添加 Action: 为 init 进程初始化 binder\n    am.QueueBuiltinAction(InitBinder, \"InitBinder\");\n\n    std::string bootmode = GetProperty(\"ro.bootmode\", \"\");\n    if (bootmode == \"charger\") {\n        // 在充电模式下, 添加 Action: 触发事件 charger [2.4.4.1.2.1]\n        am.QueueEventTrigger(\"charger\");\n    } else {\n        // 否则, 添加 Action: 触发事件 late-init [2.4.4.1.2.1]\n        am.QueueEventTrigger(\"late-init\");\n    }\n\n    // 添加 Action: 触发当前所有的属性触发器\n    am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\");\n\n    ...\n\n}\n```\n\n此外，在解析脚本或者属性值改变的时候，也会使用 ActionManager 添加 Action。\n\n\n\n#### 2.4.5.2 HandleProcessActions\n\n<!-- ((s->flags() & SVC_RUNNING) && s->timeout_period()) -->\n\n<!-- 详细分析 service 的重启过程 -->\n\n```c++\nstatic std::optional<boot_clock::time_point> HandleProcessActions() {\n    std::optional<boot_clock::time_point> next_process_action_time;\n\n    // 遍历 ServiceList\n    for (const auto& s : ServiceList::GetInstance()) {\n        // 判断服务是否处于运行中状态, 以及是否有超时时长\n        if ((s->flags() & SVC_RUNNING) && s->timeout_period()) {\n            // 计算出服务启动的超时时间\n            auto timeout_time = s->time_started() + *s->timeout_period();\n\n            if (boot_clock::now() > timeout_time) {\n                // 如果当前时间已大于服务启动的超时时间, 说明服务启动已超时\n                s->Timeout();\n            } else {\n                // 更新 next_process_action_time\n                // 此时, next_process_action_time 表示最近的, 需要检查服务是否启动成功的时间点\n                if (!next_process_action_time || timeout_time < *next_process_action_time) {\n                    next_process_action_time = timeout_time;\n                }\n            }\n        }\n\n        // 如果服务不带有标志位 SVC_RESTARTING, 则不需要重启, 继续 for 循环\n        if (!(s->flags() & SVC_RESTARTING)) continue;\n\n        // 计算出服务启动的超时时间\n        auto restart_time = s->time_started() + s->restart_period();\n\n        // 现在服务需要重启, 接下来重启已满足重启条件的服务\n        if (boot_clock::now() > restart_time) {\n            // 如果当前时间已大于服务的重启时间, 那么立即启动服务\n            if (auto result = s->Start(); !result) {\n                LOG(ERROR) << \"Could not restart process '\" << s->name() << \"': \" << result.error();\n            }\n        } else {\n            // 更新 next_process_action_time\n            // 此时, next_process_action_time 表示最近的, 需要对服务进行重启操作的时间点\n            if (!next_process_action_time || restart_time < *next_process_action_time) {\n                next_process_action_time = restart_time;\n            }\n        }\n    }\n    return next_process_action_time;\n}\n```\n\n此函数的工作有：\n\n1. 检查带有标志位 `SVC_RUNNING` 的服务是否超时，如果服务启动超时，则调用 `Timeout` 函数，否则更新下次检查的时间点。\n2. 当服务带有标志位 `SVC_RESTARTING` 时，说明服务需要重启。如果当前时间已大于服务的重启时间，则立即重启服务；否则，更新下次重启的时间点。 \n\n经分析可知，`next_process_action_time` 可能表示下一次的检查服务是否启动超时的时间点，也可能表示下一次为某个服务重启的时间点。\n\n注意到，在之前的分析信号 [2.4.3.1.4.3] 提到过，当 init 收到子进程终结的信号之后，会为有重启需要的服务添加标志位 `SVC_RESTARTING`。那么现在可以知道，在 init 进程进入无限循环状态后，就会处理这些带有标志位 `SVC_RESTARTING` 的服务，重启满足条件的服务。\n\n\n\n# 参考\n\n[Android系统启动-综述](http://gityuan.com/2016/02/01/android-booting/)\n\n[Android系统启动-Init篇](http://gityuan.com/2016/02/05/android-init/)\n\n[epoll(7)](https://man7.org/linux/man-pages/man7/epoll.7.html)\n\n[Signal](https://en.wikipedia.org/wiki/Signal_(IPC))\n\n[signal(7)](https://man7.org/linux/man-pages/man7/signal.7.html)\n\n[wait(2)](https://man7.org/linux/man-pages/man2/wait.2.html)\n\n[signalfd(2)](https://man7.org/linux/man-pages/man2/signalfd.2.html)\n\n","slug":"exploring-init-process-startup-process","published":1,"updated":"2021-11-10T07:43:55.775Z","_id":"ckvt7ngc6000felprc7r9ejwx","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>本文基于源代码：android-security-10.0.0_r56</p>\n</blockquote>\n<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><!-- TODO: 关于 init 进程更好的概述 -->\n\n<p>Android 基于 Linux 内核，在内核启动过程中会创建出 init 进程。</p>\n<p>init 进程是用户空间的第一个进程，进程的 pid = 1。</p>\n<a id=\"more\"></a>\n\n\n\n<h1 id=\"2-启动流程\"><a href=\"#2-启动流程\" class=\"headerlink\" title=\"2. 启动流程\"></a>2. 启动流程</h1><!-- TODO: 总结 -->\n\n\n\n<h2 id=\"2-1-init-进程的入口\"><a href=\"#2-1-init-进程的入口\" class=\"headerlink\" title=\"2.1 init 进程的入口\"></a>2.1 init 进程的入口</h2><!-- TODO: 为什么是入口？ -->\n\n<!-- TODO: init 就是一个普通的命令行程序, 位置在 /system/core/init？ -->\n\n<p>在 Android 9，init 进程的入口位于 <code>system/core/init/init.cpp</code> 中的 main 函数。</p>\n<p>在 Android 10 之后，init 进程的入口改到了 <code>system/core/init/main.cpp</code> 中的 main 函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(basename(argv[<span class=\"number\">0</span>]), <span class=\"string\">&quot;ueventd&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ueventd_main(argc, argv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;subcontext&quot;</span>)) &#123;</span><br><span class=\"line\">            android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class=\"line\">            <span class=\"keyword\">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> SubcontextMain(argc, argv, &amp;function_map);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;selinux_setup&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SetupSelinux(argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;second_stage&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SecondStageMain(argc, argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> FirstStageMain(argc, argv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先来了解其中使用到的两个库函数：<code>basename</code> 函数和 <code>strcmp</code> 函数。</p>\n<ul>\n<li><code>basename</code> 的函数原型为 <code>char* basename(char* __path)</code>，可以根据给定的一个路径，返回文件名。例如：传入参数 “/system/bin/ueventd”，函数会返回 “ueventd”。</li>\n<li><code>strcmp</code> 的函数原型为 <code>int strcmp(const char* __lhs, const char* __rhs)</code>，是一个字符串比较函数，返回值为整数。当两个字符串相等时，函数返回 0。</li>\n</ul>\n<p>再来分析 main 函数：函数的主要工作是根据参数 <code>argc</code> 和 <code>argv</code>，选择对应的执行方式。如果参数未匹配成功，则默认调用 <code>FirstStageMain</code> 函数。</p>\n<h2 id=\"2-2-启动的第一阶段\"><a href=\"#2-2-启动的第一阶段\" class=\"headerlink\" title=\"2.2 启动的第一阶段\"></a>2.2 启动的第一阶段</h2><!-- TODO: mkdir, mknod, tmpfs -->\n\n<!-- TODO: 所挂载的文件系统的用处 -->\n\n<!-- TODO: KernelLogging(/dev/kmsg) -->\n\n<!-- TODO: InstallRebootSignalHandlers -->\n\n<p>调用 <code>int FirstStageMain(int argc, char** argv)</code> 进入启动的第一阶段，函数所在文件的路径为 <code>system/core/init/first_stage_init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FirstStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(clearenv());</span><br><span class=\"line\">    CHECKCALL(setenv(<span class=\"string\">&quot;PATH&quot;</span>, _PATH_DEFPATH, <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"comment\">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class=\"line\">    <span class=\"comment\">// on / and then we&#x27;ll let the rc file figure out the rest.</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/dev&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class=\"string\">&quot;mode=0755&quot;</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/pts&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/socket&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/dm-user&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;devpts&quot;</span>, <span class=\"string\">&quot;/dev/pts&quot;</span>, <span class=\"string\">&quot;devpts&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;proc&quot;</span>, <span class=\"string\">&quot;/proc&quot;</span>, <span class=\"string\">&quot;proc&quot;</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;hidepid=2,gid=&quot;</span> MAKE_STR(AID_READPROC)));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> MAKE_STR</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t expose the raw commandline to unprivileged processes.</span></span><br><span class=\"line\">    <span class=\"comment\">// 设置文件权限 [2.2.1]</span></span><br><span class=\"line\">    CHECKCALL(chmod(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, <span class=\"number\">0440</span>));</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> cmdline;</span><br><span class=\"line\">    android::base::ReadFileToString(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, &amp;cmdline);</span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t expose the raw bootconfig to unprivileged processes.</span></span><br><span class=\"line\">    chmod(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, <span class=\"number\">0440</span>);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootconfig;</span><br><span class=\"line\">    android::base::ReadFileToString(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, &amp;bootconfig);</span><br><span class=\"line\">    <span class=\"keyword\">gid_t</span> groups[] = &#123;AID_READPROC&#125;;</span><br><span class=\"line\">    CHECKCALL(setgroups(arraysize(groups), groups));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;sysfs&quot;</span>, <span class=\"string\">&quot;/sys&quot;</span>, <span class=\"string\">&quot;sysfs&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;selinuxfs&quot;</span>, <span class=\"string\">&quot;/sys/fs/selinux&quot;</span>, <span class=\"string\">&quot;selinuxfs&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/kmsg&quot;</span>, S_IFCHR | <span class=\"number\">0600</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">11</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">if</span> <span class=\"title\">constexpr</span> <span class=\"params\">(WORLD_WRITABLE_KMSG)</span> </span>&#123;</span><br><span class=\"line\">        CHECKCALL(mknod(<span class=\"string\">&quot;/dev/kmsg_debug&quot;</span>, S_IFCHR | <span class=\"number\">0622</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">11</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/random&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">8</span>)));</span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/urandom&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">9</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This is needed for log wrapper, which gets called before ueventd runs.</span></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/ptmx&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">5</span>, <span class=\"number\">2</span>)));</span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/null&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">3</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// These below mounts are done in first stage init so that first stage mount can mount</span></span><br><span class=\"line\">    <span class=\"comment\">// subdirectories of /mnt/&#123;vendor,product&#125;/.  Other mounts, not required by first stage mount,</span></span><br><span class=\"line\">    <span class=\"comment\">// should be done in rc files.</span></span><br><span class=\"line\">    <span class=\"comment\">// Mount staging areas for devices managed by vold</span></span><br><span class=\"line\">    <span class=\"comment\">// See storage config details at http://source.android.com/devices/storage/</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/mnt&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=1000&quot;</span>));</span><br><span class=\"line\">    <span class=\"comment\">// /mnt/vendor is used to mount vendor-specific partitions that can not be</span></span><br><span class=\"line\">    <span class=\"comment\">// part of the vendor partition, e.g. because they are mounted read-write.</span></span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/mnt/vendor&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    <span class=\"comment\">// /mnt/product is used to mount product-specific partitions that can not be</span></span><br><span class=\"line\">    <span class=\"comment\">// part of the product partition, e.g. because they are mounted read-write.</span></span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/mnt/product&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /debug_ramdisk is used to preserve additional files from the debug ramdisk</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/debug_ramdisk&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=0&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /second_stage_resources is used to preserve files from first to second</span></span><br><span class=\"line\">    <span class=\"comment\">// stage init</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, kSecondStageRes, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=0&quot;</span>))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> CHECKCALL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    SetStdioToDevNull(argv);</span><br><span class=\"line\">    <span class=\"comment\">// Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually</span></span><br><span class=\"line\">    <span class=\"comment\">// talk to the outside world...</span></span><br><span class=\"line\">    InitKernelLogging(argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!errors.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; [error_string, error_errno] : errors) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; error_string &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; strerror(error_errno);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;Init encountered errors starting first stage, aborting&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG(INFO) &lt;&lt; <span class=\"string\">&quot;init first stage started!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 /system/bin/init</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到传入的参数是 selinux_setup, 因此接下来会调用 SetupSelinux 函数进行 SELinux 的初始化 [2.3]</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;selinux_setup&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> fd = open(<span class=\"string\">&quot;/dev/kmsg&quot;</span>, O_WRONLY | O_CLOEXEC);</span><br><span class=\"line\">    dup2(fd, STDOUT_FILENO);</span><br><span class=\"line\">    dup2(fd, STDERR_FILENO);</span><br><span class=\"line\">    close(fd);</span><br><span class=\"line\">    execv(path, <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">char</span>**&gt;(args));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// execv() only returns if an error happened, in which case we</span></span><br><span class=\"line\">    <span class=\"comment\">// panic and never fall through this conditional.</span></span><br><span class=\"line\">    PLOG(FATAL) &lt;&lt; <span class=\"string\">&quot;execv(\\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class=\"string\">&quot;\\&quot;) failed&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数主要工作是挂载一些文件系统，然后执行 <code>/system/bin/init</code>，重新进入 main 函数，通过传入参数 <code>&quot;selinux_setup&quot;</code>，进而调用 SetupSelinux 函数，进行 SELinux 的初始化。</p>\n<h3 id=\"2-2-1-设置文件或目录的权限\"><a href=\"#2-2-1-设置文件或目录的权限\" class=\"headerlink\" title=\"2.2.1 设置文件或目录的权限\"></a>2.2.1 设置文件或目录的权限</h3><p>在 Linux 系统上，<code>chmod</code> 命令用于控制用户对文件或者目录的权限，但只有文件所有者和超级用户可以修改文件或目录的权限。</p>\n<p>权限分为三类：读，写，执行。</p>\n<h4 id=\"2-2-1-1-符号表示法\"><a href=\"#2-2-1-1-符号表示法\" class=\"headerlink\" title=\"2.2.1.1 符号表示法\"></a>2.2.1.1 符号表示法</h4><p>符号表示法用 10 位字符表示权限，其形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rwxrwxrwx</span><br></pre></td></tr></table></figure>\n<p>其中第一个字符表示文件类型，常见的符号有：</p>\n<ul>\n<li><code>-</code>，表示普通文件。</li>\n<li><code>d</code>，表示目录。</li>\n<li><code>c</code>，表示字符特殊文件。</li>\n</ul>\n<p>剩余的 9 个字符，每 3 个字符分为一组，分别表示文件所有者，用户组，其他用户的权限。</p>\n<p>3 个字符组成的字符串，第 1 位控制读权限，第 2 位控制写权限，第 3 位控制执行权限：</p>\n<ul>\n<li>如果拥有读权限，第 1 位字符为 <code>r</code>，否则为 <code>-</code>。</li>\n<li>如果拥有写权限，第 2 位字符为 <code>w</code>，否则为 <code>-</code>。</li>\n<li>如果拥有执行权限，第 3 位字符为 <code>x</code>，否则为 <code>-</code>。</li>\n</ul>\n<p>示例：<code>-rwxrw-r--</code> 表示一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。</p>\n<h4 id=\"2-2-1-2-数字表示法\"><a href=\"#2-2-1-2-数字表示法\" class=\"headerlink\" title=\"2.2.1.2 数字表示法\"></a>2.2.1.2 数字表示法</h4><p>可以用 4 位八进制数字表示权限，第 1 位同样表示文件类型，剩余的 3 位数字，分别表示文件所有者，用户组，其他用户的权限。</p>\n<p>读，写，执行，这 3 类权限可以使用 3 位二进制数字表示，不同类型的权限单独对应二进制数字中一个位：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数值</th>\n<th align=\"center\">权限</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">二进制：100，八进制：4</td>\n<td align=\"center\">r</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：010，八进制：2</td>\n<td align=\"center\">w</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：001，八进制：1</td>\n<td align=\"center\">x</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：000，八进制：0</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p>在各类权限对应的数值之和，可以代表一组特定的权限。由于和的数值范围为 0~7，因此可以通过一个八进制数字表示。示例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数值</th>\n<th align=\"center\">权限</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">二进制：111，八进制：7</td>\n<td align=\"center\">rwx</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：110，八进制：6</td>\n<td align=\"center\">rw-</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：101，八进制：5</td>\n<td align=\"center\">r-x</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：000，八进制：0</td>\n<td align=\"center\">—</td>\n</tr>\n</tbody></table>\n<p>因此，用符号表示法表示的权限，同样可以使用数字表示法来表示，示例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号表示法</th>\n<th align=\"center\">数字表示法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-rwxrwxrwx</td>\n<td align=\"center\">0777</td>\n<td align=\"center\">一个普通文件，文件所有者，用户组，其他用户都有读，写，执行的权限</td>\n</tr>\n<tr>\n<td align=\"center\">-rwxrw-r–</td>\n<td align=\"center\">0764</td>\n<td align=\"center\">一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-2-1-3-分析源码中的权限设置\"><a href=\"#2-2-1-3-分析源码中的权限设置\" class=\"headerlink\" title=\"2.2.1.3 分析源码中的权限设置\"></a>2.2.1.3 分析源码中的权限设置</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Don&#x27;t expose the raw commandline to unprivileged processes.</span></span><br><span class=\"line\">CHECKCALL(chmod(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, <span class=\"number\">0440</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Don&#x27;t expose the raw bootconfig to unprivileged processes.</span></span><br><span class=\"line\">chmod(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, <span class=\"number\">0440</span>);</span><br></pre></td></tr></table></figure>\n<p>在源码中有两处使用到 <code>chmod</code> 命令，分别对文件 <code>/proc/cmdline</code>，<code>/proc/bootconfig</code> 设置了权限 <code>0440</code>，表明 root 用户 (文件所有者) 及其用户组也只有文件的读权限。</p>\n<h2 id=\"2-3-初始化-SELinux\"><a href=\"#2-3-初始化-SELinux\" class=\"headerlink\" title=\"2.3 初始化 SELinux\"></a>2.3 初始化 SELinux</h2><!-- TODO: 分析 SELinux -->\n\n<p>调用 <code>int SetupSelinux(char** argv)</code> 进行 SELinux 的初始化，该函数所在文件的路径为 <code>system/core/init/selinux.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This function initializes SELinux then execs init to run in the init SELinux context.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SetupSelinux</span><span class=\"params\">(<span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set up SELinux, loading the SELinux policy.</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 SELinux</span></span><br><span class=\"line\">    SelinuxSetupKernelLogging();</span><br><span class=\"line\">    SelinuxInitialize();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 /system/bin/init</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到传入的参数是 second_stage, 因此接下来会调用 SecondStageMain 函数进入启动的第二阶段 [2.4]</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;second_stage&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    execv(path, <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">char</span>**&gt;(args));</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数首先初始化了 SELinux，然后执行 <code>/system/bin/init</code>，重新进入 main 函数，通过传入参数 <code>&quot;second_stage&quot;</code>，进而调用 SecondStageMain 函数，进入启动的第二阶段。</p>\n<h2 id=\"2-4-启动的第二阶段\"><a href=\"#2-4-启动的第二阶段\" class=\"headerlink\" title=\"2.4 启动的第二阶段\"></a>2.4 启动的第二阶段</h2><!-- TODO: property_load_boot_defaults -->\n\n<!-- TODO: 在编译的过程中, android 的各种系统参数会被汇总到 build.prop 文件中？ -->\n\n<!-- TODO: SELinux 相关代码的分析 -->\n\n<!-- TODO: keyctl_get_keyring_ID(KEY_SPEC_SESSION_KEYRING, 1) -->\n\n<!-- TODO: InitializeSubcontext() -->\n\n<!-- TODO: ActionManager 和 ServiceList 的作用 -->\n\n<p>调用 <code>int SecondStageMain(int argc, char** argv)</code> 进入启动的第二阶段，函数所在文件的路径为 <code>system/core/init/init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set init and its forked children&#x27;s oom_adj.</span></span><br><span class=\"line\">    <span class=\"comment\">// 设置 init 进程以及由其 fork 得到的子进程 oom_score_adj 的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 数值越小, 进程优先级越高</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = WriteFile(<span class=\"string\">&quot;/proc/1/oom_score_adj&quot;</span>, <span class=\"string\">&quot;-1000&quot;</span>); !result) &#123;</span><br><span class=\"line\">        LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Unable to write -1000 to /proc/1/oom_score_adj: &quot;</span> &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化属性服务 [2.4.2.1]</span></span><br><span class=\"line\">    property_init();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 epoll [2.4.1.1]</span></span><br><span class=\"line\">    Epoll epoll;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Open(); !result) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用 epoll 对 init 子进程的信号进行监听 [2.4.3.1.3]</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化子进程退出的信号处理函数</span></span><br><span class=\"line\">    InstallSignalFdHandler(&amp;epoll);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 开启属性服务 [2.4.2.2]</span></span><br><span class=\"line\">    StartPropertyService(&amp;epoll);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class=\"line\">    ServiceList&amp; sm = ServiceList::GetInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 加载启动脚本 [2.4.4]</span></span><br><span class=\"line\">    LoadBootScripts(am, sm);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action [2.4.5.1]</span></span><br><span class=\"line\">    am.QueueBuiltinAction(SetupCgroupsAction, <span class=\"string\">&quot;SetupCgroups&quot;</span>);</span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;early-init&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class=\"string\">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    am.QueueBuiltinAction(queue_property_triggers_action, <span class=\"string\">&quot;queue_property_triggers&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进入无限循环状态 [2.4.5]</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> epoll_timeout = <span class=\"built_in\">std</span>::optional&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (do_shutdown &amp;&amp; !shutting_down) &#123;</span><br><span class=\"line\">            do_shutdown = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (HandlePowerctlMessage(shutdown_command)) &#123;</span><br><span class=\"line\">                shutting_down = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            am.ExecuteOneCommand();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!shutting_down) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> next_process_action_time = HandleProcessActions();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next_process_action_time) &#123;</span><br><span class=\"line\">                    epoll_timeout = <span class=\"built_in\">std</span>::chrono::<span class=\"built_in\">ceil</span>&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;(</span><br><span class=\"line\">                            *next_process_action_time - boot_clock::now());</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (*epoll_timeout &lt; <span class=\"number\">0</span>ms) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (am.HasMoreCommands()) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Wait(epoll_timeout); !result) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; result.error();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二阶段的工作可以大致分为 5 个部分：</p>\n<ul>\n<li><p>epoll</p>\n</li>\n<li><p>属性服务</p>\n</li>\n<li><p>信号</p>\n</li>\n<li><p>加载启动脚本</p>\n</li>\n<li><p>进入无限循环状态</p>\n</li>\n</ul>\n<p>接下来将分别对这 5 个部分的工作进行分析。</p>\n<h3 id=\"2-4-1-epoll\"><a href=\"#2-4-1-epoll\" class=\"headerlink\" title=\"2.4.1 epoll\"></a>2.4.1 epoll</h3><p>epoll 是 Linux 提供的 I/O 事件通知机制。epoll 可以监听大量的文件描述符，检查其中某一个文件描述符是否进入就绪状态。</p>\n<h4 id=\"2-4-1-1-初始化\"><a href=\"#2-4-1-1-初始化\" class=\"headerlink\" title=\"2.4.1.1 初始化\"></a>2.4.1.1 初始化</h4><p>在 init 进程中，epoll 通过以下代码初始化：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Epoll epoll;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Open(); !result) &#123;</span><br><span class=\"line\">    PLOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以知道，epoll 实例是通过调用 Open 函数创建的，函数所在文件的路径为 <code>system/core/init/epoll.cpp</code>，来分析这个函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::Open</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_fd_ &gt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关键点</span></span><br><span class=\"line\">    epoll_fd_.reset(epoll_create1(EPOLL_CLOEXEC));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_fd_ == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ErrnoError() &lt;&lt; <span class=\"string\">&quot;epoll_create1 failed&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数的关键点在于调用 <code>epoll_create1</code>。<code>epoll_create1</code> 是一个系统调用，其新建了一个 epoll 实例并返回该实例文件描述符。</p>\n<h4 id=\"2-4-1-2-使用-epoll-监听文件描述符\"><a href=\"#2-4-1-2-使用-epoll-监听文件描述符\" class=\"headerlink\" title=\"2.4.1.2 使用 epoll 监听文件描述符\"></a>2.4.1.2 使用 epoll 监听文件描述符</h4><p>要使用 epoll 监听文件描述符，需要调用 RegisterHandler 函数，将文件描述符注册到 epoll。</p>\n<p>函数所在文件的路径为 <code>system/core/init/epoll.cpp</code>，此函数的关键点在于系统调用 epoll_ctl：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::RegisterHandler</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; handler, <span class=\"keyword\">uint32_t</span> events)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关键点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &amp;ev) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先来看下 epoll_ctl 这个系统调用。</p>\n<h5 id=\"2-4-1-2-1-系统调用-epoll-ctl\"><a href=\"#2-4-1-2-1-系统调用-epoll-ctl\" class=\"headerlink\" title=\"2.4.1.2.1 系统调用 epoll_ctl\"></a>2.4.1.2.1 系统调用 epoll_ctl</h5><p><strong>epoll_ctl</strong> 是一个系统调用，函数原型为 <code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code>，用于对指定的文件描述符 fd 进行添加、修改或者删除操作。</p>\n<h6 id=\"2-4-1-2-1-1-参数\"><a href=\"#2-4-1-2-1-1-参数\" class=\"headerlink\" title=\"2.4.1.2.1.1 参数\"></a>2.4.1.2.1.1 参数</h6><p>首先来理解 epoll_ctl 的参数：</p>\n<ul>\n<li><p><strong>epfd</strong> 是 epoll 实例的文件描述符。</p>\n</li>\n<li><p><strong>op</strong> 表示要执行的操作，有三种取值：</p>\n<ul>\n<li><p><strong>EPOLL_CTL_ADD</strong></p>\n<p>添加指定的文件描述符到 epoll 的监控列表。</p>\n</li>\n<li><p><strong>EPOLL_CTL_MOD</strong></p>\n<p>修改 epoll 的监控列表中指定的文件描述符。</p>\n</li>\n<li><p><strong>EPOLL_CTL_DEL</strong></p>\n<p>从 epoll 的监控列表中删除指定的文件描述符。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>fd</strong> 表示指定的文件描述符。</p>\n</li>\n<li><p><strong>event</strong> 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，其定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">uint32_t</span>     events;      <span class=\"comment\">/* Epoll events */</span></span><br><span class=\"line\">   <span class=\"keyword\">epoll_data_t</span> data;        <span class=\"comment\">/* User data variable */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>结构体成员 <code>events</code> 用于表示要监听的事件，可以由零个或者多个事件类型组成，下面列出部分常见的事件类型：</p>\n<ul>\n<li><p>\u0015\u0015<strong>EPOLLIN</strong><br>表示关联的文件描述符可用于读操作。</p>\n</li>\n<li><p><strong>EPOLLOUT</strong><br>表示关联的文件描述符可用于写操作。</p>\n</li>\n<li><p><strong>EPOLLPRI</strong><br>表示关联的文件描述符出现异常情况。</p>\n</li>\n<li><p><strong>EPOLLERR</strong><br>表示关联的文件描述符出现错误。</p>\n</li>\n<li><p><strong>EPOLLHUP</strong><br>表示关联的文件描述符被挂断。</p>\n</li>\n<li><p><strong>EPOLLONESHOT</strong><br>表示只监听文件描述符的一次事件。当事件触发之后，epoll 就会禁用此文件描述符。<br>如果想要继续监听该文件描述符的事件，需要再次调用 epoll_ctl，并执行 EPOLL_CTL_MOD 操作。</p>\n</li>\n</ul>\n<p>结构体成员 <code>data</code> 的作用是将其数据交给内核保存，当文件描述符就绪后，内核会返回保存的数据 [2.4.1.3]。<code>epoll_data_t</code> 是一个共用体，其定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">epoll_data</span> &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span>        *ptr;</span><br><span class=\"line\">   <span class=\"keyword\">int</span>          fd;</span><br><span class=\"line\">   <span class=\"keyword\">uint32_t</span>     u32;</span><br><span class=\"line\">   <span class=\"keyword\">uint64_t</span>     u64;</span><br><span class=\"line\">&#125; <span class=\"keyword\">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h6 id=\"2-4-1-2-1-2-返回值\"><a href=\"#2-4-1-2-1-2-返回值\" class=\"headerlink\" title=\"2.4.1.2.1.2 返回值\"></a>2.4.1.2.1.2 返回值</h6><p>最后来了解 epoll_ctl 的返回值：</p>\n<ul>\n<li><p>当操作成功时，返回值为 0。</p>\n</li>\n<li><p>当发生错误时，返回值为 -1。</p>\n</li>\n</ul>\n<h5 id=\"2-4-1-2-2-分析-RegisterHandler-函数\"><a href=\"#2-4-1-2-2-分析-RegisterHandler-函数\" class=\"headerlink\" title=\"2.4.1.2.2 分析 RegisterHandler 函数\"></a>2.4.1.2.2 分析 RegisterHandler 函数</h5><p>在了解过系统调用 epoll_ctl 以后，现在开始分析 RegisterHandler 函数。首先来看函数在头文件中的声明，头文件的路径为 <code>system/core/init/epoll.h</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Epoll</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Result&lt;Success&gt; <span class=\"title\">RegisterHandler</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; handler,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                    <span class=\"keyword\">uint32_t</span> events = EPOLLIN)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>由函数原型可知，函数的第三个参数 <code>events</code> 有默认值 <code>EPOLLIN</code>，表示监听文件描述符的读操作是否可用。</p>\n<p>接下来分析 RegisterHandler 函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::RegisterHandler</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; handler, <span class=\"keyword\">uint32_t</span> events)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// handler 是事件触发时的回调函数</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> [it, inserted] = epoll_handlers_.emplace(fd, <span class=\"built_in\">std</span>::move(handler));</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    epoll_event ev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置要监听的事件类型</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于 events 有默认值 EPOLLIN, 因此默认监听的事件类型是读操作是否可用</span></span><br><span class=\"line\">    ev.events = events;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 设置回调函数, 回调函数会在事件触发后被调用 [2.4.1.3.2]</span></span><br><span class=\"line\">    ev.data.ptr = <span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"keyword\">void</span>*&gt;(&amp;it-&gt;second);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发起 epoll_ctl 系统调用</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到第二个参数传入的是 EPOLL_CTL_ADD, 因此对指定文件描述符执行的是添加操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &amp;ev) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        Result&lt;Success&gt; result = ErrnoError() &lt;&lt; <span class=\"string\">&quot;epoll_ctl failed to add fd&quot;</span>;</span><br><span class=\"line\">        epoll_handlers_.erase(fd);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过分析，可以知道函数的主要工作是：设置文件描述符需要监听的事件类型 <code>events</code> 以及事件触发时的回调函数 <code>handler</code>，最后发起 <code>epoll_ctl</code> 系统调用，将文件描述符添加到 epoll 监控列表。</p>\n<h4 id=\"2-4-1-3-等待事件触发\"><a href=\"#2-4-1-3-等待事件触发\" class=\"headerlink\" title=\"2.4.1.3 等待事件触发\"></a>2.4.1.3 等待事件触发</h4><p>经过 epoll 的初始化以及将文件描述符注册到 epoll 之后，接下来就需要等待事件触发，然后处理事件。</p>\n<p>在 init 进程启动的第二阶段，最后一个步骤就是进入死循环，不断地等待事件触发。接下来看下这段逻辑：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 关键点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Wait(epoll_timeout); !result) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; result.error();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段逻辑的关键点在于 Wait 函数，接下来分析这个函数。</p>\n<h5 id=\"2-4-1-3-1-系统调用-epoll-wait\"><a href=\"#2-4-1-3-1-系统调用-epoll-wait\" class=\"headerlink\" title=\"2.4.1.3.1 系统调用 epoll_wait\"></a>2.4.1.3.1 系统调用 epoll_wait</h5><p>在分析 Wait 函数之前，首先要了解系统调用 epoll_wait，这个系统调用是 Wait 函数的关键点。</p>\n<p><strong>epoll_wait</strong> 是一个系统调用，函数原型为 <code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code>，用于等待 epoll 上的事件。</p>\n<p>调用 epoll_wait 便会进入阻塞状态，直至满足以下任一条件，调用才会返回：</p>\n<ul>\n<li>监听的文件描述符传递一个事件；</li>\n<li>调用被信号处理程序中断；</li>\n<li>等待超出超时时长。</li>\n</ul>\n<h6 id=\"2-4-1-3-1-1-参数\"><a href=\"#2-4-1-3-1-1-参数\" class=\"headerlink\" title=\"2.4.1.3.1.1 参数\"></a>2.4.1.3.1.1 参数</h6><p>首先来理解 epoll_wait 的参数：</p>\n<ul>\n<li><p><strong>epfd</strong> 是 epoll 实例的文件描述符。</p>\n</li>\n<li><p><strong>events</strong> 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，在 [2.4.1.2.1] 一节已经详细介绍过。</p>\n<p>当事件触发后，调用就会返回，此时可以从 events 中得到已触发事件的集合。集合中每一个事件结构体 epoll_event 的 data 字段和调用 epoll_ctl 为相应的文件描述符设置的 data 字段是相同的。意味着，当事件触发后，之前调用 epoll_ctl 给指定文件描述符设置的 event.data 会通过这个参数返回给 epoll_wait 的调用者。</p>\n</li>\n<li><p><strong>maxevents</strong> 表示在一次调用中返回事件的最大数量。因此，从参数 events 中得到的事件数量不会大于 maxevents。</p>\n</li>\n<li><p><strong>timeout</strong> 是此次调用的超时时长。当 timeout = -1 时，调用将会一直阻塞，直到有事件发生；当 timeout = 0 时，调用会立即返回，即使当前没有事件发生。</p>\n</li>\n</ul>\n<h6 id=\"2-4-1-3-1-2-返回值\"><a href=\"#2-4-1-3-1-2-返回值\" class=\"headerlink\" title=\"2.4.1.3.1.2 返回值\"></a>2.4.1.3.1.2 返回值</h6><p>最后来了解 epoll_wait 的返回值：</p>\n<ul>\n<li><p>当调用成功时，返回值为已就绪的文件描述符的数量，此时可以对这些文件描述符进行 I/O 操作。</p>\n<p>需要注意的是，如果该调用是因为超出等待时长而返回的，则返回值为 0，表明没有已就绪的文件描述符。</p>\n</li>\n<li><p>当调用失败时，返回值为 -1，并返回错误信息。</p>\n</li>\n</ul>\n<h5 id=\"2-4-1-3-2-分析-Wait-函数\"><a href=\"#2-4-1-3-2-分析-Wait-函数\" class=\"headerlink\" title=\"2.4.1.3.2 分析 Wait 函数\"></a>2.4.1.3.2 分析 Wait 函数</h5><p>在了解过系统调用 epoll_wait 以后，就可以开始分析 Wait 函数，函数所在文件的路径为 <code>system/core/init/epoll.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::Wait</span><span class=\"params\">(<span class=\"built_in\">std</span>::optional&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt; timeout)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 超时时长默认值为 -1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> timeout_ms = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeout &amp;&amp; timeout-&gt;count() &lt; INT_MAX) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当参数 timeout 满足不等于 0 和数值没有溢出时, 更新超时时长</span></span><br><span class=\"line\">        timeout_ms = timeout-&gt;count();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    epoll_event ev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发起 epoll_wait 系统调用</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到第三个参数传入的是 1, 表明每次调用最多返回 1 个事件</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd_, &amp;ev, <span class=\"number\">1</span>, timeout_ms));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nr == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用返回 -1, 表明此次调用失败</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ErrnoError() &lt;&lt; <span class=\"string\">&quot;epoll_wait failed&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nr == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用返回 1, 表明此次调用成功, 有 1 个事件触发</span></span><br><span class=\"line\">        <span class=\"comment\">// ev.data.ptr 是之前调用 epoll_ctl 给指定文件描述符设置的回调函数, 因此事件最后交给回调函数进行处理</span></span><br><span class=\"line\">        <span class=\"built_in\">std</span>::invoke(*<span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt;*&gt;(ev.data.ptr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数设置了超时时长，然后发起 <code>epoll_wait</code> 系统调用，等待事件触发。当 <code>epoll_wait</code> 成功返回时，会从返回的数据里面取出之前通过 epoll_ctl 设置的回调函数，将事件交由回调函数处理。</p>\n<h3 id=\"2-4-2-属性服务\"><a href=\"#2-4-2-属性服务\" class=\"headerlink\" title=\"2.4.2 属性服务\"></a>2.4.2 属性服务</h3><p>属性服务是 Android 提供的一个用于存取系统属性的服务，属性以 key-value 的形式存储在一块共享内存，所有进程都可以通过这个服务获取和设置属性。</p>\n<p>使用 adb，输入命令 <code>getprop</code>，可以查看一台设备上的属性，下面列举其中的一些输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ro.product.brand]: [Redmi]</span><br><span class=\"line\">[ro.product.manufacturer]: [Xiaomi]</span><br><span class=\"line\">[ro.product.marketname]: [Redmi K30S Ultra]</span><br><span class=\"line\">[ro.product.model]: [M2007J3SC]</span><br><span class=\"line\">[ro.product.name]: [apollo]</span><br><span class=\"line\"></span><br><span class=\"line\">[ro.product.cpu.abi]: [arm64-v8a]</span><br><span class=\"line\">[ro.product.cpu.abilist]: [arm64-v8a,armeabi-v7a,armeabi]</span><br><span class=\"line\">[ro.product.cpu.abilist32]: [armeabi-v7a,armeabi]</span><br><span class=\"line\">[ro.product.cpu.abilist64]: [arm64-v8a]</span><br><span class=\"line\"></span><br><span class=\"line\">[dalvik.vm.heapsize]: [512m]</span><br><span class=\"line\">[dalvik.vm.heapstartsize]: [8m]</span><br></pre></td></tr></table></figure>\n<p>通过列举出的数据，可以看出属性里面包含了很多重要的信息：机型信息，CPU 架构，虚拟机分配的内存大小等等。</p>\n<p>在 Java 代码中，可以调用 <code>SystemProperties.get(String, String)</code> 方法获取系统属性。例如，在 ActivityManager 中就有这样的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">staticGetLargeMemoryClass</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过获取系统属性 dalvik.vm.heapsize, 得出应用可用堆内存的最大值</span></span><br><span class=\"line\">    String vmHeapSize = SystemProperties.get(<span class=\"string\">&quot;dalvik.vm.heapsize&quot;</span>, <span class=\"string\">&quot;16m&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.parseInt(vmHeapSize.substring(<span class=\"number\">0</span>, vmHeapSize.length() - <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似地，调用 <code>SystemProperties.set(String, String)</code> 方法可以设置系统属性。例如，在 ActivityManagerService 中就有这样的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">finishBooting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Tell anyone interested that we are done booting!</span></span><br><span class=\"line\">        <span class=\"comment\">// 通过设置属性 sys.boot_completed = 1, 标记系统已经启动完成</span></span><br><span class=\"line\">        SystemProperties.set(<span class=\"string\">&quot;sys.boot_completed&quot;</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"2-4-2-1-初始化\"><a href=\"#2-4-2-1-初始化\" class=\"headerlink\" title=\"2.4.2.1 初始化\"></a>2.4.2.1 初始化</h4><!-- TODO: 如何创建内存区域？ -->\n\n<!-- TODO: 进程是怎样获取共享内存中的属性？ -->\n\n<!-- TODO: 进程为什么不能直接设置共享内存中的属性？ -->\n\n<!-- TODO: CreateSerializedPropertyInfo() -->\n\n<!-- TODO: property_info_area.LoadDefaultPath() -->\n\n<p>属性服务初始化时，调用的是 property_init 函数，文件路径为 <code>system/core/init/property_service.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">property_init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mkdir(<span class=\"string\">&quot;/dev/__properties__&quot;</span>, S_IRWXU | S_IXGRP | S_IXOTH);</span><br><span class=\"line\">    CreateSerializedPropertyInfo();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建内存区域</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__system_property_area_init()) &#123;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;Failed to initialize property area&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!property_info_area.LoadDefaultPath()) &#123;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;Failed to load serialized property info file&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数最主要的工作是通过调用 <code>__system_property_area_init</code> 函数，创建用于存储属性的内存区域。</p>\n<h4 id=\"2-4-2-2-启动\"><a href=\"#2-4-2-2-启动\" class=\"headerlink\" title=\"2.4.2.2 启动\"></a>2.4.2.2 启动</h4><!-- TODO: socket 的创建过程 -->\n\n<!-- TODO: listen(property_set_fd, 8) -->\n\n<!-- TODO: 一个进程是怎样向 init 进程发起属性设置的请求？ -->\n\n<p>属性服务启动时，调用的是 StartPropertyService 函数，文件路径为 <code>system/core/init/property_service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StartPropertyService</span><span class=\"params\">(Epoll* epoll)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建 socket 并返回其文件描述符, 其中 PROP_SERVICE_NAME = &quot;property_service&quot;</span></span><br><span class=\"line\">    property_set_fd = CreateSocket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,</span><br><span class=\"line\">                                   <span class=\"literal\">false</span>, <span class=\"number\">0666</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (property_set_fd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; <span class=\"string\">&quot;start_property_service socket creation failed&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listen(property_set_fd, <span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将 socket 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]</span></span><br><span class=\"line\">    <span class=\"comment\">// handle_property_set_fd 是可读事件触发时的回调函数 [2.4.2.3]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll-&gt;RegisterHandler(property_set_fd, handle_property_set_fd); !result) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数首先创建名称为 property_service 的 socket，然后将 socket 文件描述符注册到 epoll，监听其可读事件。</p>\n<p>当可读事件触发时，会进入回调函数 <code>handle_property_set_fd</code>，接着来分析这个回调函数。</p>\n<h4 id=\"2-4-2-3-回调函数-handle-property-set-fd\"><a href=\"#2-4-2-3-回调函数-handle-property-set-fd\" class=\"headerlink\" title=\"2.4.2.3 回调函数 handle_property_set_fd\"></a>2.4.2.3 回调函数 handle_property_set_fd</h4><!-- TODO: ucred cr; socklen_t cr_size = sizeof(cr); -->\n\n<!-- TODO: 设置属性的具体实现 -->\n\n<!-- TODO: 除了通过向 init 进程发出请求设置属性以外, 在其他地方是否也有属性的设置？ -->\n\n<!-- TODO: 属性的同步问题 -->\n\n<p>函数所在文件的路径为 <code>system/core/init/property_service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handle_property_set_fd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2000ms</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">constexpr</span> <span class=\"keyword\">uint32_t</span> kDefaultSocketTimeout = <span class=\"number\">2000</span>; <span class=\"comment\">/* ms */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">SocketConnection <span class=\"title\">socket</span><span class=\"params\">(s, cr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置 2000ms 的超时时长</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> timeout_ms = kDefaultSocketTimeout;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> cmd = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!socket.RecvUint32(&amp;cmd, &amp;timeout_ms)) &#123;</span><br><span class=\"line\">        PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop: error while reading command from the socket&quot;</span>;</span><br><span class=\"line\">        socket.SendUint32(PROP_ERROR_READ_CMD);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (cmd) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理 PROP_MSG_SETPROP 命令</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> PROP_MSG_SETPROP: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// PROP_NAME_MAX = 32</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> prop_name[PROP_NAME_MAX];</span><br><span class=\"line\">        <span class=\"keyword\">char</span> prop_value[PROP_VALUE_MAX];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收属性名和属性值, 分别存储于字符数组 prop_name 和 prop_value 中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!socket.RecvChars(prop_name, PROP_NAME_MAX, &amp;timeout_ms) ||</span><br><span class=\"line\">            !socket.RecvChars(prop_value, PROP_VALUE_MAX, &amp;timeout_ms)) &#123;</span><br><span class=\"line\">          PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop(PROP_MSG_SETPROP): error while reading name/value from the socket&quot;</span>;</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将字符数组中最后的一个元素设置为 0</span></span><br><span class=\"line\">        prop_name[PROP_NAME_MAX<span class=\"number\">-1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        prop_value[PROP_VALUE_MAX<span class=\"number\">-1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; cr = socket.cred();</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> error;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置属性</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> result =</span><br><span class=\"line\">            HandlePropertySet(prop_name, prop_value, socket.source_context(), cr, &amp;error);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != PROP_SUCCESS) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Unable to set property &#x27;&quot;</span> &lt;&lt; prop_name &lt;&lt; <span class=\"string\">&quot;&#x27; to &#x27;&quot;</span> &lt;&lt; prop_value</span><br><span class=\"line\">                       &lt;&lt; <span class=\"string\">&quot;&#x27; from uid:&quot;</span> &lt;&lt; cr.uid &lt;&lt; <span class=\"string\">&quot; gid:&quot;</span> &lt;&lt; cr.gid &lt;&lt; <span class=\"string\">&quot; pid:&quot;</span> &lt;&lt; cr.pid &lt;&lt; <span class=\"string\">&quot;: &quot;</span></span><br><span class=\"line\">                       &lt;&lt; error;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 处理 PROP_MSG_SETPROP2 命令</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> PROP_MSG_SETPROP2: &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收字符串类型的属性名和属性值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!socket.RecvString(&amp;name, &amp;timeout_ms) ||</span><br><span class=\"line\">            !socket.RecvString(&amp;value, &amp;timeout_ms)) &#123;</span><br><span class=\"line\">          PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop(PROP_MSG_SETPROP2): error while reading name/value from the socket&quot;</span>;</span><br><span class=\"line\">          socket.SendUint32(PROP_ERROR_READ_DATA);</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; cr = socket.cred();</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> error;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置属性</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> result = HandlePropertySet(name, value, socket.source_context(), cr, &amp;error);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != PROP_SUCCESS) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Unable to set property &#x27;&quot;</span> &lt;&lt; name &lt;&lt; <span class=\"string\">&quot;&#x27; to &#x27;&quot;</span> &lt;&lt; value</span><br><span class=\"line\">                       &lt;&lt; <span class=\"string\">&quot;&#x27; from uid:&quot;</span> &lt;&lt; cr.uid &lt;&lt; <span class=\"string\">&quot; gid:&quot;</span> &lt;&lt; cr.gid &lt;&lt; <span class=\"string\">&quot; pid:&quot;</span> &lt;&lt; cr.pid &lt;&lt; <span class=\"string\">&quot;: &quot;</span></span><br><span class=\"line\">                       &lt;&lt; error;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        socket.SendUint32(result);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop: invalid command &quot;</span> &lt;&lt; cmd;</span><br><span class=\"line\">        socket.SendUint32(PROP_ERROR_INVALID_CMD);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数初始化了 socket 接收事件的超时时长，然后对接收到的 <code>cmd</code> 做相应的操作：</p>\n<ul>\n<li>对于 <code>PROP_MSG_SETPROP</code> 命令，使用两个长度为 <code>PROP_NAME_MAX</code> 的字符数组保存接收到的属性名和属性值。值得注意的是，最后会将字符数组中最后的一个元素设为 0，因此接收的属性名和属性值的最大长度不应超过 <code>PROP_NAME_MAX - 1</code> 。</li>\n<li>对于 <code>PROP_MSG_SETPROP2</code> 命令，使用两个 <code>std::string</code> 保存接收到的属性名和属性值。</li>\n</ul>\n<p>最后，不论是 <code>PROP_MSG_SETPROP</code> 命令还是 <code>PROP_MSG_SETPROP2</code> 命令，都会调用 <code>HandlePropertySet</code> 函数来设置属性。</p>\n<h3 id=\"2-4-3-信号\"><a href=\"#2-4-3-信号\" class=\"headerlink\" title=\"2.4.3 信号\"></a>2.4.3 信号</h3><p><strong>信号 (Signals)</strong> 属于 IPC 的一种方式，用于向一个进程或者进程中的特定线程发送事件通知。</p>\n<p>信号是一个<strong>异步的</strong>通信机制，一个进程可以不需要等待信号的到达。在信号未产生时，进程会正常执行；当信号产生后，系统可以中断目标进程的任何非原子操作，此时进程的正常执行流程会被中断，进而对信号进行处理。</p>\n<h4 id=\"2-4-3-1-处理信号\"><a href=\"#2-4-3-1-处理信号\" class=\"headerlink\" title=\"2.4.3.1 处理信号\"></a>2.4.3.1 处理信号</h4><p>在 Linux，一个子进程终结后，内核依然会为其维护关于此进程的最小信息集 (PID、终结状态、资源使用信息)，以便父进程获取有关子进程的信息。如果父进程没有为该子进程发起 wait、waitpid 或者 waitid 系统调用，那么子进程的信息就会一直占据着内核进程表的空间。在这种情况下，这个子进程就成为了一个**僵尸进程 (Zombie process)**。</p>\n<p>一般情况下，对于一个僵尸进程，如果其父进程终结了，那么 init 进程就会自动成为僵尸进程的父进程。此时，为了避免僵尸进程一直占据着系统资源，init 进程需要为僵尸进程释放占据的空间。</p>\n<p>而且，在加载启动脚本 [2.4.4] 这一步骤中，init 进程会 fork 得到一些子进程，例如：servicemanager 进程、zygote 进程。这些子进程对 Android 而言非常重要，在这些进程退出后，init 进程需要有相应的动作将其重启。</p>\n<p>于是，为了管理这些子进程，init 进程需要接收子进程终结的信号并进行相应的处理。</p>\n<p>在 Android，信号处理基于 Linux 的信号机制。</p>\n<h5 id=\"2-4-3-1-1-信号的处理方式\"><a href=\"#2-4-3-1-1-信号的处理方式\" class=\"headerlink\" title=\"2.4.3.1.1 信号的处理方式\"></a>2.4.3.1.1 信号的处理方式</h5><!-- 更正: 注册信号处理函数 -->\n\n<p>信号的处理方式有以下三种：</p>\n<ul>\n<li><strong>忽略该信号</strong></li>\n<li><strong>按信号的默认行为处理该信号</strong></li>\n<li><strong>使用自定义的信号处理函数来处理该信号</strong></li>\n</ul>\n<p>init 进程使用的是第三种处理方式：使用自定义的信号处理函数来处理该信号。进程注册了一个信号处理函数，当目标信号产生时，信号会被捕获，并调用注册的函数进行处理。</p>\n<p>接下来分析这个过程。</p>\n<h5 id=\"2-4-3-1-2-系统调用-sigaction\"><a href=\"#2-4-3-1-2-系统调用-sigaction\" class=\"headerlink\" title=\"2.4.3.1.2 系统调用 sigaction\"></a>2.4.3.1.2 系统调用 sigaction</h5><p>在分析 init 进程注册函数的过程之前，首先来了解系统调用 sigaction，这个系统调用是此过程的一个关键点。</p>\n<p><strong>sigaction</strong> 是一个系统调用，函数原型为 <code>int sigaction(int signum, const struct sigaction *restrict act, struct sigaction *restrict oldact)</code>，用于更改进程在收到指定信号后的行为。</p>\n<h6 id=\"2-4-3-1-2-1-参数\"><a href=\"#2-4-3-1-2-1-参数\" class=\"headerlink\" title=\"2.4.3.1.2.1 参数\"></a>2.4.3.1.2.1 参数</h6><p>首先来理解 sigaction 的参数：</p>\n<ul>\n<li><p><strong>signum</strong> 是指定信号的编号。</p>\n<p>同一个信号在不同的架构上可能有不同的编号。在 Android，ARM 架构的信号编号定义在 <code>bionic/libc/kernel/uapi/asm-arm/asm/signal.h</code> 文件上。</p>\n</li>\n<li><p><strong>act</strong> 是一个 sigaction 类型的指针，而 sigaction 是一个结构体，其定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span>     (*sa_handler)(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">   <span class=\"keyword\">void</span>     (*sa_sigaction)(<span class=\"keyword\">int</span>, <span class=\"keyword\">siginfo_t</span> *, <span class=\"keyword\">void</span> *);</span><br><span class=\"line\">   <span class=\"keyword\">sigset_t</span>   sa_mask;</span><br><span class=\"line\">   <span class=\"keyword\">int</span>        sa_flags;</span><br><span class=\"line\">   <span class=\"keyword\">void</span>     (*sa_restorer)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>关注结构体中两个较为重要的成员 <code>sa_handler</code> 和 <code>sa_flags</code>。</p>\n<p>成员 <code>sa_handler</code> 用于指定信号产生时的行为，可以是以下这些值之一：</p>\n<ul>\n<li><p><strong>SIG_DFL</strong></p>\n<p>表示执行该信号的默认行为。</p>\n</li>\n<li><p><strong>SIG_IGN</strong></p>\n<p>表示忽略该信号。</p>\n</li>\n<li><p><strong>一个指向信号处理函数的指针</strong></p>\n<p>信号编号 signum 将作为函数的唯一参数传入。当目标信号产生时，会自动调用此函数进行处理。</p>\n</li>\n</ul>\n<p>成员 <code>sa_flags</code> 是标志位，可以由零个或者多个标志组成。下面列出其中的一些标志：</p>\n<ul>\n<li><p><strong>SA_NOCLDSTOP</strong></p>\n<p>只有当 signum = SIGCHLD 时才有意义。表示进程不接收子进程停止或者恢复时产生的信号，只接收子进程终结的信号。</p>\n</li>\n<li><p><strong>SA_RESETHAND</strong></p>\n<p>当信号已经由信号处理函数处理过后，将信号恢复为使用默认行为进行处理。</p>\n</li>\n<li><p><strong>SA_SIGINFO</strong></p>\n<p>不再通过结构体成员 sa_handler 设置信号处理函数，而是使用成员 sa_sigaction。此时，函数的入参有三个。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>oldact</strong> 同样是一个 sigaction 类型的指针，用于保存上一个 sigaction 调用所传入的参数 act，可以为空。</p>\n</li>\n</ul>\n<h6 id=\"2-4-3-1-2-2-返回值\"><a href=\"#2-4-3-1-2-2-返回值\" class=\"headerlink\" title=\"2.4.3.1.2.2 返回值\"></a>2.4.3.1.2.2 返回值</h6><p>最后来了解 sigaction 的返回值：</p>\n<ul>\n<li><p>当操作成功时，返回值为 0。</p>\n</li>\n<li><p>当发生错误时，返回值为 -1。</p>\n</li>\n</ul>\n<h5 id=\"2-4-3-1-3-init-进程注册信号处理函数\"><a href=\"#2-4-3-1-3-init-进程注册信号处理函数\" class=\"headerlink\" title=\"2.4.3.1.3 init 进程注册信号处理函数\"></a>2.4.3.1.3 init 进程注册信号处理函数</h5><p>在了解过系统调用 sigaction 以后，现在可以开始分析 init 进程注册信号处理函数的过程。</p>\n<h6 id=\"2-4-3-1-3-1-发起系统调用-sigaction\"><a href=\"#2-4-3-1-3-1-发起系统调用-sigaction\" class=\"headerlink\" title=\"2.4.3.1.3.1 发起系统调用 sigaction\"></a>2.4.3.1.3.1 发起系统调用 sigaction</h6><p>init 进程通过调用 InstallSignalFdHandler 函数实现注册信号处理函数，函数所在文件的路径为 <code>system/core/init/init.cpp</code>，首先来关注函数前半部分所做的工作：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">InstallSignalFdHandler</span><span class=\"params\">(Epoll* epoll)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建结构体 sigaction</span></span><br><span class=\"line\">    <span class=\"comment\">// 成员 sa_handler 用于指定信号产生时的行为, 令 sa_handler = SIG_DFL 表明当信号产生时按默认行为对信号进行处理</span></span><br><span class=\"line\">    <span class=\"comment\">// 成员 sa_flags 是标志位, 令 sa_flags = SA_NOCLDSTOP 表明 init 进程不接收子进程被中断或者被中断后恢复时产生的信号, 只接收子进程终结的信号</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> <span class=\"title\">act</span> &#123;</span> .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDSTOP &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// sigaction 是一个系统调用, 用于更改进程在收到指定的信号时所执行的操作 [2.4.3.1.2]</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到第一个参数传入的是 SIGCHLD, 表明目标信号是 SIGCHLD, 当子进程终结, 被中断, 或者被中断后恢复时, 就会产生此信号</span></span><br><span class=\"line\">    sigaction(SIGCHLD, &amp;act, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数前半部分所做的工作是：发起系统调用 sigaction，针对子进程产生的 <code>SIGCHLD</code> 信号，当进程在收到信号时，按默认行为对信号进行处理，而 <code>SIGCHLD</code> 信号的默认行为就是忽略该信号。</p>\n<p>值得注意的是，当子进程终结、被中断或者被中断后恢复时，都会产生 <code>SIGCHLD</code> 信号，而添加标志位 <code>SA_NOCLDSTOP</code> 可以使得 init 进程只接收子进程终结的信号。</p>\n<p>显然，在函数前半部分所做的工作中，并没有实现按自定义行为对信号进行处理。事实上，init 进程是通过监听 signal 文件描述符来实现按自定义行为来处理信号的。接下来分析 InstallSignalFdHandler 函数后半部分所做的工作。</p>\n<h6 id=\"2-4-3-1-3-2-监听-signal-文件描述符\"><a href=\"#2-4-3-1-3-2-监听-signal-文件描述符\" class=\"headerlink\" title=\"2.4.3.1.3.2 监听 signal 文件描述符\"></a>2.4.3.1.3.2 监听 signal 文件描述符</h6><p>之前提到，信号是一个异步的通信机制。进程可以注册一个信号处理函数，接着就能继续进行其他的工作，只有当目标信号发送到进程时，才回调处理函数进行处理，这里就体现出异步的性质。</p>\n<p>除了异步的方式以外，进程还可以通过同步的方式接收信号。Linux 提供了系统调用 signalfd，用于创建一个接收指定信号的文件描述符。对文件描述符执行读操作会进入阻塞状态，直到目标信号产生并传递给进程。</p>\n<p>init 进程就是通过这种方式来同步接收信号的，接下来分析这个过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">InstallSignalFdHandler</span><span class=\"params\">(Epoll* epoll)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// mask 是一个信号集, 用于指定想要接收的信号</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这里, 目标信号就是 SIGCHLD</span></span><br><span class=\"line\">    <span class=\"keyword\">sigset_t</span> mask;</span><br><span class=\"line\">    sigemptyset(&amp;mask);</span><br><span class=\"line\">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 signal 文件描述符</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到, 在发起系统调用 signalfd 时, 传入的第一个参数是 -1, 则调用会创建一个新的文件描述符</span></span><br><span class=\"line\">    signal_fd = signalfd(<span class=\"number\">-1</span>, &amp;mask, SFD_CLOEXEC);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (signal_fd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; <span class=\"string\">&quot;failed to create signalfd&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将 signal 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]</span></span><br><span class=\"line\">    <span class=\"comment\">// HandleSignalFd 是可读事件触发时的回调函数 [2.4.3.1.4]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll-&gt;RegisterHandler(signal_fd, HandleSignalFd); !result) &#123;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数后半部分所做的工作是：创建信号集，信号集里面包含了信号 <code>SIGCHLD</code>，然后新建一个与信号集关联的 signal 文件描述符，最后将文件描述符注册到 epoll。</p>\n<p>当 signal 文件描述符的可读事件触发时，就会调用 HandleSignalFd 函数，接下来分析这个函数。</p>\n<h5 id=\"2-4-3-1-4-回调函数-HandleSignalFd\"><a href=\"#2-4-3-1-4-回调函数-HandleSignalFd\" class=\"headerlink\" title=\"2.4.3.1.4 回调函数 HandleSignalFd\"></a>2.4.3.1.4 回调函数 HandleSignalFd</h5><p>函数所在文件的路径为 <code>system/core/init/init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">HandleSignalFd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    signalfd_siginfo siginfo;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从 signal 文件描述符中读取结构体 signalfd_siginfo, 每次读取一个</span></span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> bytes_read = TEMP_FAILURE_RETRY(read(signal_fd, &amp;siginfo, <span class=\"keyword\">sizeof</span>(siginfo)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bytes_read != <span class=\"keyword\">sizeof</span>(siginfo)) &#123;</span><br><span class=\"line\">        PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Failed to read siginfo from signal_fd&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据信号编号执行相应的操作</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (siginfo.ssi_signo) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SIGCHLD:</span><br><span class=\"line\">            ReapAnyOutstandingChildren();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SIGTERM:</span><br><span class=\"line\">            HandleSigtermSignal(siginfo);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;signal_fd: received unexpected signal &quot;</span> &lt;&lt; siginfo.ssi_signo;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当目标信号产生并传递给进程时，signal 文件描述符的可读事件就会触发，返回一个或者多个结构体 signalfd_siginfo。而函数 HandleSignalFd 负责从 signal 文件描述符中读出一个结构体 signalfd_siginfo，并根据信号编号执行相应的操作。</p>\n<p>在这里，我们关心的信号是 <code>SIGCHLD</code>。当此信号产生后，会调用 ReapAnyOutstandingChildren 函数，接着来分析这个函数。</p>\n<h6 id=\"2-4-3-1-4-1-分析-ReapAnyOutstandingChildren-函数\"><a href=\"#2-4-3-1-4-1-分析-ReapAnyOutstandingChildren-函数\" class=\"headerlink\" title=\"2.4.3.1.4.1 分析 ReapAnyOutstandingChildren 函数\"></a>2.4.3.1.4.1 分析 ReapAnyOutstandingChildren 函数</h6><p>函数所在文件的路径为 <code>system/core/init/sigchld_handler.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ReapAnyOutstandingChildren</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ReapOneProcess()) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数循环调用 ReapOneProcess 函数，只有当函数 ReapOneProcess 返回 false 时，循环才会停止。接着来看 ReapOneProcess 函数做了什么工作。</p>\n<h6 id=\"2-4-3-1-4-2-分析-ReapOneProcess-函数\"><a href=\"#2-4-3-1-4-2-分析-ReapOneProcess-函数\" class=\"headerlink\" title=\"2.4.3.1.4.2 分析 ReapOneProcess 函数\"></a>2.4.3.1.4.2 分析 ReapOneProcess 函数</h6><!-- TODO: 分析 service->flags() -->\n\n<!-- TODO: 分析 ServiceList::GetInstance().RemoveService(*service) -->\n\n<p>函数所在文件的路径为 <code>system/core/init/sigchld_handler.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">ReapOneProcess</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">siginfo_t</span> siginfo = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发起系统调用 waitid, 此系统调用用于获取子进程状态的变更和相关的信息</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于 init 进程只接收子进程终结的信号, 因此这里获取到的都是已进入僵尸状态的子进程的相关信息, 信息保存在 siginfo 当中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TEMP_FAILURE_RETRY(waitid(P_ALL, <span class=\"number\">0</span>, &amp;siginfo, WEXITED | WNOHANG | WNOWAIT)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 失败, 函数返回 false</span></span><br><span class=\"line\">        PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;waitid failed&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取子进程的 pid</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> pid = siginfo.si_pid;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 子进程的 pid 不存在, 函数返回 false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> wait_string;</span><br><span class=\"line\">    Service* service = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PropertyChildReap(pid)) &#123;</span><br><span class=\"line\">        name = <span class=\"string\">&quot;Async property child&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (SubcontextChildReap(pid)) &#123;</span><br><span class=\"line\">        name = <span class=\"string\">&quot;Subcontext&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据 pid 查询相应的 service</span></span><br><span class=\"line\">        service = ServiceList::GetInstance().FindService(pid, &amp;Service::pid);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (service) &#123;</span><br><span class=\"line\">            name = StringPrintf(<span class=\"string\">&quot;Service &#x27;%s&#x27; (pid %d)&quot;</span>, service-&gt;name().c_str(), pid);</span><br><span class=\"line\"></span><br><span class=\"line\">            ...</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            name = StringPrintf(<span class=\"string\">&quot;Untracked pid %d&quot;</span>, pid);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 没有找到对应的 service, 函数返回 true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!service) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用 service 的 Reap 函数</span></span><br><span class=\"line\">    service-&gt;Reap(siginfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经分析可知，ReapOneProcess 函数的主要工作是：为每个进入终结状态的子进程发起系统调用 waitid，从而避免已进入僵尸状态的子进程一直占据着系统资源。最后，函数会根据子进程 pid 查找是否存在相应的 service，如果 service 存在，还会调用 service 的 Reap 函数。接着来分析 Reap 函数。</p>\n<h6 id=\"2-4-3-1-4-3-分析-Reap-函数\"><a href=\"#2-4-3-1-4-3-分析-Reap-函数\" class=\"headerlink\" title=\"2.4.3.1.4.3 分析 Reap 函数\"></a>2.4.3.1.4.3 分析 Reap 函数</h6><p>函数所在文件的路径为 <code>system/core/init/service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Service::Reap</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">siginfo_t</span>&amp; siginfo)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(flags_ &amp; SVC_ONESHOT) || (flags_ &amp; SVC_RESTART)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果服务的标志位同时不带有 SVC_ONESHOT 和 SVC_RESTART, 则直接杀死服务所在的进程组</span></span><br><span class=\"line\">        KillProcessGroup(SIGKILL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果服务的标志位带有 SVC_TEMPORARY, 则直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags_ &amp; SVC_TEMPORARY) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重置状态</span></span><br><span class=\"line\">    pid_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    flags_ &amp;= (~SVC_RUNNING);</span><br><span class=\"line\">    start_order_ = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((flags_ &amp; SVC_ONESHOT) &amp;&amp; !(flags_ &amp; SVC_RESTART) &amp;&amp; !(flags_ &amp; SVC_RESET)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将带有 SVC_ONESHOT 的服务设为不可用状态</span></span><br><span class=\"line\">        flags_ |= SVC_DISABLED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags_ &amp; (SVC_DISABLED | SVC_RESET))  &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果服务的标志位带有 SVC_DISABLED 或者 SVC_RESET, 则使其进入 stopped 状态, 不会自动重启</span></span><br><span class=\"line\">        NotifyStateChange(<span class=\"string\">&quot;stopped&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 带有标志位 SVC_CRITICAL 的服务会被标记为系统关键服务</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果服务在 4 分钟之内崩溃 4 次以上, 又或者服务崩溃时系统处于未完全启动状态</span></span><br><span class=\"line\">    <span class=\"comment\">// 则设备会重启并进入 bootloader 或者设置崩溃相关的属性</span></span><br><span class=\"line\">    boot_clock::time_point now = boot_clock::now();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (((flags_ &amp; SVC_CRITICAL) || !pre_apexd_) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> boot_completed = android::base::GetBoolProperty(<span class=\"string\">&quot;sys.boot_completed&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now &lt; time_crashed_ + <span class=\"number\">4</span>min || !boot_completed) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++crash_count_ &gt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (flags_ &amp; SVC_CRITICAL) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Aborts into bootloader</span></span><br><span class=\"line\">                    LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;critical process &#x27;&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;&#x27; exited 4 times &quot;</span></span><br><span class=\"line\">                               &lt;&lt; (boot_completed ? <span class=\"string\">&quot;in 4 minutes&quot;</span> : <span class=\"string\">&quot;before boot completed&quot;</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;updatable process &#x27;&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;&#x27; exited 4 times &quot;</span></span><br><span class=\"line\">                               &lt;&lt; (boot_completed ? <span class=\"string\">&quot;in 4 minutes&quot;</span> : <span class=\"string\">&quot;before boot completed&quot;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// Notifies update_verifier and apexd</span></span><br><span class=\"line\">                    property_set(<span class=\"string\">&quot;ro.init.updatable_crashing&quot;</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            time_crashed_ = now;</span><br><span class=\"line\">            crash_count_ = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加标志位 SVC_RESTARTING, init 进程会重启带有此标志位的服务 [2.4.5.2]</span></span><br><span class=\"line\">    flags_ &amp;= (~SVC_RESTART);</span><br><span class=\"line\">    flags_ |= SVC_RESTARTING;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行当前 service 中所有 onrestart 命令</span></span><br><span class=\"line\">    onrestart_.ExecuteAllCommands();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使服务进入 restarting 状态</span></span><br><span class=\"line\">    NotifyStateChange(<span class=\"string\">&quot;restarting&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Reap 函数最主要的工作就是重启有需要的服务。注意到，改变服务状态是通过调用 NotifyStateChange 函数实现的，来看看这个函数。</p>\n<h6 id=\"2-4-3-1-4-4-分析-NotifyStateChange-函数\"><a href=\"#2-4-3-1-4-4-分析-NotifyStateChange-函数\" class=\"headerlink\" title=\"2.4.3.1.4.4 分析 NotifyStateChange 函数\"></a>2.4.3.1.4.4 分析 NotifyStateChange 函数</h6><p>函数所在文件的路径为 <code>system/core/init/service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Service::NotifyStateChange</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; new_state)</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((flags_ &amp; SVC_TEMPORARY) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果服务的标志位中带有 SVC_TEMPORARY, 则不会使用属性服务来记录它的状态</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用属性服务来记录服务当前的状态</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> prop_name = <span class=\"string\">&quot;init.svc.&quot;</span> + name_;</span><br><span class=\"line\">    property_set(prop_name, new_state);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过分析这个函数，可以知道，系统会使用属性服务以 key-value 的形式存储服务当前的状态，其中 key 的取值为 init.svc.[service_name]，value 是服务当前的状态。因此，可以使用 adb，输入命令 <code>getprop | grep init.svc.</code>，查看设备上 service 的运行状态，以下是其中的一些输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[init.svc.adbd]: [running]</span><br><span class=\"line\">[init.svc.alarm-hal-1-0]: [running]</span><br><span class=\"line\">[init.svc.android.thermal-hal]: [running]</span><br><span class=\"line\">[init.svc.apexd]: [stopped]</span><br><span class=\"line\">[init.svc.apexd-bootstrap]: [stopped]</span><br><span class=\"line\">[init.svc.apexd-snapshotde]: [stopped]</span><br><span class=\"line\">[init.svc.audioserver]: [running]</span><br><span class=\"line\">[init.svc.wifidisplayhalservice]: [running]</span><br><span class=\"line\">[init.svc.wpa_supplicant]: [running]</span><br><span class=\"line\">[init.svc.zygote]: [running]</span><br><span class=\"line\">[init.svc.zygote_secondary]: [running]</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-4-4-加载启动脚本\"><a href=\"#2-4-4-加载启动脚本\" class=\"headerlink\" title=\"2.4.4 加载启动脚本\"></a>2.4.4 加载启动脚本</h3><!-- TODO: 分析函数 CreateParser -->\n\n<!-- TODO: .rc 文件的解析过程 -->\n\n<!-- TODO: 属性的变更如何触发脚本中的属性触发器？ -->\n\n<!-- TODO: /system/etc/init -->\n\n<!-- TODO: /odm/etc/init -->\n\n<!-- TODO: /vendor/etc/init -->\n\n<p>调用 LoadBootScripts 函数加载启动脚本，函数所在文件的路径为 <code>system/core/init/init.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">LoadBootScripts</span><span class=\"params\">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class=\"line\">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootscript = GetProperty(<span class=\"string\">&quot;ro.boot.init_rc&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootscript.empty()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 加载 init.rc 脚本文件 [2.4.4.1]</span></span><br><span class=\"line\">        parser.ParseConfig(<span class=\"string\">&quot;/init.rc&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /system/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/system/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/system/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /product/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /product_services/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /odm/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/odm/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/odm/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /vendor/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        parser.ParseConfig(bootscript);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般情况下，此函数会去加载一些指定的脚本，其中：</p>\n<ul>\n<li><code>init.rc</code> 是主要的 .rc 文件。</li>\n<li><code>/system/etc/init/</code> 包含了核心的系统项目，例如：SurfaceFlinger, MediaService, logcatd。</li>\n<li><code>/vendor/etc/init/</code> 包含了 SoC 供应商项目，例如：核心 SoC 功能所需的操作或守护进程。</li>\n<li><code>/odm/etc/init/</code> 包含了设备制造商项目，例如：运动传感器或其他外围设备所需的操作或守护进程。</li>\n</ul>\n<p>init.rc 是最主要脚本文件，接下来将对这个脚本进行分析。</p>\n<h4 id=\"2-4-4-1-init-rc-脚本\"><a href=\"#2-4-4-1-init-rc-脚本\" class=\"headerlink\" title=\"2.4.4.1 init.rc 脚本\"></a>2.4.4.1 init.rc 脚本</h4><p>在 Android，后缀为 .rc 的文件由 Android Init Language 编写，<a href=\"https://cs.android.com/android/platform/superproject/+/android-security-10.0.0_r56:system/core/init/README.md\">关于 Android Init Language 的详细说明</a> 可以在 AOSP 上找到，路径为 <code>system/core/init/README.md</code>。</p>\n<p>在分析脚本之前，首先来了解这种语言的语法。</p>\n<h5 id=\"2-4-4-1-1-Android-Init-Language\"><a href=\"#2-4-4-1-1-Android-Init-Language\" class=\"headerlink\" title=\"2.4.4.1.1 Android Init Language\"></a>2.4.4.1.1 Android Init Language</h5><p>Android Init Language 由五大类表达式组成：<code>Actions</code>，<code>Commands</code>，<code>Services</code>，<code>Options</code>，<code>Imports</code>。</p>\n<p>其语法规则有：</p>\n<ul>\n<li>每一行都是一条语句，一条语句由多个 token 组成，token 之间以空格分开。</li>\n<li>如果一个 token 包含了空格，可以跟 c 语言类似，使用反斜杠 <code>\\</code> 作为转义字符，又或者使用双引号包裹整个 token。</li>\n<li>在行的末尾使用反斜杠 <code>\\</code>，可以将语句换行。</li>\n<li>以符号 <code>#</code> 开头的行是注释行。</li>\n<li>系统属性的值可以通过语法 <code>$&#123;property.name&#125;</code> 获取，例如：<code>import /init.recovery.$&#123;ro.hardware&#125;.rc</code>。</li>\n<li>一个文件可以分为多个 section，必须使用 <code>Actions</code> 或者 <code>Services</code> 来声明一个新的 section。所有的 <code>Commands</code> 和 <code>Options</code> 都是属于最近声明的那一个 section。如果在一个 section 之前声明了 <code>Commands</code> 或者 <code>Options</code> ，则声明会被忽略。</li>\n<li><code>Services</code> 的名称必须是唯一的，如果存在多个重名的 <code>Services</code> ，除了第一个以外，其他的都会被忽略，并且会输出错误日志。</li>\n</ul>\n<p>接下来列出一些较为重要的表达式。</p>\n<h6 id=\"2-4-4-1-1-1-Actions\"><a href=\"#2-4-4-1-1-1-Actions\" class=\"headerlink\" title=\"2.4.4.1.1.1 Actions\"></a>2.4.4.1.1.1 Actions</h6><p><code>Actions</code> 由 一系列 <code>Commands</code> 组成，同时 <code>Triggers</code> 决定了 <code>Actions</code> 的触发时机，其形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]*</span><br><span class=\"line\">   &lt;command&gt;</span><br><span class=\"line\">   &lt;command&gt;</span><br><span class=\"line\">   &lt;command&gt;</span><br></pre></td></tr></table></figure>\n<p>当一个事件触发后，如果此事件能够匹配上 <code>Actions</code> 的  <code>Triggers</code>，那么 <code>Actions</code> 会被添加到待执行队列的尾部。</p>\n<p>之后，待执行队列中的 <code>Actions</code> 会按照加入顺序出队，并且执行该 <code>Actions</code> 中的 <code>Commands</code>。</p>\n<p>以启动 Zygote 作为示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br></pre></td></tr></table></figure>\n<p>简单分析这个脚本：</p>\n<p>这个 <code>Actions</code> 拥有两个 <code>Triggers</code>，分别是 <code>zygote-start</code> 和 <code>property:ro.crypto.state=unencrypted</code>，从第二行开始，每一行都是一个 <code>Command</code>。</p>\n<p>当事件 <code>zygote-start</code> 和 <code>property:ro.crypto.state=unencrypted</code> 触发后，<code>Actions</code> 会被加入到待执行队列。在执行到该 <code>Actions</code> 时，会按照 <code>Commands</code> 定义的先后顺序，依次执行 <code>Actions</code> 中的 <code>Commands</code>。</p>\n<h6 id=\"2-4-4-1-1-2-Triggers\"><a href=\"#2-4-4-1-1-2-Triggers\" class=\"headerlink\" title=\"2.4.4.1.1.2 Triggers\"></a>2.4.4.1.1.2 Triggers</h6><p><code>Triggers</code> 是字符串，用于匹配某些类型的事件并触发 <code>Actions</code> 中的 <code>Commands</code>。</p>\n<p>Triggers 可以分为两类：</p>\n<ul>\n<li><p><strong>Event triggers</strong></p>\n<p>事件触发器，这类触发器所匹配的事件由命令 <code>trigger</code>  触发，又或者通过调用 <code>QueueEventTrigger()</code> 函数触发。</p>\n</li>\n<li><p><strong>Property triggers</strong></p>\n<p>属性触发器，这类触发器所匹配的事件是：属性是否满足某个值，形式为 <code>property:&lt;key&gt;=&lt;value&gt;</code>。这里的属性就是之前提到的属性服务管理的属性。</p>\n</li>\n</ul>\n<p>注意，每一个 <code>Actions</code> 可以有多个属性触发器，但只能有一个事件触发器。</p>\n<p>例如：</p>\n<p><code>on init &amp;&amp; property:a=b</code>，<code>on property:a=b &amp;&amp; property:c=d</code> 是合法的。</p>\n<p><code>on boot &amp;&amp; on init</code> 是不合法的。</p>\n<h6 id=\"2-4-4-1-1-3-Commands\"><a href=\"#2-4-4-1-1-3-Commands\" class=\"headerlink\" title=\"2.4.4.1.1.3 Commands\"></a>2.4.4.1.1.3 Commands</h6><p>下面列举一些常见的 <code>Commands</code>：</p>\n<ul>\n<li><p><strong>trigger <event></strong></p>\n<p>触发一个事件。</p>\n</li>\n<li><p><strong>write <path> <content></strong></p>\n<p>按 path 打开文件，往文件中写入内容。</p>\n</li>\n<li><p><strong>chown <owner> <group> <path></strong></p>\n<p>更改文件所有者和组。</p>\n</li>\n<li><p><strong>mkdir <path> [mode] [owner] [group]</strong></p>\n<p>在路径上创建一个目录，可以选择使用给定的权限，所有者，用户组。 </p>\n<p>如果未指定权限，所有者，用户组，则新建的目录默认具有权限 755，并由 root 用户和 root 组拥有。</p>\n<p>当指定权限，所有者，用户组时，如果目录已经存在，则权限，所有者，用户组将被更新。</p>\n</li>\n<li><p><strong>start <service></strong></p>\n<p>当指定的服务未在运行时，启动该服务。</p>\n</li>\n<li><p><strong>exec_start <service></strong></p>\n<p>启动指定的服务，在该命令返回之前暂停处理其他命令。</p>\n</li>\n<li><p><strong>setprop <name> <value></strong></p>\n<p>给系统属性赋值，这里的属性是之前提到的属性服务中的属性。</p>\n</li>\n<li><p><strong>symlink <target> <path></strong></p>\n<p>在 path 上创建一个连接到 target 的符号链接。</p>\n</li>\n</ul>\n<h6 id=\"2-4-4-1-1-4-Services\"><a href=\"#2-4-4-1-1-4-Services\" class=\"headerlink\" title=\"2.4.4.1.1.4 Services\"></a>2.4.4.1.1.4 Services</h6><p><code>Services</code> 是由 init 进程启动的程序，一般运行在 init 进程的一个子进程，因此 init 进程在启动一个 <code>Services</code> 时会通过 fork 的方式生成子进程。</p>\n<p>默认情况下，<code>Services</code> 退出后会重启。</p>\n<p><code>Services</code> 的形式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class=\"line\">   &lt;option&gt;</span><br><span class=\"line\">   &lt;option&gt;</span><br><span class=\"line\">   ...</span><br></pre></td></tr></table></figure>\n<p>以启动 Zygote 64 位进程的脚本作为示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class=\"line\">    class main</span><br><span class=\"line\">    priority -20</span><br><span class=\"line\">    user root</span><br><span class=\"line\">    group root readproc reserved_disk</span><br><span class=\"line\">    socket zygote stream 660 root system</span><br><span class=\"line\">    socket usap_pool_primary stream 660 root system</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class=\"line\">    onrestart restart audioserver</span><br><span class=\"line\">    onrestart restart cameraserver</span><br><span class=\"line\">    onrestart restart media</span><br><span class=\"line\">    onrestart restart netd</span><br><span class=\"line\">    onrestart restart wificond</span><br><span class=\"line\">    writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br></pre></td></tr></table></figure>\n<p>简单分析这个脚本：<code>zygote</code> 是 <code>Services</code> 的名称，<code>/system/bin/app_process64</code> 是可执行文件的路径，<code>-Xzygote /system/bin --zygote --start-system-server</code> 是启动参数，从第二行开始，每一行都是一个 <code>Options</code>。</p>\n<h6 id=\"2-4-4-1-1-5-Options\"><a href=\"#2-4-4-1-1-5-Options\" class=\"headerlink\" title=\"2.4.4.1.1.5 Options\"></a>2.4.4.1.1.5 Options</h6><p><code>Options</code> 是 <code>Services</code> 的配置项，用于控制 init 进程运行 <code>Services</code> 的方式和时间。</p>\n<p> 下面列举一些常见的 <code>Options</code>：</p>\n<ul>\n<li><p><strong>class <name> [ <name>* ]</strong></p>\n<p>指定 <code>Services</code> 的类名。当 <code>Services</code> 所属类开启 (退出) 时，<code>Services</code> 也会开启 (退出) 。默认值为 default。</p>\n</li>\n<li><p><strong>class_start <serviceclass></strong></p>\n<p>启动所有未在运行的，类名被指定为 <code>serviceclass</code> 的 <code>Services</code>。</p>\n</li>\n<li><p><strong>priority <priority></strong></p>\n<p>设置 <code>Services</code> 进程的优先级。取值范围是 -20 ~ 19。默认值为 0。</p>\n</li>\n<li><p><strong>user <username></strong></p>\n<p>设置执行 <code>Services</code> 的用户。一般情况下，默认值为 root。</p>\n</li>\n<li><p><strong>group <groupname> [ <groupname>* ]</strong></p>\n<p>设置执行 <code>Services</code> 的用户组。一般情况下，默认值为 root。</p>\n</li>\n<li><p><strong>socket <name> <type> <perm> [ <user> [ <group> [ <seclabel> ] ] ]</strong></p>\n<p>创建一个 unix 域的 socket，命名为 <code>/dev/socket/&lt;name&gt;</code>，并将 socket 的文件描述符传递给创建的进程。</p>\n</li>\n<li><p><strong>onrestart</strong></p>\n<p>当 <code>Services</code> 重启时执行一个 <code>Commands</code>。</p>\n</li>\n<li><p><strong>oneshot</strong></p>\n<p>当 <code>Services</code> 退出后不再重启。</p>\n</li>\n<li><p><strong>writepid <file> [ <file>* ]</strong></p>\n<p>在进程 fork 之后，将子进程的 pid 写入指定的文件。</p>\n</li>\n</ul>\n<h5 id=\"2-4-4-1-2-加载-init-rc-脚本\"><a href=\"#2-4-4-1-2-加载-init-rc-脚本\" class=\"headerlink\" title=\"2.4.4.1.2 加载 init.rc 脚本\"></a>2.4.4.1.2 加载 init.rc 脚本</h5><p>脚本文件 init.rc 负责系统的初始设置，文件的路径为 <code>system/core/rootdir/init.rc</code>。</p>\n<p>在了解到脚本的编写语法之后，可以知道脚本的内容都是由  <code>Actions</code> 和 <code>Services</code> 构成的，而在 init.rc 脚本中绝大部分都是 <code>Actions</code>。在 [2.4.4.1.1.2] 中曾经提到，调用 <code>QueueEventTrigger()</code> 函数可以触发一个事件，当事件匹配上  <code>Actions</code> 的  <code>Triggers</code>，就会开始执行该 <code>Actions</code>。 接下来回到进程启动的第二阶段，寻找事件的触发点。</p>\n<h6 id=\"2-4-4-1-2-1-源码中事件的触发点\"><a href=\"#2-4-4-1-2-1-源码中事件的触发点\" class=\"headerlink\" title=\"2.4.4.1.2.1 源码中事件的触发点\"></a>2.4.4.1.2.1 源码中事件的触发点</h6><p>回到 init 进程启动的第二阶段，对应源代码 <code>system/core/init/init.cpp</code> 的 SecondStageMain 函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将触发事件 early-init 的操作加入到 ActionManager</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;early-init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Trigger all the boot actions to get us started.</span></span><br><span class=\"line\">    <span class=\"comment\">// 将触发事件 init 的操作加入到 ActionManager</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t mount filesystems or start core system services in charger mode.</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootmode = GetProperty(<span class=\"string\">&quot;ro.bootmode&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootmode == <span class=\"string\">&quot;charger&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前处于充电模式, 则将触发事件 charger 的操作加入到 ActionManager</span></span><br><span class=\"line\">        <span class=\"comment\">// 在充电模式下, 不会挂载文件系统和启动核心系统服务</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;charger&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前处于非充电模式, 则将触发事件 late-init 的操作加入到 ActionManager</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;late-init&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ActionManager 会按操作加入的顺序逐一执行 [2.4.5.x]，由此可知事件的触发顺序：</p>\n<ul>\n<li>非充电模式：early-init -&gt; init -&gt; late-init</li>\n<li>充电模式：early-init -&gt; init -&gt; charger</li>\n</ul>\n<p>由于在充电模式下，系统可能未完全启动，接下来将选取非充电模式下的流程进行分析。</p>\n<h6 id=\"2-4-4-1-2-2-init-rc-脚本的执行过程\"><a href=\"#2-4-4-1-2-2-init-rc-脚本的执行过程\" class=\"headerlink\" title=\"2.4.4.1.2.2 init.rc 脚本的执行过程\"></a>2.4.4.1.2.2 init.rc 脚本的执行过程</h6><!-- TODO: trigger boot -->\n\n<p>现在结合事件的触发顺序，分析脚本执行过程中的一些关键点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on early-init</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    # 以 start 方式启动 ueventd</span><br><span class=\"line\">    start ueventd</span><br><span class=\"line\"></span><br><span class=\"line\">    # 以 exec_start 方式运行 apexd-bootstrap, 在该命令返回之前暂停处理其他命令, 从而保证后续流程中 APEX 的可用性</span><br><span class=\"line\">    exec_start apexd-bootstrap</span><br><span class=\"line\"></span><br><span class=\"line\">on init</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    # 以 start 方式启动基本服务</span><br><span class=\"line\">    # 启动 servicemanager [2.4.4.1.2.3]</span><br><span class=\"line\">    start servicemanager</span><br><span class=\"line\">    start hwservicemanager</span><br><span class=\"line\">    start vndservicemanager</span><br><span class=\"line\"></span><br><span class=\"line\"># 挂载文件和启动核心系统服务</span><br><span class=\"line\"># 其中 trigger 用于触发一个事件 [2.4.4.1.1.2]</span><br><span class=\"line\">on late-init</span><br><span class=\"line\">    trigger early-fs</span><br><span class=\"line\">    trigger fs</span><br><span class=\"line\">    trigger post-fs</span><br><span class=\"line\">    trigger late-fs</span><br><span class=\"line\">    trigger post-fs-data</span><br><span class=\"line\">    trigger load_persist_props_action</span><br><span class=\"line\"></span><br><span class=\"line\">    # 触发事件 zygote-start, 启动 zygote [2.4.4.1.2.4]</span><br><span class=\"line\">    trigger zygote-start</span><br><span class=\"line\"></span><br><span class=\"line\">    trigger firmware_mounts_complete</span><br><span class=\"line\">    trigger early-boot</span><br><span class=\"line\">    trigger boot</span><br></pre></td></tr></table></figure>\n<p>经过分析，现在已经大致了解脚本的执行过程，接下来分析 servicemanager 和 zygote 的启动。</p>\n<h6 id=\"2-4-4-1-2-3-启动-servicemanager\"><a href=\"#2-4-4-1-2-3-启动-servicemanager\" class=\"headerlink\" title=\"2.4.4.1.2.3 启动 servicemanager\"></a>2.4.4.1.2.3 启动 servicemanager</h6><p>servicemanager 启动脚本的路径为 <code>frameworks/native/cmds/servicemanager/servicemanager.rc</code>，分析这个脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># servicemanager 是 Services 的名称</span><br><span class=\"line\"># &#x2F;system&#x2F;bin&#x2F;servicemanager 是可执行文件的路径</span><br><span class=\"line\">service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager</span><br><span class=\"line\">    # 指定类名为 core 和 animation</span><br><span class=\"line\">    # 当 core 或者 animation 开启 (关闭) 时, servicemanager 也将开启 (关闭)</span><br><span class=\"line\">    class core animation</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置用户为 system</span><br><span class=\"line\">    user system</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置用户组为 system 和 readproc</span><br><span class=\"line\">    group system readproc</span><br><span class=\"line\"></span><br><span class=\"line\">    # 将其标记为设备的关键服务</span><br><span class=\"line\">    # 如果此服务在规定时间内不断重启, 则设备会重启并进入 bootloader</span><br><span class=\"line\">    critical</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置服务重启后执行的操作</span><br><span class=\"line\">    # 每一个操作都是一个 Commands</span><br><span class=\"line\">    onrestart restart healthd</span><br><span class=\"line\">    onrestart restart zygote</span><br><span class=\"line\">    onrestart restart audioserver</span><br><span class=\"line\">    onrestart restart media</span><br><span class=\"line\">    onrestart restart surfaceflinger</span><br><span class=\"line\">    onrestart restart inputflinger</span><br><span class=\"line\">    onrestart restart drm</span><br><span class=\"line\">    onrestart restart cameraserver</span><br><span class=\"line\">    onrestart restart keystore</span><br><span class=\"line\">    onrestart restart gatekeeperd</span><br><span class=\"line\">    onrestart restart thermalservice</span><br><span class=\"line\"></span><br><span class=\"line\">    # 在进程执行 fork 操作之后，将子进程的 pid 写入文件 &#x2F;dev&#x2F;cpuset&#x2F;system-background&#x2F;tasks</span><br><span class=\"line\">    writepid &#x2F;dev&#x2F;cpuset&#x2F;system-background&#x2F;tasks</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置服务的关闭行为</span><br><span class=\"line\">    # shutdown critical 表示此服务在关闭期间不会被杀死, 当关闭超时后才会被杀死</span><br><span class=\"line\">    shutdown critical</span><br></pre></td></tr></table></figure>\n<p>启动 servicemanager 之后，便会进入 <code>frameworks/native/cmds/servicemanager/service_manager.c</code> 的 main 函数。</p>\n<h6 id=\"2-4-4-1-2-4-启动-zygote\"><a href=\"#2-4-4-1-2-4-启动-zygote\" class=\"headerlink\" title=\"2.4.4.1.2.4 启动 zygote\"></a>2.4.4.1.2.4 启动 zygote</h6><p>在 init.rc 脚本中，事件 <code>zygote-start</code> 有 3 个对应的 <code>Actions</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br><span class=\"line\"></span><br><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unsupported</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br><span class=\"line\"></span><br><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;encrypted &amp;&amp; property:ro.crypto.type&#x3D;file</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br></pre></td></tr></table></figure>\n<p>其中，zygote 通过以下语句导入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#x2F;init.$&#123;ro.zygote&#125;.rc</span><br></pre></td></tr></table></figure>\n<p>此语句会根据属性 <code>ro.zygote</code>，导入相应的文件，其中包括：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote32.rc</span><br><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote32_64.rc</span><br><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote64.rc</span><br><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote64_32.rc</span><br></pre></td></tr></table></figure>\n<p>zygote 的启动除了依赖事件 <code>zygote-start</code> 以外，还需要某些属性满足特定的值。当上面列出的三个 <code>Actions</code> 中的其中一个满足条件后，便会启动 zygote。</p>\n<p>这里分析启动 Zygote 64 位进程的脚本，脚本文件的路径为 <code>system/core/rootdir/init.zygote64.rc</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># zygote 是 Services 的名称</span><br><span class=\"line\"># &#x2F;system&#x2F;bin&#x2F;app_process64 是可执行文件的路径</span><br><span class=\"line\"># -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server 是启动参数</span><br><span class=\"line\">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class=\"line\">    # 指定类名为 main</span><br><span class=\"line\">    # 当 main 开启 (关闭) 时, zygote 也将开启 (关闭)</span><br><span class=\"line\">    class main</span><br><span class=\"line\"></span><br><span class=\"line\">    # 进程优先级为 -20</span><br><span class=\"line\">    # 由于优先级的取值范围是 -20 ~ 19, 数值越小, 优先级越高, 因此 zygote 进程拥有最高的优先级</span><br><span class=\"line\">    priority -20</span><br><span class=\"line\"></span><br><span class=\"line\">    # 用户和用户组都是 root</span><br><span class=\"line\">    user root</span><br><span class=\"line\">    group root readproc reserved_disk</span><br><span class=\"line\"></span><br><span class=\"line\">    # 创建 socket</span><br><span class=\"line\">    socket zygote stream 660 root system</span><br><span class=\"line\">    socket usap_pool_primary stream 660 root system</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置服务重启后执行的操作</span><br><span class=\"line\">    # 每一个操作都是一个 Commands</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class=\"line\">    onrestart restart audioserver</span><br><span class=\"line\">    onrestart restart cameraserver</span><br><span class=\"line\">    onrestart restart media</span><br><span class=\"line\">    onrestart restart netd</span><br><span class=\"line\">    onrestart restart wificond</span><br><span class=\"line\"></span><br><span class=\"line\">    # 在 zygote 进程执行 fork 操作之后，将子进程的 pid 写入文件 &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br><span class=\"line\">    writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br></pre></td></tr></table></figure>\n<p>启动 zygote 之后，便会进入 <code>frameworks/base/cmds/app_process/app_main.cpp</code> 的 main 函数。</p>\n<h3 id=\"2-4-5-进入无限循环状态\"><a href=\"#2-4-5-进入无限循环状态\" class=\"headerlink\" title=\"2.4.5 进入无限循环状态\"></a>2.4.5 进入无限循环状态</h3><p>init 进程启动完成之后，进程就会一直存活，而保持存活的方法就是进入无限循环状态。接下来分析这个过程，源代码的路径为 <code>system/core/init/init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置等待 epoll 事件的超时时长</span></span><br><span class=\"line\">        <span class=\"comment\">// 默认情况下会一直处于阻塞状态, 直到有事件发生, 此时 epoll_timeout 取值为 -1</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> epoll_timeout = <span class=\"built_in\">std</span>::optional&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// am 是一个引用, 指向 ActionManager 实例</span></span><br><span class=\"line\">            <span class=\"comment\">// 按顺序执行 ActionManager 中的一个命令 [2.4.5.1]</span></span><br><span class=\"line\">            am.ExecuteOneCommand();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!shutting_down) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取下一次 HandleProcessActions 的时间点 [2.4.5.2]</span></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> next_process_action_time = HandleProcessActions();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next_process_action_time) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 计算出 next_process_action_time 与当前时间的差值</span></span><br><span class=\"line\">                    epoll_timeout = <span class=\"built_in\">std</span>::chrono::<span class=\"built_in\">ceil</span>&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;(</span><br><span class=\"line\">                            *next_process_action_time - boot_clock::now());</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 如果差值小于 0, 说明需要立即进行下一次的循环</span></span><br><span class=\"line\">                    <span class=\"comment\">// 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (*epoll_timeout &lt; <span class=\"number\">0</span>ms) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果 ActionManager 中仍有待执行的命令, 那么 init 进程不会进入阻塞状态, 并立即再次唤起</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (am.HasMoreCommands()) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 Wait 函数, 等待事件触发 [2.4.1.3]</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Wait(epoll_timeout); !result) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; result.error();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经分析可知，init 进程进入循环状态后主要的工作有 3 个：</p>\n<ul>\n<li>执行 ActionManager 中的命令。</li>\n<li>重启服务。</li>\n<li>等待 epoll 事件，当事件触发后，调用相应的函数进行处理。结合前面的分析，可知等待的事件有：一个进程通过请求 init 进程向属性服务写入属性，以及 init 进程接收到 <code>SIGCHLD</code> 信号。</li>\n</ul>\n<h4 id=\"2-4-5-1-ActionManager\"><a href=\"#2-4-5-1-ActionManager\" class=\"headerlink\" title=\"2.4.5.1 ActionManager\"></a>2.4.5.1 ActionManager</h4><!-- TODO: 什么是 Action? -->\n\n<!-- TODO: Action 和脚本中的 Actions 有没有关系 -->\n\n<!-- TODO: 添加和执行过程 -->\n\n<p>ActionManager 是 Action 的管理器，它提供了对 Action 的添加、执行、清空等操作。</p>\n<h5 id=\"2-4-5-1-1-添加-Action\"><a href=\"#2-4-5-1-1-添加-Action\" class=\"headerlink\" title=\"2.4.5.1.1 添加 Action\"></a>2.4.5.1.1 添加 Action</h5><!-- TODO: 详细分析 Action 的作用 -->\n\n<p>在 init 进程启动的第二阶段中添加了一些 Action，简单看下其中部分 Action 的作用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// am 是一个引用, 指向 ActionManager 实例</span></span><br><span class=\"line\">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueBuiltinAction(SetupCgroupsAction, <span class=\"string\">&quot;SetupCgroups&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 触发事件 early-init [2.4.4.1.2.1]</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;early-init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 等待 coldboot 完成</span></span><br><span class=\"line\">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class=\"string\">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class=\"string\">&quot;MixHwrngIntoLinuxRng&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(SetMmapRndBitsAction, <span class=\"string\">&quot;SetMmapRndBits&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(SetKptrRestrictAction, <span class=\"string\">&quot;SetKptrRestrict&quot;</span>);</span><br><span class=\"line\">    Keychords keychords;</span><br><span class=\"line\">    am.QueueBuiltinAction(</span><br><span class=\"line\">        [&amp;epoll, &amp;keychords](<span class=\"keyword\">const</span> BuiltinArguments&amp; args) -&gt; Result&lt;Success&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; svc : ServiceList::GetInstance()) &#123;</span><br><span class=\"line\">                keychords.Register(svc-&gt;keycodes());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            keychords.Start(&amp;epoll, HandleKeychord);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;KeychordInit&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(console_init_action, <span class=\"string\">&quot;console_init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 触发事件 init [2.4.4.1.2.1]</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueBuiltinAction(StartBoringSslSelfTest, <span class=\"string\">&quot;StartBoringSslSelfTest&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class=\"string\">&quot;MixHwrngIntoLinuxRng&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 为 init 进程初始化 binder</span></span><br><span class=\"line\">    am.QueueBuiltinAction(InitBinder, <span class=\"string\">&quot;InitBinder&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootmode = GetProperty(<span class=\"string\">&quot;ro.bootmode&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootmode == <span class=\"string\">&quot;charger&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在充电模式下, 添加 Action: 触发事件 charger [2.4.4.1.2.1]</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;charger&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 否则, 添加 Action: 触发事件 late-init [2.4.4.1.2.1]</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;late-init&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 触发当前所有的属性触发器</span></span><br><span class=\"line\">    am.QueueBuiltinAction(queue_property_triggers_action, <span class=\"string\">&quot;queue_property_triggers&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，在解析脚本或者属性值改变的时候，也会使用 ActionManager 添加 Action。</p>\n<h4 id=\"2-4-5-2-HandleProcessActions\"><a href=\"#2-4-5-2-HandleProcessActions\" class=\"headerlink\" title=\"2.4.5.2 HandleProcessActions\"></a>2.4.5.2 HandleProcessActions</h4><!-- ((s->flags() & SVC_RUNNING) && s->timeout_period()) -->\n\n<!-- 详细分析 service 的重启过程 -->\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"built_in\">std</span>::optional&lt;boot_clock::time_point&gt; <span class=\"title\">HandleProcessActions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::optional&lt;boot_clock::time_point&gt; next_process_action_time;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历 ServiceList</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; s : ServiceList::GetInstance()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断服务是否处于运行中状态, 以及是否有超时时长</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((s-&gt;flags() &amp; SVC_RUNNING) &amp;&amp; s-&gt;timeout_period()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算出服务启动的超时时间</span></span><br><span class=\"line\">            <span class=\"keyword\">auto</span> timeout_time = s-&gt;time_started() + *s-&gt;timeout_period();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (boot_clock::now() &gt; timeout_time) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果当前时间已大于服务启动的超时时间, 说明服务启动已超时</span></span><br><span class=\"line\">                s-&gt;Timeout();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 更新 next_process_action_time</span></span><br><span class=\"line\">                <span class=\"comment\">// 此时, next_process_action_time 表示最近的, 需要检查服务是否启动成功的时间点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!next_process_action_time || timeout_time &lt; *next_process_action_time) &#123;</span><br><span class=\"line\">                    next_process_action_time = timeout_time;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果服务不带有标志位 SVC_RESTARTING, 则不需要重启, 继续 for 循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(s-&gt;flags() &amp; SVC_RESTARTING)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算出服务启动的超时时间</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> restart_time = s-&gt;time_started() + s-&gt;restart_period();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 现在服务需要重启, 接下来重启已满足重启条件的服务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (boot_clock::now() &gt; restart_time) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前时间已大于服务的重启时间, 那么立即启动服务</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = s-&gt;Start(); !result) &#123;</span><br><span class=\"line\">                LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Could not restart process &#x27;&quot;</span> &lt;&lt; s-&gt;name() &lt;&lt; <span class=\"string\">&quot;&#x27;: &quot;</span> &lt;&lt; result.error();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 更新 next_process_action_time</span></span><br><span class=\"line\">            <span class=\"comment\">// 此时, next_process_action_time 表示最近的, 需要对服务进行重启操作的时间点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!next_process_action_time || restart_time &lt; *next_process_action_time) &#123;</span><br><span class=\"line\">                next_process_action_time = restart_time;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next_process_action_time;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数的工作有：</p>\n<ol>\n<li>检查带有标志位 <code>SVC_RUNNING</code> 的服务是否超时，如果服务启动超时，则调用 <code>Timeout</code> 函数，否则更新下次检查的时间点。</li>\n<li>当服务带有标志位 <code>SVC_RESTARTING</code> 时，说明服务需要重启。如果当前时间已大于服务的重启时间，则立即重启服务；否则，更新下次重启的时间点。 </li>\n</ol>\n<p>经分析可知，<code>next_process_action_time</code> 可能表示下一次的检查服务是否启动超时的时间点，也可能表示下一次为某个服务重启的时间点。</p>\n<p>注意到，在之前的分析信号 [2.4.3.1.4.3] 提到过，当 init 收到子进程终结的信号之后，会为有重启需要的服务添加标志位 <code>SVC_RESTARTING</code>。那么现在可以知道，在 init 进程进入无限循环状态后，就会处理这些带有标志位 <code>SVC_RESTARTING</code> 的服务，重启满足条件的服务。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://gityuan.com/2016/02/01/android-booting/\">Android系统启动-综述</a></p>\n<p><a href=\"http://gityuan.com/2016/02/05/android-init/\">Android系统启动-Init篇</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man7/epoll.7.html\">epoll(7)</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Signal_(IPC)\">Signal</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man7/signal.7.html\">signal(7)</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man2/wait.2.html\">wait(2)</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man2/signalfd.2.html\">signalfd(2)</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文基于源代码：android-security-10.0.0_r56</p>\n</blockquote>\n<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><!-- TODO: 关于 init 进程更好的概述 -->\n\n<p>Android 基于 Linux 内核，在内核启动过程中会创建出 init 进程。</p>\n<p>init 进程是用户空间的第一个进程，进程的 pid = 1。</p>","more":"<h1 id=\"2-启动流程\"><a href=\"#2-启动流程\" class=\"headerlink\" title=\"2. 启动流程\"></a>2. 启动流程</h1><!-- TODO: 总结 -->\n\n\n\n<h2 id=\"2-1-init-进程的入口\"><a href=\"#2-1-init-进程的入口\" class=\"headerlink\" title=\"2.1 init 进程的入口\"></a>2.1 init 进程的入口</h2><!-- TODO: 为什么是入口？ -->\n\n<!-- TODO: init 就是一个普通的命令行程序, 位置在 /system/core/init？ -->\n\n<p>在 Android 9，init 进程的入口位于 <code>system/core/init/init.cpp</code> 中的 main 函数。</p>\n<p>在 Android 10 之后，init 进程的入口改到了 <code>system/core/init/main.cpp</code> 中的 main 函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(basename(argv[<span class=\"number\">0</span>]), <span class=\"string\">&quot;ueventd&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ueventd_main(argc, argv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;subcontext&quot;</span>)) &#123;</span><br><span class=\"line\">            android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class=\"line\">            <span class=\"keyword\">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> SubcontextMain(argc, argv, &amp;function_map);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;selinux_setup&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SetupSelinux(argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;second_stage&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SecondStageMain(argc, argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> FirstStageMain(argc, argv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先来了解其中使用到的两个库函数：<code>basename</code> 函数和 <code>strcmp</code> 函数。</p>\n<ul>\n<li><code>basename</code> 的函数原型为 <code>char* basename(char* __path)</code>，可以根据给定的一个路径，返回文件名。例如：传入参数 “/system/bin/ueventd”，函数会返回 “ueventd”。</li>\n<li><code>strcmp</code> 的函数原型为 <code>int strcmp(const char* __lhs, const char* __rhs)</code>，是一个字符串比较函数，返回值为整数。当两个字符串相等时，函数返回 0。</li>\n</ul>\n<p>再来分析 main 函数：函数的主要工作是根据参数 <code>argc</code> 和 <code>argv</code>，选择对应的执行方式。如果参数未匹配成功，则默认调用 <code>FirstStageMain</code> 函数。</p>\n<h2 id=\"2-2-启动的第一阶段\"><a href=\"#2-2-启动的第一阶段\" class=\"headerlink\" title=\"2.2 启动的第一阶段\"></a>2.2 启动的第一阶段</h2><!-- TODO: mkdir, mknod, tmpfs -->\n\n<!-- TODO: 所挂载的文件系统的用处 -->\n\n<!-- TODO: KernelLogging(/dev/kmsg) -->\n\n<!-- TODO: InstallRebootSignalHandlers -->\n\n<p>调用 <code>int FirstStageMain(int argc, char** argv)</code> 进入启动的第一阶段，函数所在文件的路径为 <code>system/core/init/first_stage_init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FirstStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(clearenv());</span><br><span class=\"line\">    CHECKCALL(setenv(<span class=\"string\">&quot;PATH&quot;</span>, _PATH_DEFPATH, <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"comment\">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class=\"line\">    <span class=\"comment\">// on / and then we&#x27;ll let the rc file figure out the rest.</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/dev&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class=\"string\">&quot;mode=0755&quot;</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/pts&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/socket&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/dev/dm-user&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;devpts&quot;</span>, <span class=\"string\">&quot;/dev/pts&quot;</span>, <span class=\"string\">&quot;devpts&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;proc&quot;</span>, <span class=\"string\">&quot;/proc&quot;</span>, <span class=\"string\">&quot;proc&quot;</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;hidepid=2,gid=&quot;</span> MAKE_STR(AID_READPROC)));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> MAKE_STR</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t expose the raw commandline to unprivileged processes.</span></span><br><span class=\"line\">    <span class=\"comment\">// 设置文件权限 [2.2.1]</span></span><br><span class=\"line\">    CHECKCALL(chmod(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, <span class=\"number\">0440</span>));</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> cmdline;</span><br><span class=\"line\">    android::base::ReadFileToString(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, &amp;cmdline);</span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t expose the raw bootconfig to unprivileged processes.</span></span><br><span class=\"line\">    chmod(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, <span class=\"number\">0440</span>);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootconfig;</span><br><span class=\"line\">    android::base::ReadFileToString(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, &amp;bootconfig);</span><br><span class=\"line\">    <span class=\"keyword\">gid_t</span> groups[] = &#123;AID_READPROC&#125;;</span><br><span class=\"line\">    CHECKCALL(setgroups(arraysize(groups), groups));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;sysfs&quot;</span>, <span class=\"string\">&quot;/sys&quot;</span>, <span class=\"string\">&quot;sysfs&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;selinuxfs&quot;</span>, <span class=\"string\">&quot;/sys/fs/selinux&quot;</span>, <span class=\"string\">&quot;selinuxfs&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/kmsg&quot;</span>, S_IFCHR | <span class=\"number\">0600</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">11</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">if</span> <span class=\"title\">constexpr</span> <span class=\"params\">(WORLD_WRITABLE_KMSG)</span> </span>&#123;</span><br><span class=\"line\">        CHECKCALL(mknod(<span class=\"string\">&quot;/dev/kmsg_debug&quot;</span>, S_IFCHR | <span class=\"number\">0622</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">11</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/random&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">8</span>)));</span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/urandom&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">9</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This is needed for log wrapper, which gets called before ueventd runs.</span></span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/ptmx&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">5</span>, <span class=\"number\">2</span>)));</span><br><span class=\"line\">    CHECKCALL(mknod(<span class=\"string\">&quot;/dev/null&quot;</span>, S_IFCHR | <span class=\"number\">0666</span>, makedev(<span class=\"number\">1</span>, <span class=\"number\">3</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// These below mounts are done in first stage init so that first stage mount can mount</span></span><br><span class=\"line\">    <span class=\"comment\">// subdirectories of /mnt/&#123;vendor,product&#125;/.  Other mounts, not required by first stage mount,</span></span><br><span class=\"line\">    <span class=\"comment\">// should be done in rc files.</span></span><br><span class=\"line\">    <span class=\"comment\">// Mount staging areas for devices managed by vold</span></span><br><span class=\"line\">    <span class=\"comment\">// See storage config details at http://source.android.com/devices/storage/</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/mnt&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=1000&quot;</span>));</span><br><span class=\"line\">    <span class=\"comment\">// /mnt/vendor is used to mount vendor-specific partitions that can not be</span></span><br><span class=\"line\">    <span class=\"comment\">// part of the vendor partition, e.g. because they are mounted read-write.</span></span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/mnt/vendor&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\">    <span class=\"comment\">// /mnt/product is used to mount product-specific partitions that can not be</span></span><br><span class=\"line\">    <span class=\"comment\">// part of the product partition, e.g. because they are mounted read-write.</span></span><br><span class=\"line\">    CHECKCALL(mkdir(<span class=\"string\">&quot;/mnt/product&quot;</span>, <span class=\"number\">0755</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /debug_ramdisk is used to preserve additional files from the debug ramdisk</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, <span class=\"string\">&quot;/debug_ramdisk&quot;</span>, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=0&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /second_stage_resources is used to preserve files from first to second</span></span><br><span class=\"line\">    <span class=\"comment\">// stage init</span></span><br><span class=\"line\">    CHECKCALL(mount(<span class=\"string\">&quot;tmpfs&quot;</span>, kSecondStageRes, <span class=\"string\">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class=\"line\">                    <span class=\"string\">&quot;mode=0755,uid=0,gid=0&quot;</span>))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> CHECKCALL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    SetStdioToDevNull(argv);</span><br><span class=\"line\">    <span class=\"comment\">// Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually</span></span><br><span class=\"line\">    <span class=\"comment\">// talk to the outside world...</span></span><br><span class=\"line\">    InitKernelLogging(argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!errors.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; [error_string, error_errno] : errors) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; error_string &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; strerror(error_errno);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;Init encountered errors starting first stage, aborting&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG(INFO) &lt;&lt; <span class=\"string\">&quot;init first stage started!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 /system/bin/init</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到传入的参数是 selinux_setup, 因此接下来会调用 SetupSelinux 函数进行 SELinux 的初始化 [2.3]</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;selinux_setup&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> fd = open(<span class=\"string\">&quot;/dev/kmsg&quot;</span>, O_WRONLY | O_CLOEXEC);</span><br><span class=\"line\">    dup2(fd, STDOUT_FILENO);</span><br><span class=\"line\">    dup2(fd, STDERR_FILENO);</span><br><span class=\"line\">    close(fd);</span><br><span class=\"line\">    execv(path, <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">char</span>**&gt;(args));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// execv() only returns if an error happened, in which case we</span></span><br><span class=\"line\">    <span class=\"comment\">// panic and never fall through this conditional.</span></span><br><span class=\"line\">    PLOG(FATAL) &lt;&lt; <span class=\"string\">&quot;execv(\\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class=\"string\">&quot;\\&quot;) failed&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数主要工作是挂载一些文件系统，然后执行 <code>/system/bin/init</code>，重新进入 main 函数，通过传入参数 <code>&quot;selinux_setup&quot;</code>，进而调用 SetupSelinux 函数，进行 SELinux 的初始化。</p>\n<h3 id=\"2-2-1-设置文件或目录的权限\"><a href=\"#2-2-1-设置文件或目录的权限\" class=\"headerlink\" title=\"2.2.1 设置文件或目录的权限\"></a>2.2.1 设置文件或目录的权限</h3><p>在 Linux 系统上，<code>chmod</code> 命令用于控制用户对文件或者目录的权限，但只有文件所有者和超级用户可以修改文件或目录的权限。</p>\n<p>权限分为三类：读，写，执行。</p>\n<h4 id=\"2-2-1-1-符号表示法\"><a href=\"#2-2-1-1-符号表示法\" class=\"headerlink\" title=\"2.2.1.1 符号表示法\"></a>2.2.1.1 符号表示法</h4><p>符号表示法用 10 位字符表示权限，其形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rwxrwxrwx</span><br></pre></td></tr></table></figure>\n<p>其中第一个字符表示文件类型，常见的符号有：</p>\n<ul>\n<li><code>-</code>，表示普通文件。</li>\n<li><code>d</code>，表示目录。</li>\n<li><code>c</code>，表示字符特殊文件。</li>\n</ul>\n<p>剩余的 9 个字符，每 3 个字符分为一组，分别表示文件所有者，用户组，其他用户的权限。</p>\n<p>3 个字符组成的字符串，第 1 位控制读权限，第 2 位控制写权限，第 3 位控制执行权限：</p>\n<ul>\n<li>如果拥有读权限，第 1 位字符为 <code>r</code>，否则为 <code>-</code>。</li>\n<li>如果拥有写权限，第 2 位字符为 <code>w</code>，否则为 <code>-</code>。</li>\n<li>如果拥有执行权限，第 3 位字符为 <code>x</code>，否则为 <code>-</code>。</li>\n</ul>\n<p>示例：<code>-rwxrw-r--</code> 表示一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。</p>\n<h4 id=\"2-2-1-2-数字表示法\"><a href=\"#2-2-1-2-数字表示法\" class=\"headerlink\" title=\"2.2.1.2 数字表示法\"></a>2.2.1.2 数字表示法</h4><p>可以用 4 位八进制数字表示权限，第 1 位同样表示文件类型，剩余的 3 位数字，分别表示文件所有者，用户组，其他用户的权限。</p>\n<p>读，写，执行，这 3 类权限可以使用 3 位二进制数字表示，不同类型的权限单独对应二进制数字中一个位：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数值</th>\n<th align=\"center\">权限</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">二进制：100，八进制：4</td>\n<td align=\"center\">r</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：010，八进制：2</td>\n<td align=\"center\">w</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：001，八进制：1</td>\n<td align=\"center\">x</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：000，八进制：0</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p>在各类权限对应的数值之和，可以代表一组特定的权限。由于和的数值范围为 0~7，因此可以通过一个八进制数字表示。示例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数值</th>\n<th align=\"center\">权限</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">二进制：111，八进制：7</td>\n<td align=\"center\">rwx</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：110，八进制：6</td>\n<td align=\"center\">rw-</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：101，八进制：5</td>\n<td align=\"center\">r-x</td>\n</tr>\n<tr>\n<td align=\"center\">二进制：000，八进制：0</td>\n<td align=\"center\">—</td>\n</tr>\n</tbody></table>\n<p>因此，用符号表示法表示的权限，同样可以使用数字表示法来表示，示例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号表示法</th>\n<th align=\"center\">数字表示法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-rwxrwxrwx</td>\n<td align=\"center\">0777</td>\n<td align=\"center\">一个普通文件，文件所有者，用户组，其他用户都有读，写，执行的权限</td>\n</tr>\n<tr>\n<td align=\"center\">-rwxrw-r–</td>\n<td align=\"center\">0764</td>\n<td align=\"center\">一个普通文件，文件所有者拥有读，写和执行权限，用户组拥有读和写权限，其他用户只有读权限。</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-2-1-3-分析源码中的权限设置\"><a href=\"#2-2-1-3-分析源码中的权限设置\" class=\"headerlink\" title=\"2.2.1.3 分析源码中的权限设置\"></a>2.2.1.3 分析源码中的权限设置</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Don&#x27;t expose the raw commandline to unprivileged processes.</span></span><br><span class=\"line\">CHECKCALL(chmod(<span class=\"string\">&quot;/proc/cmdline&quot;</span>, <span class=\"number\">0440</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Don&#x27;t expose the raw bootconfig to unprivileged processes.</span></span><br><span class=\"line\">chmod(<span class=\"string\">&quot;/proc/bootconfig&quot;</span>, <span class=\"number\">0440</span>);</span><br></pre></td></tr></table></figure>\n<p>在源码中有两处使用到 <code>chmod</code> 命令，分别对文件 <code>/proc/cmdline</code>，<code>/proc/bootconfig</code> 设置了权限 <code>0440</code>，表明 root 用户 (文件所有者) 及其用户组也只有文件的读权限。</p>\n<h2 id=\"2-3-初始化-SELinux\"><a href=\"#2-3-初始化-SELinux\" class=\"headerlink\" title=\"2.3 初始化 SELinux\"></a>2.3 初始化 SELinux</h2><!-- TODO: 分析 SELinux -->\n\n<p>调用 <code>int SetupSelinux(char** argv)</code> 进行 SELinux 的初始化，该函数所在文件的路径为 <code>system/core/init/selinux.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This function initializes SELinux then execs init to run in the init SELinux context.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SetupSelinux</span><span class=\"params\">(<span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set up SELinux, loading the SELinux policy.</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 SELinux</span></span><br><span class=\"line\">    SelinuxSetupKernelLogging();</span><br><span class=\"line\">    SelinuxInitialize();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 /system/bin/init</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到传入的参数是 second_stage, 因此接下来会调用 SecondStageMain 函数进入启动的第二阶段 [2.4]</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;second_stage&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    execv(path, <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">char</span>**&gt;(args));</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数首先初始化了 SELinux，然后执行 <code>/system/bin/init</code>，重新进入 main 函数，通过传入参数 <code>&quot;second_stage&quot;</code>，进而调用 SecondStageMain 函数，进入启动的第二阶段。</p>\n<h2 id=\"2-4-启动的第二阶段\"><a href=\"#2-4-启动的第二阶段\" class=\"headerlink\" title=\"2.4 启动的第二阶段\"></a>2.4 启动的第二阶段</h2><!-- TODO: property_load_boot_defaults -->\n\n<!-- TODO: 在编译的过程中, android 的各种系统参数会被汇总到 build.prop 文件中？ -->\n\n<!-- TODO: SELinux 相关代码的分析 -->\n\n<!-- TODO: keyctl_get_keyring_ID(KEY_SPEC_SESSION_KEYRING, 1) -->\n\n<!-- TODO: InitializeSubcontext() -->\n\n<!-- TODO: ActionManager 和 ServiceList 的作用 -->\n\n<p>调用 <code>int SecondStageMain(int argc, char** argv)</code> 进入启动的第二阶段，函数所在文件的路径为 <code>system/core/init/init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set init and its forked children&#x27;s oom_adj.</span></span><br><span class=\"line\">    <span class=\"comment\">// 设置 init 进程以及由其 fork 得到的子进程 oom_score_adj 的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 数值越小, 进程优先级越高</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = WriteFile(<span class=\"string\">&quot;/proc/1/oom_score_adj&quot;</span>, <span class=\"string\">&quot;-1000&quot;</span>); !result) &#123;</span><br><span class=\"line\">        LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Unable to write -1000 to /proc/1/oom_score_adj: &quot;</span> &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化属性服务 [2.4.2.1]</span></span><br><span class=\"line\">    property_init();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 epoll [2.4.1.1]</span></span><br><span class=\"line\">    Epoll epoll;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Open(); !result) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用 epoll 对 init 子进程的信号进行监听 [2.4.3.1.3]</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化子进程退出的信号处理函数</span></span><br><span class=\"line\">    InstallSignalFdHandler(&amp;epoll);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 开启属性服务 [2.4.2.2]</span></span><br><span class=\"line\">    StartPropertyService(&amp;epoll);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class=\"line\">    ServiceList&amp; sm = ServiceList::GetInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 加载启动脚本 [2.4.4]</span></span><br><span class=\"line\">    LoadBootScripts(am, sm);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action [2.4.5.1]</span></span><br><span class=\"line\">    am.QueueBuiltinAction(SetupCgroupsAction, <span class=\"string\">&quot;SetupCgroups&quot;</span>);</span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;early-init&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class=\"string\">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    am.QueueBuiltinAction(queue_property_triggers_action, <span class=\"string\">&quot;queue_property_triggers&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进入无限循环状态 [2.4.5]</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> epoll_timeout = <span class=\"built_in\">std</span>::optional&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (do_shutdown &amp;&amp; !shutting_down) &#123;</span><br><span class=\"line\">            do_shutdown = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (HandlePowerctlMessage(shutdown_command)) &#123;</span><br><span class=\"line\">                shutting_down = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            am.ExecuteOneCommand();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!shutting_down) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> next_process_action_time = HandleProcessActions();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next_process_action_time) &#123;</span><br><span class=\"line\">                    epoll_timeout = <span class=\"built_in\">std</span>::chrono::<span class=\"built_in\">ceil</span>&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;(</span><br><span class=\"line\">                            *next_process_action_time - boot_clock::now());</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (*epoll_timeout &lt; <span class=\"number\">0</span>ms) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (am.HasMoreCommands()) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Wait(epoll_timeout); !result) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; result.error();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二阶段的工作可以大致分为 5 个部分：</p>\n<ul>\n<li><p>epoll</p>\n</li>\n<li><p>属性服务</p>\n</li>\n<li><p>信号</p>\n</li>\n<li><p>加载启动脚本</p>\n</li>\n<li><p>进入无限循环状态</p>\n</li>\n</ul>\n<p>接下来将分别对这 5 个部分的工作进行分析。</p>\n<h3 id=\"2-4-1-epoll\"><a href=\"#2-4-1-epoll\" class=\"headerlink\" title=\"2.4.1 epoll\"></a>2.4.1 epoll</h3><p>epoll 是 Linux 提供的 I/O 事件通知机制。epoll 可以监听大量的文件描述符，检查其中某一个文件描述符是否进入就绪状态。</p>\n<h4 id=\"2-4-1-1-初始化\"><a href=\"#2-4-1-1-初始化\" class=\"headerlink\" title=\"2.4.1.1 初始化\"></a>2.4.1.1 初始化</h4><p>在 init 进程中，epoll 通过以下代码初始化：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Epoll epoll;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Open(); !result) &#123;</span><br><span class=\"line\">    PLOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以知道，epoll 实例是通过调用 Open 函数创建的，函数所在文件的路径为 <code>system/core/init/epoll.cpp</code>，来分析这个函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::Open</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_fd_ &gt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关键点</span></span><br><span class=\"line\">    epoll_fd_.reset(epoll_create1(EPOLL_CLOEXEC));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_fd_ == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ErrnoError() &lt;&lt; <span class=\"string\">&quot;epoll_create1 failed&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数的关键点在于调用 <code>epoll_create1</code>。<code>epoll_create1</code> 是一个系统调用，其新建了一个 epoll 实例并返回该实例文件描述符。</p>\n<h4 id=\"2-4-1-2-使用-epoll-监听文件描述符\"><a href=\"#2-4-1-2-使用-epoll-监听文件描述符\" class=\"headerlink\" title=\"2.4.1.2 使用 epoll 监听文件描述符\"></a>2.4.1.2 使用 epoll 监听文件描述符</h4><p>要使用 epoll 监听文件描述符，需要调用 RegisterHandler 函数，将文件描述符注册到 epoll。</p>\n<p>函数所在文件的路径为 <code>system/core/init/epoll.cpp</code>，此函数的关键点在于系统调用 epoll_ctl：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::RegisterHandler</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; handler, <span class=\"keyword\">uint32_t</span> events)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关键点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &amp;ev) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先来看下 epoll_ctl 这个系统调用。</p>\n<h5 id=\"2-4-1-2-1-系统调用-epoll-ctl\"><a href=\"#2-4-1-2-1-系统调用-epoll-ctl\" class=\"headerlink\" title=\"2.4.1.2.1 系统调用 epoll_ctl\"></a>2.4.1.2.1 系统调用 epoll_ctl</h5><p><strong>epoll_ctl</strong> 是一个系统调用，函数原型为 <code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code>，用于对指定的文件描述符 fd 进行添加、修改或者删除操作。</p>\n<h6 id=\"2-4-1-2-1-1-参数\"><a href=\"#2-4-1-2-1-1-参数\" class=\"headerlink\" title=\"2.4.1.2.1.1 参数\"></a>2.4.1.2.1.1 参数</h6><p>首先来理解 epoll_ctl 的参数：</p>\n<ul>\n<li><p><strong>epfd</strong> 是 epoll 实例的文件描述符。</p>\n</li>\n<li><p><strong>op</strong> 表示要执行的操作，有三种取值：</p>\n<ul>\n<li><p><strong>EPOLL_CTL_ADD</strong></p>\n<p>添加指定的文件描述符到 epoll 的监控列表。</p>\n</li>\n<li><p><strong>EPOLL_CTL_MOD</strong></p>\n<p>修改 epoll 的监控列表中指定的文件描述符。</p>\n</li>\n<li><p><strong>EPOLL_CTL_DEL</strong></p>\n<p>从 epoll 的监控列表中删除指定的文件描述符。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>fd</strong> 表示指定的文件描述符。</p>\n</li>\n<li><p><strong>event</strong> 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，其定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">uint32_t</span>     events;      <span class=\"comment\">/* Epoll events */</span></span><br><span class=\"line\">   <span class=\"keyword\">epoll_data_t</span> data;        <span class=\"comment\">/* User data variable */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>结构体成员 <code>events</code> 用于表示要监听的事件，可以由零个或者多个事件类型组成，下面列出部分常见的事件类型：</p>\n<ul>\n<li><p>\u0015\u0015<strong>EPOLLIN</strong><br>表示关联的文件描述符可用于读操作。</p>\n</li>\n<li><p><strong>EPOLLOUT</strong><br>表示关联的文件描述符可用于写操作。</p>\n</li>\n<li><p><strong>EPOLLPRI</strong><br>表示关联的文件描述符出现异常情况。</p>\n</li>\n<li><p><strong>EPOLLERR</strong><br>表示关联的文件描述符出现错误。</p>\n</li>\n<li><p><strong>EPOLLHUP</strong><br>表示关联的文件描述符被挂断。</p>\n</li>\n<li><p><strong>EPOLLONESHOT</strong><br>表示只监听文件描述符的一次事件。当事件触发之后，epoll 就会禁用此文件描述符。<br>如果想要继续监听该文件描述符的事件，需要再次调用 epoll_ctl，并执行 EPOLL_CTL_MOD 操作。</p>\n</li>\n</ul>\n<p>结构体成员 <code>data</code> 的作用是将其数据交给内核保存，当文件描述符就绪后，内核会返回保存的数据 [2.4.1.3]。<code>epoll_data_t</code> 是一个共用体，其定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">epoll_data</span> &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span>        *ptr;</span><br><span class=\"line\">   <span class=\"keyword\">int</span>          fd;</span><br><span class=\"line\">   <span class=\"keyword\">uint32_t</span>     u32;</span><br><span class=\"line\">   <span class=\"keyword\">uint64_t</span>     u64;</span><br><span class=\"line\">&#125; <span class=\"keyword\">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h6 id=\"2-4-1-2-1-2-返回值\"><a href=\"#2-4-1-2-1-2-返回值\" class=\"headerlink\" title=\"2.4.1.2.1.2 返回值\"></a>2.4.1.2.1.2 返回值</h6><p>最后来了解 epoll_ctl 的返回值：</p>\n<ul>\n<li><p>当操作成功时，返回值为 0。</p>\n</li>\n<li><p>当发生错误时，返回值为 -1。</p>\n</li>\n</ul>\n<h5 id=\"2-4-1-2-2-分析-RegisterHandler-函数\"><a href=\"#2-4-1-2-2-分析-RegisterHandler-函数\" class=\"headerlink\" title=\"2.4.1.2.2 分析 RegisterHandler 函数\"></a>2.4.1.2.2 分析 RegisterHandler 函数</h5><p>在了解过系统调用 epoll_ctl 以后，现在开始分析 RegisterHandler 函数。首先来看函数在头文件中的声明，头文件的路径为 <code>system/core/init/epoll.h</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Epoll</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Result&lt;Success&gt; <span class=\"title\">RegisterHandler</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; handler,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                    <span class=\"keyword\">uint32_t</span> events = EPOLLIN)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>由函数原型可知，函数的第三个参数 <code>events</code> 有默认值 <code>EPOLLIN</code>，表示监听文件描述符的读操作是否可用。</p>\n<p>接下来分析 RegisterHandler 函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::RegisterHandler</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; handler, <span class=\"keyword\">uint32_t</span> events)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// handler 是事件触发时的回调函数</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> [it, inserted] = epoll_handlers_.emplace(fd, <span class=\"built_in\">std</span>::move(handler));</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    epoll_event ev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置要监听的事件类型</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于 events 有默认值 EPOLLIN, 因此默认监听的事件类型是读操作是否可用</span></span><br><span class=\"line\">    ev.events = events;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 设置回调函数, 回调函数会在事件触发后被调用 [2.4.1.3.2]</span></span><br><span class=\"line\">    ev.data.ptr = <span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"keyword\">void</span>*&gt;(&amp;it-&gt;second);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发起 epoll_ctl 系统调用</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到第二个参数传入的是 EPOLL_CTL_ADD, 因此对指定文件描述符执行的是添加操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &amp;ev) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        Result&lt;Success&gt; result = ErrnoError() &lt;&lt; <span class=\"string\">&quot;epoll_ctl failed to add fd&quot;</span>;</span><br><span class=\"line\">        epoll_handlers_.erase(fd);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过分析，可以知道函数的主要工作是：设置文件描述符需要监听的事件类型 <code>events</code> 以及事件触发时的回调函数 <code>handler</code>，最后发起 <code>epoll_ctl</code> 系统调用，将文件描述符添加到 epoll 监控列表。</p>\n<h4 id=\"2-4-1-3-等待事件触发\"><a href=\"#2-4-1-3-等待事件触发\" class=\"headerlink\" title=\"2.4.1.3 等待事件触发\"></a>2.4.1.3 等待事件触发</h4><p>经过 epoll 的初始化以及将文件描述符注册到 epoll 之后，接下来就需要等待事件触发，然后处理事件。</p>\n<p>在 init 进程启动的第二阶段，最后一个步骤就是进入死循环，不断地等待事件触发。接下来看下这段逻辑：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 关键点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Wait(epoll_timeout); !result) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; result.error();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段逻辑的关键点在于 Wait 函数，接下来分析这个函数。</p>\n<h5 id=\"2-4-1-3-1-系统调用-epoll-wait\"><a href=\"#2-4-1-3-1-系统调用-epoll-wait\" class=\"headerlink\" title=\"2.4.1.3.1 系统调用 epoll_wait\"></a>2.4.1.3.1 系统调用 epoll_wait</h5><p>在分析 Wait 函数之前，首先要了解系统调用 epoll_wait，这个系统调用是 Wait 函数的关键点。</p>\n<p><strong>epoll_wait</strong> 是一个系统调用，函数原型为 <code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code>，用于等待 epoll 上的事件。</p>\n<p>调用 epoll_wait 便会进入阻塞状态，直至满足以下任一条件，调用才会返回：</p>\n<ul>\n<li>监听的文件描述符传递一个事件；</li>\n<li>调用被信号处理程序中断；</li>\n<li>等待超出超时时长。</li>\n</ul>\n<h6 id=\"2-4-1-3-1-1-参数\"><a href=\"#2-4-1-3-1-1-参数\" class=\"headerlink\" title=\"2.4.1.3.1.1 参数\"></a>2.4.1.3.1.1 参数</h6><p>首先来理解 epoll_wait 的参数：</p>\n<ul>\n<li><p><strong>epfd</strong> 是 epoll 实例的文件描述符。</p>\n</li>\n<li><p><strong>events</strong> 是一个 epoll_event 类型的指针，而 epoll_event 是一个结构体，在 [2.4.1.2.1] 一节已经详细介绍过。</p>\n<p>当事件触发后，调用就会返回，此时可以从 events 中得到已触发事件的集合。集合中每一个事件结构体 epoll_event 的 data 字段和调用 epoll_ctl 为相应的文件描述符设置的 data 字段是相同的。意味着，当事件触发后，之前调用 epoll_ctl 给指定文件描述符设置的 event.data 会通过这个参数返回给 epoll_wait 的调用者。</p>\n</li>\n<li><p><strong>maxevents</strong> 表示在一次调用中返回事件的最大数量。因此，从参数 events 中得到的事件数量不会大于 maxevents。</p>\n</li>\n<li><p><strong>timeout</strong> 是此次调用的超时时长。当 timeout = -1 时，调用将会一直阻塞，直到有事件发生；当 timeout = 0 时，调用会立即返回，即使当前没有事件发生。</p>\n</li>\n</ul>\n<h6 id=\"2-4-1-3-1-2-返回值\"><a href=\"#2-4-1-3-1-2-返回值\" class=\"headerlink\" title=\"2.4.1.3.1.2 返回值\"></a>2.4.1.3.1.2 返回值</h6><p>最后来了解 epoll_wait 的返回值：</p>\n<ul>\n<li><p>当调用成功时，返回值为已就绪的文件描述符的数量，此时可以对这些文件描述符进行 I/O 操作。</p>\n<p>需要注意的是，如果该调用是因为超出等待时长而返回的，则返回值为 0，表明没有已就绪的文件描述符。</p>\n</li>\n<li><p>当调用失败时，返回值为 -1，并返回错误信息。</p>\n</li>\n</ul>\n<h5 id=\"2-4-1-3-2-分析-Wait-函数\"><a href=\"#2-4-1-3-2-分析-Wait-函数\" class=\"headerlink\" title=\"2.4.1.3.2 分析 Wait 函数\"></a>2.4.1.3.2 分析 Wait 函数</h5><p>在了解过系统调用 epoll_wait 以后，就可以开始分析 Wait 函数，函数所在文件的路径为 <code>system/core/init/epoll.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Result&lt;Success&gt; <span class=\"title\">Epoll::Wait</span><span class=\"params\">(<span class=\"built_in\">std</span>::optional&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt; timeout)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 超时时长默认值为 -1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> timeout_ms = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeout &amp;&amp; timeout-&gt;count() &lt; INT_MAX) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当参数 timeout 满足不等于 0 和数值没有溢出时, 更新超时时长</span></span><br><span class=\"line\">        timeout_ms = timeout-&gt;count();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    epoll_event ev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发起 epoll_wait 系统调用</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到第三个参数传入的是 1, 表明每次调用最多返回 1 个事件</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd_, &amp;ev, <span class=\"number\">1</span>, timeout_ms));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nr == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用返回 -1, 表明此次调用失败</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ErrnoError() &lt;&lt; <span class=\"string\">&quot;epoll_wait failed&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nr == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用返回 1, 表明此次调用成功, 有 1 个事件触发</span></span><br><span class=\"line\">        <span class=\"comment\">// ev.data.ptr 是之前调用 epoll_ctl 给指定文件描述符设置的回调函数, 因此事件最后交给回调函数进行处理</span></span><br><span class=\"line\">        <span class=\"built_in\">std</span>::invoke(*<span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt;*&gt;(ev.data.ptr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数设置了超时时长，然后发起 <code>epoll_wait</code> 系统调用，等待事件触发。当 <code>epoll_wait</code> 成功返回时，会从返回的数据里面取出之前通过 epoll_ctl 设置的回调函数，将事件交由回调函数处理。</p>\n<h3 id=\"2-4-2-属性服务\"><a href=\"#2-4-2-属性服务\" class=\"headerlink\" title=\"2.4.2 属性服务\"></a>2.4.2 属性服务</h3><p>属性服务是 Android 提供的一个用于存取系统属性的服务，属性以 key-value 的形式存储在一块共享内存，所有进程都可以通过这个服务获取和设置属性。</p>\n<p>使用 adb，输入命令 <code>getprop</code>，可以查看一台设备上的属性，下面列举其中的一些输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ro.product.brand]: [Redmi]</span><br><span class=\"line\">[ro.product.manufacturer]: [Xiaomi]</span><br><span class=\"line\">[ro.product.marketname]: [Redmi K30S Ultra]</span><br><span class=\"line\">[ro.product.model]: [M2007J3SC]</span><br><span class=\"line\">[ro.product.name]: [apollo]</span><br><span class=\"line\"></span><br><span class=\"line\">[ro.product.cpu.abi]: [arm64-v8a]</span><br><span class=\"line\">[ro.product.cpu.abilist]: [arm64-v8a,armeabi-v7a,armeabi]</span><br><span class=\"line\">[ro.product.cpu.abilist32]: [armeabi-v7a,armeabi]</span><br><span class=\"line\">[ro.product.cpu.abilist64]: [arm64-v8a]</span><br><span class=\"line\"></span><br><span class=\"line\">[dalvik.vm.heapsize]: [512m]</span><br><span class=\"line\">[dalvik.vm.heapstartsize]: [8m]</span><br></pre></td></tr></table></figure>\n<p>通过列举出的数据，可以看出属性里面包含了很多重要的信息：机型信息，CPU 架构，虚拟机分配的内存大小等等。</p>\n<p>在 Java 代码中，可以调用 <code>SystemProperties.get(String, String)</code> 方法获取系统属性。例如，在 ActivityManager 中就有这样的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">staticGetLargeMemoryClass</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过获取系统属性 dalvik.vm.heapsize, 得出应用可用堆内存的最大值</span></span><br><span class=\"line\">    String vmHeapSize = SystemProperties.get(<span class=\"string\">&quot;dalvik.vm.heapsize&quot;</span>, <span class=\"string\">&quot;16m&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.parseInt(vmHeapSize.substring(<span class=\"number\">0</span>, vmHeapSize.length() - <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似地，调用 <code>SystemProperties.set(String, String)</code> 方法可以设置系统属性。例如，在 ActivityManagerService 中就有这样的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">finishBooting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Tell anyone interested that we are done booting!</span></span><br><span class=\"line\">        <span class=\"comment\">// 通过设置属性 sys.boot_completed = 1, 标记系统已经启动完成</span></span><br><span class=\"line\">        SystemProperties.set(<span class=\"string\">&quot;sys.boot_completed&quot;</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"2-4-2-1-初始化\"><a href=\"#2-4-2-1-初始化\" class=\"headerlink\" title=\"2.4.2.1 初始化\"></a>2.4.2.1 初始化</h4><!-- TODO: 如何创建内存区域？ -->\n\n<!-- TODO: 进程是怎样获取共享内存中的属性？ -->\n\n<!-- TODO: 进程为什么不能直接设置共享内存中的属性？ -->\n\n<!-- TODO: CreateSerializedPropertyInfo() -->\n\n<!-- TODO: property_info_area.LoadDefaultPath() -->\n\n<p>属性服务初始化时，调用的是 property_init 函数，文件路径为 <code>system/core/init/property_service.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">property_init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mkdir(<span class=\"string\">&quot;/dev/__properties__&quot;</span>, S_IRWXU | S_IXGRP | S_IXOTH);</span><br><span class=\"line\">    CreateSerializedPropertyInfo();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建内存区域</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__system_property_area_init()) &#123;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;Failed to initialize property area&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!property_info_area.LoadDefaultPath()) &#123;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;Failed to load serialized property info file&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数最主要的工作是通过调用 <code>__system_property_area_init</code> 函数，创建用于存储属性的内存区域。</p>\n<h4 id=\"2-4-2-2-启动\"><a href=\"#2-4-2-2-启动\" class=\"headerlink\" title=\"2.4.2.2 启动\"></a>2.4.2.2 启动</h4><!-- TODO: socket 的创建过程 -->\n\n<!-- TODO: listen(property_set_fd, 8) -->\n\n<!-- TODO: 一个进程是怎样向 init 进程发起属性设置的请求？ -->\n\n<p>属性服务启动时，调用的是 StartPropertyService 函数，文件路径为 <code>system/core/init/property_service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StartPropertyService</span><span class=\"params\">(Epoll* epoll)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建 socket 并返回其文件描述符, 其中 PROP_SERVICE_NAME = &quot;property_service&quot;</span></span><br><span class=\"line\">    property_set_fd = CreateSocket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,</span><br><span class=\"line\">                                   <span class=\"literal\">false</span>, <span class=\"number\">0666</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (property_set_fd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; <span class=\"string\">&quot;start_property_service socket creation failed&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listen(property_set_fd, <span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将 socket 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]</span></span><br><span class=\"line\">    <span class=\"comment\">// handle_property_set_fd 是可读事件触发时的回调函数 [2.4.2.3]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll-&gt;RegisterHandler(property_set_fd, handle_property_set_fd); !result) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数首先创建名称为 property_service 的 socket，然后将 socket 文件描述符注册到 epoll，监听其可读事件。</p>\n<p>当可读事件触发时，会进入回调函数 <code>handle_property_set_fd</code>，接着来分析这个回调函数。</p>\n<h4 id=\"2-4-2-3-回调函数-handle-property-set-fd\"><a href=\"#2-4-2-3-回调函数-handle-property-set-fd\" class=\"headerlink\" title=\"2.4.2.3 回调函数 handle_property_set_fd\"></a>2.4.2.3 回调函数 handle_property_set_fd</h4><!-- TODO: ucred cr; socklen_t cr_size = sizeof(cr); -->\n\n<!-- TODO: 设置属性的具体实现 -->\n\n<!-- TODO: 除了通过向 init 进程发出请求设置属性以外, 在其他地方是否也有属性的设置？ -->\n\n<!-- TODO: 属性的同步问题 -->\n\n<p>函数所在文件的路径为 <code>system/core/init/property_service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handle_property_set_fd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2000ms</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">constexpr</span> <span class=\"keyword\">uint32_t</span> kDefaultSocketTimeout = <span class=\"number\">2000</span>; <span class=\"comment\">/* ms */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">SocketConnection <span class=\"title\">socket</span><span class=\"params\">(s, cr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置 2000ms 的超时时长</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> timeout_ms = kDefaultSocketTimeout;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> cmd = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!socket.RecvUint32(&amp;cmd, &amp;timeout_ms)) &#123;</span><br><span class=\"line\">        PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop: error while reading command from the socket&quot;</span>;</span><br><span class=\"line\">        socket.SendUint32(PROP_ERROR_READ_CMD);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (cmd) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理 PROP_MSG_SETPROP 命令</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> PROP_MSG_SETPROP: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// PROP_NAME_MAX = 32</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> prop_name[PROP_NAME_MAX];</span><br><span class=\"line\">        <span class=\"keyword\">char</span> prop_value[PROP_VALUE_MAX];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收属性名和属性值, 分别存储于字符数组 prop_name 和 prop_value 中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!socket.RecvChars(prop_name, PROP_NAME_MAX, &amp;timeout_ms) ||</span><br><span class=\"line\">            !socket.RecvChars(prop_value, PROP_VALUE_MAX, &amp;timeout_ms)) &#123;</span><br><span class=\"line\">          PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop(PROP_MSG_SETPROP): error while reading name/value from the socket&quot;</span>;</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将字符数组中最后的一个元素设置为 0</span></span><br><span class=\"line\">        prop_name[PROP_NAME_MAX<span class=\"number\">-1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        prop_value[PROP_VALUE_MAX<span class=\"number\">-1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; cr = socket.cred();</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> error;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置属性</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> result =</span><br><span class=\"line\">            HandlePropertySet(prop_name, prop_value, socket.source_context(), cr, &amp;error);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != PROP_SUCCESS) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Unable to set property &#x27;&quot;</span> &lt;&lt; prop_name &lt;&lt; <span class=\"string\">&quot;&#x27; to &#x27;&quot;</span> &lt;&lt; prop_value</span><br><span class=\"line\">                       &lt;&lt; <span class=\"string\">&quot;&#x27; from uid:&quot;</span> &lt;&lt; cr.uid &lt;&lt; <span class=\"string\">&quot; gid:&quot;</span> &lt;&lt; cr.gid &lt;&lt; <span class=\"string\">&quot; pid:&quot;</span> &lt;&lt; cr.pid &lt;&lt; <span class=\"string\">&quot;: &quot;</span></span><br><span class=\"line\">                       &lt;&lt; error;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 处理 PROP_MSG_SETPROP2 命令</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> PROP_MSG_SETPROP2: &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收字符串类型的属性名和属性值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!socket.RecvString(&amp;name, &amp;timeout_ms) ||</span><br><span class=\"line\">            !socket.RecvString(&amp;value, &amp;timeout_ms)) &#123;</span><br><span class=\"line\">          PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop(PROP_MSG_SETPROP2): error while reading name/value from the socket&quot;</span>;</span><br><span class=\"line\">          socket.SendUint32(PROP_ERROR_READ_DATA);</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; cr = socket.cred();</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> error;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置属性</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> result = HandlePropertySet(name, value, socket.source_context(), cr, &amp;error);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != PROP_SUCCESS) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Unable to set property &#x27;&quot;</span> &lt;&lt; name &lt;&lt; <span class=\"string\">&quot;&#x27; to &#x27;&quot;</span> &lt;&lt; value</span><br><span class=\"line\">                       &lt;&lt; <span class=\"string\">&quot;&#x27; from uid:&quot;</span> &lt;&lt; cr.uid &lt;&lt; <span class=\"string\">&quot; gid:&quot;</span> &lt;&lt; cr.gid &lt;&lt; <span class=\"string\">&quot; pid:&quot;</span> &lt;&lt; cr.pid &lt;&lt; <span class=\"string\">&quot;: &quot;</span></span><br><span class=\"line\">                       &lt;&lt; error;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        socket.SendUint32(result);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;sys_prop: invalid command &quot;</span> &lt;&lt; cmd;</span><br><span class=\"line\">        socket.SendUint32(PROP_ERROR_INVALID_CMD);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数初始化了 socket 接收事件的超时时长，然后对接收到的 <code>cmd</code> 做相应的操作：</p>\n<ul>\n<li>对于 <code>PROP_MSG_SETPROP</code> 命令，使用两个长度为 <code>PROP_NAME_MAX</code> 的字符数组保存接收到的属性名和属性值。值得注意的是，最后会将字符数组中最后的一个元素设为 0，因此接收的属性名和属性值的最大长度不应超过 <code>PROP_NAME_MAX - 1</code> 。</li>\n<li>对于 <code>PROP_MSG_SETPROP2</code> 命令，使用两个 <code>std::string</code> 保存接收到的属性名和属性值。</li>\n</ul>\n<p>最后，不论是 <code>PROP_MSG_SETPROP</code> 命令还是 <code>PROP_MSG_SETPROP2</code> 命令，都会调用 <code>HandlePropertySet</code> 函数来设置属性。</p>\n<h3 id=\"2-4-3-信号\"><a href=\"#2-4-3-信号\" class=\"headerlink\" title=\"2.4.3 信号\"></a>2.4.3 信号</h3><p><strong>信号 (Signals)</strong> 属于 IPC 的一种方式，用于向一个进程或者进程中的特定线程发送事件通知。</p>\n<p>信号是一个<strong>异步的</strong>通信机制，一个进程可以不需要等待信号的到达。在信号未产生时，进程会正常执行；当信号产生后，系统可以中断目标进程的任何非原子操作，此时进程的正常执行流程会被中断，进而对信号进行处理。</p>\n<h4 id=\"2-4-3-1-处理信号\"><a href=\"#2-4-3-1-处理信号\" class=\"headerlink\" title=\"2.4.3.1 处理信号\"></a>2.4.3.1 处理信号</h4><p>在 Linux，一个子进程终结后，内核依然会为其维护关于此进程的最小信息集 (PID、终结状态、资源使用信息)，以便父进程获取有关子进程的信息。如果父进程没有为该子进程发起 wait、waitpid 或者 waitid 系统调用，那么子进程的信息就会一直占据着内核进程表的空间。在这种情况下，这个子进程就成为了一个**僵尸进程 (Zombie process)**。</p>\n<p>一般情况下，对于一个僵尸进程，如果其父进程终结了，那么 init 进程就会自动成为僵尸进程的父进程。此时，为了避免僵尸进程一直占据着系统资源，init 进程需要为僵尸进程释放占据的空间。</p>\n<p>而且，在加载启动脚本 [2.4.4] 这一步骤中，init 进程会 fork 得到一些子进程，例如：servicemanager 进程、zygote 进程。这些子进程对 Android 而言非常重要，在这些进程退出后，init 进程需要有相应的动作将其重启。</p>\n<p>于是，为了管理这些子进程，init 进程需要接收子进程终结的信号并进行相应的处理。</p>\n<p>在 Android，信号处理基于 Linux 的信号机制。</p>\n<h5 id=\"2-4-3-1-1-信号的处理方式\"><a href=\"#2-4-3-1-1-信号的处理方式\" class=\"headerlink\" title=\"2.4.3.1.1 信号的处理方式\"></a>2.4.3.1.1 信号的处理方式</h5><!-- 更正: 注册信号处理函数 -->\n\n<p>信号的处理方式有以下三种：</p>\n<ul>\n<li><strong>忽略该信号</strong></li>\n<li><strong>按信号的默认行为处理该信号</strong></li>\n<li><strong>使用自定义的信号处理函数来处理该信号</strong></li>\n</ul>\n<p>init 进程使用的是第三种处理方式：使用自定义的信号处理函数来处理该信号。进程注册了一个信号处理函数，当目标信号产生时，信号会被捕获，并调用注册的函数进行处理。</p>\n<p>接下来分析这个过程。</p>\n<h5 id=\"2-4-3-1-2-系统调用-sigaction\"><a href=\"#2-4-3-1-2-系统调用-sigaction\" class=\"headerlink\" title=\"2.4.3.1.2 系统调用 sigaction\"></a>2.4.3.1.2 系统调用 sigaction</h5><p>在分析 init 进程注册函数的过程之前，首先来了解系统调用 sigaction，这个系统调用是此过程的一个关键点。</p>\n<p><strong>sigaction</strong> 是一个系统调用，函数原型为 <code>int sigaction(int signum, const struct sigaction *restrict act, struct sigaction *restrict oldact)</code>，用于更改进程在收到指定信号后的行为。</p>\n<h6 id=\"2-4-3-1-2-1-参数\"><a href=\"#2-4-3-1-2-1-参数\" class=\"headerlink\" title=\"2.4.3.1.2.1 参数\"></a>2.4.3.1.2.1 参数</h6><p>首先来理解 sigaction 的参数：</p>\n<ul>\n<li><p><strong>signum</strong> 是指定信号的编号。</p>\n<p>同一个信号在不同的架构上可能有不同的编号。在 Android，ARM 架构的信号编号定义在 <code>bionic/libc/kernel/uapi/asm-arm/asm/signal.h</code> 文件上。</p>\n</li>\n<li><p><strong>act</strong> 是一个 sigaction 类型的指针，而 sigaction 是一个结构体，其定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span>     (*sa_handler)(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">   <span class=\"keyword\">void</span>     (*sa_sigaction)(<span class=\"keyword\">int</span>, <span class=\"keyword\">siginfo_t</span> *, <span class=\"keyword\">void</span> *);</span><br><span class=\"line\">   <span class=\"keyword\">sigset_t</span>   sa_mask;</span><br><span class=\"line\">   <span class=\"keyword\">int</span>        sa_flags;</span><br><span class=\"line\">   <span class=\"keyword\">void</span>     (*sa_restorer)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>关注结构体中两个较为重要的成员 <code>sa_handler</code> 和 <code>sa_flags</code>。</p>\n<p>成员 <code>sa_handler</code> 用于指定信号产生时的行为，可以是以下这些值之一：</p>\n<ul>\n<li><p><strong>SIG_DFL</strong></p>\n<p>表示执行该信号的默认行为。</p>\n</li>\n<li><p><strong>SIG_IGN</strong></p>\n<p>表示忽略该信号。</p>\n</li>\n<li><p><strong>一个指向信号处理函数的指针</strong></p>\n<p>信号编号 signum 将作为函数的唯一参数传入。当目标信号产生时，会自动调用此函数进行处理。</p>\n</li>\n</ul>\n<p>成员 <code>sa_flags</code> 是标志位，可以由零个或者多个标志组成。下面列出其中的一些标志：</p>\n<ul>\n<li><p><strong>SA_NOCLDSTOP</strong></p>\n<p>只有当 signum = SIGCHLD 时才有意义。表示进程不接收子进程停止或者恢复时产生的信号，只接收子进程终结的信号。</p>\n</li>\n<li><p><strong>SA_RESETHAND</strong></p>\n<p>当信号已经由信号处理函数处理过后，将信号恢复为使用默认行为进行处理。</p>\n</li>\n<li><p><strong>SA_SIGINFO</strong></p>\n<p>不再通过结构体成员 sa_handler 设置信号处理函数，而是使用成员 sa_sigaction。此时，函数的入参有三个。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>oldact</strong> 同样是一个 sigaction 类型的指针，用于保存上一个 sigaction 调用所传入的参数 act，可以为空。</p>\n</li>\n</ul>\n<h6 id=\"2-4-3-1-2-2-返回值\"><a href=\"#2-4-3-1-2-2-返回值\" class=\"headerlink\" title=\"2.4.3.1.2.2 返回值\"></a>2.4.3.1.2.2 返回值</h6><p>最后来了解 sigaction 的返回值：</p>\n<ul>\n<li><p>当操作成功时，返回值为 0。</p>\n</li>\n<li><p>当发生错误时，返回值为 -1。</p>\n</li>\n</ul>\n<h5 id=\"2-4-3-1-3-init-进程注册信号处理函数\"><a href=\"#2-4-3-1-3-init-进程注册信号处理函数\" class=\"headerlink\" title=\"2.4.3.1.3 init 进程注册信号处理函数\"></a>2.4.3.1.3 init 进程注册信号处理函数</h5><p>在了解过系统调用 sigaction 以后，现在可以开始分析 init 进程注册信号处理函数的过程。</p>\n<h6 id=\"2-4-3-1-3-1-发起系统调用-sigaction\"><a href=\"#2-4-3-1-3-1-发起系统调用-sigaction\" class=\"headerlink\" title=\"2.4.3.1.3.1 发起系统调用 sigaction\"></a>2.4.3.1.3.1 发起系统调用 sigaction</h6><p>init 进程通过调用 InstallSignalFdHandler 函数实现注册信号处理函数，函数所在文件的路径为 <code>system/core/init/init.cpp</code>，首先来关注函数前半部分所做的工作：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">InstallSignalFdHandler</span><span class=\"params\">(Epoll* epoll)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建结构体 sigaction</span></span><br><span class=\"line\">    <span class=\"comment\">// 成员 sa_handler 用于指定信号产生时的行为, 令 sa_handler = SIG_DFL 表明当信号产生时按默认行为对信号进行处理</span></span><br><span class=\"line\">    <span class=\"comment\">// 成员 sa_flags 是标志位, 令 sa_flags = SA_NOCLDSTOP 表明 init 进程不接收子进程被中断或者被中断后恢复时产生的信号, 只接收子进程终结的信号</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> <span class=\"title\">act</span> &#123;</span> .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDSTOP &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// sigaction 是一个系统调用, 用于更改进程在收到指定的信号时所执行的操作 [2.4.3.1.2]</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到第一个参数传入的是 SIGCHLD, 表明目标信号是 SIGCHLD, 当子进程终结, 被中断, 或者被中断后恢复时, 就会产生此信号</span></span><br><span class=\"line\">    sigaction(SIGCHLD, &amp;act, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数前半部分所做的工作是：发起系统调用 sigaction，针对子进程产生的 <code>SIGCHLD</code> 信号，当进程在收到信号时，按默认行为对信号进行处理，而 <code>SIGCHLD</code> 信号的默认行为就是忽略该信号。</p>\n<p>值得注意的是，当子进程终结、被中断或者被中断后恢复时，都会产生 <code>SIGCHLD</code> 信号，而添加标志位 <code>SA_NOCLDSTOP</code> 可以使得 init 进程只接收子进程终结的信号。</p>\n<p>显然，在函数前半部分所做的工作中，并没有实现按自定义行为对信号进行处理。事实上，init 进程是通过监听 signal 文件描述符来实现按自定义行为来处理信号的。接下来分析 InstallSignalFdHandler 函数后半部分所做的工作。</p>\n<h6 id=\"2-4-3-1-3-2-监听-signal-文件描述符\"><a href=\"#2-4-3-1-3-2-监听-signal-文件描述符\" class=\"headerlink\" title=\"2.4.3.1.3.2 监听 signal 文件描述符\"></a>2.4.3.1.3.2 监听 signal 文件描述符</h6><p>之前提到，信号是一个异步的通信机制。进程可以注册一个信号处理函数，接着就能继续进行其他的工作，只有当目标信号发送到进程时，才回调处理函数进行处理，这里就体现出异步的性质。</p>\n<p>除了异步的方式以外，进程还可以通过同步的方式接收信号。Linux 提供了系统调用 signalfd，用于创建一个接收指定信号的文件描述符。对文件描述符执行读操作会进入阻塞状态，直到目标信号产生并传递给进程。</p>\n<p>init 进程就是通过这种方式来同步接收信号的，接下来分析这个过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">InstallSignalFdHandler</span><span class=\"params\">(Epoll* epoll)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// mask 是一个信号集, 用于指定想要接收的信号</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这里, 目标信号就是 SIGCHLD</span></span><br><span class=\"line\">    <span class=\"keyword\">sigset_t</span> mask;</span><br><span class=\"line\">    sigemptyset(&amp;mask);</span><br><span class=\"line\">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 signal 文件描述符</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意到, 在发起系统调用 signalfd 时, 传入的第一个参数是 -1, 则调用会创建一个新的文件描述符</span></span><br><span class=\"line\">    signal_fd = signalfd(<span class=\"number\">-1</span>, &amp;mask, SFD_CLOEXEC);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (signal_fd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        PLOG(FATAL) &lt;&lt; <span class=\"string\">&quot;failed to create signalfd&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将 signal 文件描述符注册到 epoll, 监听其可读事件 [2.4.1.2]</span></span><br><span class=\"line\">    <span class=\"comment\">// HandleSignalFd 是可读事件触发时的回调函数 [2.4.3.1.4]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll-&gt;RegisterHandler(signal_fd, HandleSignalFd); !result) &#123;</span><br><span class=\"line\">        LOG(FATAL) &lt;&lt; result.error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数后半部分所做的工作是：创建信号集，信号集里面包含了信号 <code>SIGCHLD</code>，然后新建一个与信号集关联的 signal 文件描述符，最后将文件描述符注册到 epoll。</p>\n<p>当 signal 文件描述符的可读事件触发时，就会调用 HandleSignalFd 函数，接下来分析这个函数。</p>\n<h5 id=\"2-4-3-1-4-回调函数-HandleSignalFd\"><a href=\"#2-4-3-1-4-回调函数-HandleSignalFd\" class=\"headerlink\" title=\"2.4.3.1.4 回调函数 HandleSignalFd\"></a>2.4.3.1.4 回调函数 HandleSignalFd</h5><p>函数所在文件的路径为 <code>system/core/init/init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">HandleSignalFd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    signalfd_siginfo siginfo;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从 signal 文件描述符中读取结构体 signalfd_siginfo, 每次读取一个</span></span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> bytes_read = TEMP_FAILURE_RETRY(read(signal_fd, &amp;siginfo, <span class=\"keyword\">sizeof</span>(siginfo)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bytes_read != <span class=\"keyword\">sizeof</span>(siginfo)) &#123;</span><br><span class=\"line\">        PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Failed to read siginfo from signal_fd&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据信号编号执行相应的操作</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (siginfo.ssi_signo) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SIGCHLD:</span><br><span class=\"line\">            ReapAnyOutstandingChildren();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SIGTERM:</span><br><span class=\"line\">            HandleSigtermSignal(siginfo);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;signal_fd: received unexpected signal &quot;</span> &lt;&lt; siginfo.ssi_signo;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当目标信号产生并传递给进程时，signal 文件描述符的可读事件就会触发，返回一个或者多个结构体 signalfd_siginfo。而函数 HandleSignalFd 负责从 signal 文件描述符中读出一个结构体 signalfd_siginfo，并根据信号编号执行相应的操作。</p>\n<p>在这里，我们关心的信号是 <code>SIGCHLD</code>。当此信号产生后，会调用 ReapAnyOutstandingChildren 函数，接着来分析这个函数。</p>\n<h6 id=\"2-4-3-1-4-1-分析-ReapAnyOutstandingChildren-函数\"><a href=\"#2-4-3-1-4-1-分析-ReapAnyOutstandingChildren-函数\" class=\"headerlink\" title=\"2.4.3.1.4.1 分析 ReapAnyOutstandingChildren 函数\"></a>2.4.3.1.4.1 分析 ReapAnyOutstandingChildren 函数</h6><p>函数所在文件的路径为 <code>system/core/init/sigchld_handler.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ReapAnyOutstandingChildren</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ReapOneProcess()) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数循环调用 ReapOneProcess 函数，只有当函数 ReapOneProcess 返回 false 时，循环才会停止。接着来看 ReapOneProcess 函数做了什么工作。</p>\n<h6 id=\"2-4-3-1-4-2-分析-ReapOneProcess-函数\"><a href=\"#2-4-3-1-4-2-分析-ReapOneProcess-函数\" class=\"headerlink\" title=\"2.4.3.1.4.2 分析 ReapOneProcess 函数\"></a>2.4.3.1.4.2 分析 ReapOneProcess 函数</h6><!-- TODO: 分析 service->flags() -->\n\n<!-- TODO: 分析 ServiceList::GetInstance().RemoveService(*service) -->\n\n<p>函数所在文件的路径为 <code>system/core/init/sigchld_handler.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">ReapOneProcess</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">siginfo_t</span> siginfo = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发起系统调用 waitid, 此系统调用用于获取子进程状态的变更和相关的信息</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于 init 进程只接收子进程终结的信号, 因此这里获取到的都是已进入僵尸状态的子进程的相关信息, 信息保存在 siginfo 当中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TEMP_FAILURE_RETRY(waitid(P_ALL, <span class=\"number\">0</span>, &amp;siginfo, WEXITED | WNOHANG | WNOWAIT)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 失败, 函数返回 false</span></span><br><span class=\"line\">        PLOG(ERROR) &lt;&lt; <span class=\"string\">&quot;waitid failed&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取子进程的 pid</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> pid = siginfo.si_pid;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 子进程的 pid 不存在, 函数返回 false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> wait_string;</span><br><span class=\"line\">    Service* service = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PropertyChildReap(pid)) &#123;</span><br><span class=\"line\">        name = <span class=\"string\">&quot;Async property child&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (SubcontextChildReap(pid)) &#123;</span><br><span class=\"line\">        name = <span class=\"string\">&quot;Subcontext&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据 pid 查询相应的 service</span></span><br><span class=\"line\">        service = ServiceList::GetInstance().FindService(pid, &amp;Service::pid);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (service) &#123;</span><br><span class=\"line\">            name = StringPrintf(<span class=\"string\">&quot;Service &#x27;%s&#x27; (pid %d)&quot;</span>, service-&gt;name().c_str(), pid);</span><br><span class=\"line\"></span><br><span class=\"line\">            ...</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            name = StringPrintf(<span class=\"string\">&quot;Untracked pid %d&quot;</span>, pid);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 没有找到对应的 service, 函数返回 true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!service) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用 service 的 Reap 函数</span></span><br><span class=\"line\">    service-&gt;Reap(siginfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经分析可知，ReapOneProcess 函数的主要工作是：为每个进入终结状态的子进程发起系统调用 waitid，从而避免已进入僵尸状态的子进程一直占据着系统资源。最后，函数会根据子进程 pid 查找是否存在相应的 service，如果 service 存在，还会调用 service 的 Reap 函数。接着来分析 Reap 函数。</p>\n<h6 id=\"2-4-3-1-4-3-分析-Reap-函数\"><a href=\"#2-4-3-1-4-3-分析-Reap-函数\" class=\"headerlink\" title=\"2.4.3.1.4.3 分析 Reap 函数\"></a>2.4.3.1.4.3 分析 Reap 函数</h6><p>函数所在文件的路径为 <code>system/core/init/service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Service::Reap</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">siginfo_t</span>&amp; siginfo)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(flags_ &amp; SVC_ONESHOT) || (flags_ &amp; SVC_RESTART)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果服务的标志位同时不带有 SVC_ONESHOT 和 SVC_RESTART, 则直接杀死服务所在的进程组</span></span><br><span class=\"line\">        KillProcessGroup(SIGKILL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果服务的标志位带有 SVC_TEMPORARY, 则直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags_ &amp; SVC_TEMPORARY) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重置状态</span></span><br><span class=\"line\">    pid_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    flags_ &amp;= (~SVC_RUNNING);</span><br><span class=\"line\">    start_order_ = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((flags_ &amp; SVC_ONESHOT) &amp;&amp; !(flags_ &amp; SVC_RESTART) &amp;&amp; !(flags_ &amp; SVC_RESET)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将带有 SVC_ONESHOT 的服务设为不可用状态</span></span><br><span class=\"line\">        flags_ |= SVC_DISABLED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags_ &amp; (SVC_DISABLED | SVC_RESET))  &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果服务的标志位带有 SVC_DISABLED 或者 SVC_RESET, 则使其进入 stopped 状态, 不会自动重启</span></span><br><span class=\"line\">        NotifyStateChange(<span class=\"string\">&quot;stopped&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 带有标志位 SVC_CRITICAL 的服务会被标记为系统关键服务</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果服务在 4 分钟之内崩溃 4 次以上, 又或者服务崩溃时系统处于未完全启动状态</span></span><br><span class=\"line\">    <span class=\"comment\">// 则设备会重启并进入 bootloader 或者设置崩溃相关的属性</span></span><br><span class=\"line\">    boot_clock::time_point now = boot_clock::now();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (((flags_ &amp; SVC_CRITICAL) || !pre_apexd_) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> boot_completed = android::base::GetBoolProperty(<span class=\"string\">&quot;sys.boot_completed&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now &lt; time_crashed_ + <span class=\"number\">4</span>min || !boot_completed) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++crash_count_ &gt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (flags_ &amp; SVC_CRITICAL) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Aborts into bootloader</span></span><br><span class=\"line\">                    LOG(FATAL) &lt;&lt; <span class=\"string\">&quot;critical process &#x27;&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;&#x27; exited 4 times &quot;</span></span><br><span class=\"line\">                               &lt;&lt; (boot_completed ? <span class=\"string\">&quot;in 4 minutes&quot;</span> : <span class=\"string\">&quot;before boot completed&quot;</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;updatable process &#x27;&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"string\">&quot;&#x27; exited 4 times &quot;</span></span><br><span class=\"line\">                               &lt;&lt; (boot_completed ? <span class=\"string\">&quot;in 4 minutes&quot;</span> : <span class=\"string\">&quot;before boot completed&quot;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// Notifies update_verifier and apexd</span></span><br><span class=\"line\">                    property_set(<span class=\"string\">&quot;ro.init.updatable_crashing&quot;</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            time_crashed_ = now;</span><br><span class=\"line\">            crash_count_ = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加标志位 SVC_RESTARTING, init 进程会重启带有此标志位的服务 [2.4.5.2]</span></span><br><span class=\"line\">    flags_ &amp;= (~SVC_RESTART);</span><br><span class=\"line\">    flags_ |= SVC_RESTARTING;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行当前 service 中所有 onrestart 命令</span></span><br><span class=\"line\">    onrestart_.ExecuteAllCommands();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使服务进入 restarting 状态</span></span><br><span class=\"line\">    NotifyStateChange(<span class=\"string\">&quot;restarting&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Reap 函数最主要的工作就是重启有需要的服务。注意到，改变服务状态是通过调用 NotifyStateChange 函数实现的，来看看这个函数。</p>\n<h6 id=\"2-4-3-1-4-4-分析-NotifyStateChange-函数\"><a href=\"#2-4-3-1-4-4-分析-NotifyStateChange-函数\" class=\"headerlink\" title=\"2.4.3.1.4.4 分析 NotifyStateChange 函数\"></a>2.4.3.1.4.4 分析 NotifyStateChange 函数</h6><p>函数所在文件的路径为 <code>system/core/init/service.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Service::NotifyStateChange</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; new_state)</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((flags_ &amp; SVC_TEMPORARY) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果服务的标志位中带有 SVC_TEMPORARY, 则不会使用属性服务来记录它的状态</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用属性服务来记录服务当前的状态</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> prop_name = <span class=\"string\">&quot;init.svc.&quot;</span> + name_;</span><br><span class=\"line\">    property_set(prop_name, new_state);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过分析这个函数，可以知道，系统会使用属性服务以 key-value 的形式存储服务当前的状态，其中 key 的取值为 init.svc.[service_name]，value 是服务当前的状态。因此，可以使用 adb，输入命令 <code>getprop | grep init.svc.</code>，查看设备上 service 的运行状态，以下是其中的一些输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[init.svc.adbd]: [running]</span><br><span class=\"line\">[init.svc.alarm-hal-1-0]: [running]</span><br><span class=\"line\">[init.svc.android.thermal-hal]: [running]</span><br><span class=\"line\">[init.svc.apexd]: [stopped]</span><br><span class=\"line\">[init.svc.apexd-bootstrap]: [stopped]</span><br><span class=\"line\">[init.svc.apexd-snapshotde]: [stopped]</span><br><span class=\"line\">[init.svc.audioserver]: [running]</span><br><span class=\"line\">[init.svc.wifidisplayhalservice]: [running]</span><br><span class=\"line\">[init.svc.wpa_supplicant]: [running]</span><br><span class=\"line\">[init.svc.zygote]: [running]</span><br><span class=\"line\">[init.svc.zygote_secondary]: [running]</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-4-4-加载启动脚本\"><a href=\"#2-4-4-加载启动脚本\" class=\"headerlink\" title=\"2.4.4 加载启动脚本\"></a>2.4.4 加载启动脚本</h3><!-- TODO: 分析函数 CreateParser -->\n\n<!-- TODO: .rc 文件的解析过程 -->\n\n<!-- TODO: 属性的变更如何触发脚本中的属性触发器？ -->\n\n<!-- TODO: /system/etc/init -->\n\n<!-- TODO: /odm/etc/init -->\n\n<!-- TODO: /vendor/etc/init -->\n\n<p>调用 LoadBootScripts 函数加载启动脚本，函数所在文件的路径为 <code>system/core/init/init.cpp</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">LoadBootScripts</span><span class=\"params\">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class=\"line\">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootscript = GetProperty(<span class=\"string\">&quot;ro.boot.init_rc&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootscript.empty()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 加载 init.rc 脚本文件 [2.4.4.1]</span></span><br><span class=\"line\">        parser.ParseConfig(<span class=\"string\">&quot;/init.rc&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /system/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/system/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/system/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /product/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /product_services/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /odm/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/odm/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/odm/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载 /vendor/etc/init 目录下的所有脚本文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        parser.ParseConfig(bootscript);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般情况下，此函数会去加载一些指定的脚本，其中：</p>\n<ul>\n<li><code>init.rc</code> 是主要的 .rc 文件。</li>\n<li><code>/system/etc/init/</code> 包含了核心的系统项目，例如：SurfaceFlinger, MediaService, logcatd。</li>\n<li><code>/vendor/etc/init/</code> 包含了 SoC 供应商项目，例如：核心 SoC 功能所需的操作或守护进程。</li>\n<li><code>/odm/etc/init/</code> 包含了设备制造商项目，例如：运动传感器或其他外围设备所需的操作或守护进程。</li>\n</ul>\n<p>init.rc 是最主要脚本文件，接下来将对这个脚本进行分析。</p>\n<h4 id=\"2-4-4-1-init-rc-脚本\"><a href=\"#2-4-4-1-init-rc-脚本\" class=\"headerlink\" title=\"2.4.4.1 init.rc 脚本\"></a>2.4.4.1 init.rc 脚本</h4><p>在 Android，后缀为 .rc 的文件由 Android Init Language 编写，<a href=\"https://cs.android.com/android/platform/superproject/+/android-security-10.0.0_r56:system/core/init/README.md\">关于 Android Init Language 的详细说明</a> 可以在 AOSP 上找到，路径为 <code>system/core/init/README.md</code>。</p>\n<p>在分析脚本之前，首先来了解这种语言的语法。</p>\n<h5 id=\"2-4-4-1-1-Android-Init-Language\"><a href=\"#2-4-4-1-1-Android-Init-Language\" class=\"headerlink\" title=\"2.4.4.1.1 Android Init Language\"></a>2.4.4.1.1 Android Init Language</h5><p>Android Init Language 由五大类表达式组成：<code>Actions</code>，<code>Commands</code>，<code>Services</code>，<code>Options</code>，<code>Imports</code>。</p>\n<p>其语法规则有：</p>\n<ul>\n<li>每一行都是一条语句，一条语句由多个 token 组成，token 之间以空格分开。</li>\n<li>如果一个 token 包含了空格，可以跟 c 语言类似，使用反斜杠 <code>\\</code> 作为转义字符，又或者使用双引号包裹整个 token。</li>\n<li>在行的末尾使用反斜杠 <code>\\</code>，可以将语句换行。</li>\n<li>以符号 <code>#</code> 开头的行是注释行。</li>\n<li>系统属性的值可以通过语法 <code>$&#123;property.name&#125;</code> 获取，例如：<code>import /init.recovery.$&#123;ro.hardware&#125;.rc</code>。</li>\n<li>一个文件可以分为多个 section，必须使用 <code>Actions</code> 或者 <code>Services</code> 来声明一个新的 section。所有的 <code>Commands</code> 和 <code>Options</code> 都是属于最近声明的那一个 section。如果在一个 section 之前声明了 <code>Commands</code> 或者 <code>Options</code> ，则声明会被忽略。</li>\n<li><code>Services</code> 的名称必须是唯一的，如果存在多个重名的 <code>Services</code> ，除了第一个以外，其他的都会被忽略，并且会输出错误日志。</li>\n</ul>\n<p>接下来列出一些较为重要的表达式。</p>\n<h6 id=\"2-4-4-1-1-1-Actions\"><a href=\"#2-4-4-1-1-1-Actions\" class=\"headerlink\" title=\"2.4.4.1.1.1 Actions\"></a>2.4.4.1.1.1 Actions</h6><p><code>Actions</code> 由 一系列 <code>Commands</code> 组成，同时 <code>Triggers</code> 决定了 <code>Actions</code> 的触发时机，其形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]*</span><br><span class=\"line\">   &lt;command&gt;</span><br><span class=\"line\">   &lt;command&gt;</span><br><span class=\"line\">   &lt;command&gt;</span><br></pre></td></tr></table></figure>\n<p>当一个事件触发后，如果此事件能够匹配上 <code>Actions</code> 的  <code>Triggers</code>，那么 <code>Actions</code> 会被添加到待执行队列的尾部。</p>\n<p>之后，待执行队列中的 <code>Actions</code> 会按照加入顺序出队，并且执行该 <code>Actions</code> 中的 <code>Commands</code>。</p>\n<p>以启动 Zygote 作为示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br></pre></td></tr></table></figure>\n<p>简单分析这个脚本：</p>\n<p>这个 <code>Actions</code> 拥有两个 <code>Triggers</code>，分别是 <code>zygote-start</code> 和 <code>property:ro.crypto.state=unencrypted</code>，从第二行开始，每一行都是一个 <code>Command</code>。</p>\n<p>当事件 <code>zygote-start</code> 和 <code>property:ro.crypto.state=unencrypted</code> 触发后，<code>Actions</code> 会被加入到待执行队列。在执行到该 <code>Actions</code> 时，会按照 <code>Commands</code> 定义的先后顺序，依次执行 <code>Actions</code> 中的 <code>Commands</code>。</p>\n<h6 id=\"2-4-4-1-1-2-Triggers\"><a href=\"#2-4-4-1-1-2-Triggers\" class=\"headerlink\" title=\"2.4.4.1.1.2 Triggers\"></a>2.4.4.1.1.2 Triggers</h6><p><code>Triggers</code> 是字符串，用于匹配某些类型的事件并触发 <code>Actions</code> 中的 <code>Commands</code>。</p>\n<p>Triggers 可以分为两类：</p>\n<ul>\n<li><p><strong>Event triggers</strong></p>\n<p>事件触发器，这类触发器所匹配的事件由命令 <code>trigger</code>  触发，又或者通过调用 <code>QueueEventTrigger()</code> 函数触发。</p>\n</li>\n<li><p><strong>Property triggers</strong></p>\n<p>属性触发器，这类触发器所匹配的事件是：属性是否满足某个值，形式为 <code>property:&lt;key&gt;=&lt;value&gt;</code>。这里的属性就是之前提到的属性服务管理的属性。</p>\n</li>\n</ul>\n<p>注意，每一个 <code>Actions</code> 可以有多个属性触发器，但只能有一个事件触发器。</p>\n<p>例如：</p>\n<p><code>on init &amp;&amp; property:a=b</code>，<code>on property:a=b &amp;&amp; property:c=d</code> 是合法的。</p>\n<p><code>on boot &amp;&amp; on init</code> 是不合法的。</p>\n<h6 id=\"2-4-4-1-1-3-Commands\"><a href=\"#2-4-4-1-1-3-Commands\" class=\"headerlink\" title=\"2.4.4.1.1.3 Commands\"></a>2.4.4.1.1.3 Commands</h6><p>下面列举一些常见的 <code>Commands</code>：</p>\n<ul>\n<li><p><strong>trigger <event></strong></p>\n<p>触发一个事件。</p>\n</li>\n<li><p><strong>write <path> <content></strong></p>\n<p>按 path 打开文件，往文件中写入内容。</p>\n</li>\n<li><p><strong>chown <owner> <group> <path></strong></p>\n<p>更改文件所有者和组。</p>\n</li>\n<li><p><strong>mkdir <path> [mode] [owner] [group]</strong></p>\n<p>在路径上创建一个目录，可以选择使用给定的权限，所有者，用户组。 </p>\n<p>如果未指定权限，所有者，用户组，则新建的目录默认具有权限 755，并由 root 用户和 root 组拥有。</p>\n<p>当指定权限，所有者，用户组时，如果目录已经存在，则权限，所有者，用户组将被更新。</p>\n</li>\n<li><p><strong>start <service></strong></p>\n<p>当指定的服务未在运行时，启动该服务。</p>\n</li>\n<li><p><strong>exec_start <service></strong></p>\n<p>启动指定的服务，在该命令返回之前暂停处理其他命令。</p>\n</li>\n<li><p><strong>setprop <name> <value></strong></p>\n<p>给系统属性赋值，这里的属性是之前提到的属性服务中的属性。</p>\n</li>\n<li><p><strong>symlink <target> <path></strong></p>\n<p>在 path 上创建一个连接到 target 的符号链接。</p>\n</li>\n</ul>\n<h6 id=\"2-4-4-1-1-4-Services\"><a href=\"#2-4-4-1-1-4-Services\" class=\"headerlink\" title=\"2.4.4.1.1.4 Services\"></a>2.4.4.1.1.4 Services</h6><p><code>Services</code> 是由 init 进程启动的程序，一般运行在 init 进程的一个子进程，因此 init 进程在启动一个 <code>Services</code> 时会通过 fork 的方式生成子进程。</p>\n<p>默认情况下，<code>Services</code> 退出后会重启。</p>\n<p><code>Services</code> 的形式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class=\"line\">   &lt;option&gt;</span><br><span class=\"line\">   &lt;option&gt;</span><br><span class=\"line\">   ...</span><br></pre></td></tr></table></figure>\n<p>以启动 Zygote 64 位进程的脚本作为示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class=\"line\">    class main</span><br><span class=\"line\">    priority -20</span><br><span class=\"line\">    user root</span><br><span class=\"line\">    group root readproc reserved_disk</span><br><span class=\"line\">    socket zygote stream 660 root system</span><br><span class=\"line\">    socket usap_pool_primary stream 660 root system</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class=\"line\">    onrestart restart audioserver</span><br><span class=\"line\">    onrestart restart cameraserver</span><br><span class=\"line\">    onrestart restart media</span><br><span class=\"line\">    onrestart restart netd</span><br><span class=\"line\">    onrestart restart wificond</span><br><span class=\"line\">    writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br></pre></td></tr></table></figure>\n<p>简单分析这个脚本：<code>zygote</code> 是 <code>Services</code> 的名称，<code>/system/bin/app_process64</code> 是可执行文件的路径，<code>-Xzygote /system/bin --zygote --start-system-server</code> 是启动参数，从第二行开始，每一行都是一个 <code>Options</code>。</p>\n<h6 id=\"2-4-4-1-1-5-Options\"><a href=\"#2-4-4-1-1-5-Options\" class=\"headerlink\" title=\"2.4.4.1.1.5 Options\"></a>2.4.4.1.1.5 Options</h6><p><code>Options</code> 是 <code>Services</code> 的配置项，用于控制 init 进程运行 <code>Services</code> 的方式和时间。</p>\n<p> 下面列举一些常见的 <code>Options</code>：</p>\n<ul>\n<li><p><strong>class <name> [ <name>* ]</strong></p>\n<p>指定 <code>Services</code> 的类名。当 <code>Services</code> 所属类开启 (退出) 时，<code>Services</code> 也会开启 (退出) 。默认值为 default。</p>\n</li>\n<li><p><strong>class_start <serviceclass></strong></p>\n<p>启动所有未在运行的，类名被指定为 <code>serviceclass</code> 的 <code>Services</code>。</p>\n</li>\n<li><p><strong>priority <priority></strong></p>\n<p>设置 <code>Services</code> 进程的优先级。取值范围是 -20 ~ 19。默认值为 0。</p>\n</li>\n<li><p><strong>user <username></strong></p>\n<p>设置执行 <code>Services</code> 的用户。一般情况下，默认值为 root。</p>\n</li>\n<li><p><strong>group <groupname> [ <groupname>* ]</strong></p>\n<p>设置执行 <code>Services</code> 的用户组。一般情况下，默认值为 root。</p>\n</li>\n<li><p><strong>socket <name> <type> <perm> [ <user> [ <group> [ <seclabel> ] ] ]</strong></p>\n<p>创建一个 unix 域的 socket，命名为 <code>/dev/socket/&lt;name&gt;</code>，并将 socket 的文件描述符传递给创建的进程。</p>\n</li>\n<li><p><strong>onrestart</strong></p>\n<p>当 <code>Services</code> 重启时执行一个 <code>Commands</code>。</p>\n</li>\n<li><p><strong>oneshot</strong></p>\n<p>当 <code>Services</code> 退出后不再重启。</p>\n</li>\n<li><p><strong>writepid <file> [ <file>* ]</strong></p>\n<p>在进程 fork 之后，将子进程的 pid 写入指定的文件。</p>\n</li>\n</ul>\n<h5 id=\"2-4-4-1-2-加载-init-rc-脚本\"><a href=\"#2-4-4-1-2-加载-init-rc-脚本\" class=\"headerlink\" title=\"2.4.4.1.2 加载 init.rc 脚本\"></a>2.4.4.1.2 加载 init.rc 脚本</h5><p>脚本文件 init.rc 负责系统的初始设置，文件的路径为 <code>system/core/rootdir/init.rc</code>。</p>\n<p>在了解到脚本的编写语法之后，可以知道脚本的内容都是由  <code>Actions</code> 和 <code>Services</code> 构成的，而在 init.rc 脚本中绝大部分都是 <code>Actions</code>。在 [2.4.4.1.1.2] 中曾经提到，调用 <code>QueueEventTrigger()</code> 函数可以触发一个事件，当事件匹配上  <code>Actions</code> 的  <code>Triggers</code>，就会开始执行该 <code>Actions</code>。 接下来回到进程启动的第二阶段，寻找事件的触发点。</p>\n<h6 id=\"2-4-4-1-2-1-源码中事件的触发点\"><a href=\"#2-4-4-1-2-1-源码中事件的触发点\" class=\"headerlink\" title=\"2.4.4.1.2.1 源码中事件的触发点\"></a>2.4.4.1.2.1 源码中事件的触发点</h6><p>回到 init 进程启动的第二阶段，对应源代码 <code>system/core/init/init.cpp</code> 的 SecondStageMain 函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将触发事件 early-init 的操作加入到 ActionManager</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;early-init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Trigger all the boot actions to get us started.</span></span><br><span class=\"line\">    <span class=\"comment\">// 将触发事件 init 的操作加入到 ActionManager</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t mount filesystems or start core system services in charger mode.</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootmode = GetProperty(<span class=\"string\">&quot;ro.bootmode&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootmode == <span class=\"string\">&quot;charger&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前处于充电模式, 则将触发事件 charger 的操作加入到 ActionManager</span></span><br><span class=\"line\">        <span class=\"comment\">// 在充电模式下, 不会挂载文件系统和启动核心系统服务</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;charger&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前处于非充电模式, 则将触发事件 late-init 的操作加入到 ActionManager</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;late-init&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ActionManager 会按操作加入的顺序逐一执行 [2.4.5.x]，由此可知事件的触发顺序：</p>\n<ul>\n<li>非充电模式：early-init -&gt; init -&gt; late-init</li>\n<li>充电模式：early-init -&gt; init -&gt; charger</li>\n</ul>\n<p>由于在充电模式下，系统可能未完全启动，接下来将选取非充电模式下的流程进行分析。</p>\n<h6 id=\"2-4-4-1-2-2-init-rc-脚本的执行过程\"><a href=\"#2-4-4-1-2-2-init-rc-脚本的执行过程\" class=\"headerlink\" title=\"2.4.4.1.2.2 init.rc 脚本的执行过程\"></a>2.4.4.1.2.2 init.rc 脚本的执行过程</h6><!-- TODO: trigger boot -->\n\n<p>现在结合事件的触发顺序，分析脚本执行过程中的一些关键点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on early-init</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    # 以 start 方式启动 ueventd</span><br><span class=\"line\">    start ueventd</span><br><span class=\"line\"></span><br><span class=\"line\">    # 以 exec_start 方式运行 apexd-bootstrap, 在该命令返回之前暂停处理其他命令, 从而保证后续流程中 APEX 的可用性</span><br><span class=\"line\">    exec_start apexd-bootstrap</span><br><span class=\"line\"></span><br><span class=\"line\">on init</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    # 以 start 方式启动基本服务</span><br><span class=\"line\">    # 启动 servicemanager [2.4.4.1.2.3]</span><br><span class=\"line\">    start servicemanager</span><br><span class=\"line\">    start hwservicemanager</span><br><span class=\"line\">    start vndservicemanager</span><br><span class=\"line\"></span><br><span class=\"line\"># 挂载文件和启动核心系统服务</span><br><span class=\"line\"># 其中 trigger 用于触发一个事件 [2.4.4.1.1.2]</span><br><span class=\"line\">on late-init</span><br><span class=\"line\">    trigger early-fs</span><br><span class=\"line\">    trigger fs</span><br><span class=\"line\">    trigger post-fs</span><br><span class=\"line\">    trigger late-fs</span><br><span class=\"line\">    trigger post-fs-data</span><br><span class=\"line\">    trigger load_persist_props_action</span><br><span class=\"line\"></span><br><span class=\"line\">    # 触发事件 zygote-start, 启动 zygote [2.4.4.1.2.4]</span><br><span class=\"line\">    trigger zygote-start</span><br><span class=\"line\"></span><br><span class=\"line\">    trigger firmware_mounts_complete</span><br><span class=\"line\">    trigger early-boot</span><br><span class=\"line\">    trigger boot</span><br></pre></td></tr></table></figure>\n<p>经过分析，现在已经大致了解脚本的执行过程，接下来分析 servicemanager 和 zygote 的启动。</p>\n<h6 id=\"2-4-4-1-2-3-启动-servicemanager\"><a href=\"#2-4-4-1-2-3-启动-servicemanager\" class=\"headerlink\" title=\"2.4.4.1.2.3 启动 servicemanager\"></a>2.4.4.1.2.3 启动 servicemanager</h6><p>servicemanager 启动脚本的路径为 <code>frameworks/native/cmds/servicemanager/servicemanager.rc</code>，分析这个脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># servicemanager 是 Services 的名称</span><br><span class=\"line\"># &#x2F;system&#x2F;bin&#x2F;servicemanager 是可执行文件的路径</span><br><span class=\"line\">service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager</span><br><span class=\"line\">    # 指定类名为 core 和 animation</span><br><span class=\"line\">    # 当 core 或者 animation 开启 (关闭) 时, servicemanager 也将开启 (关闭)</span><br><span class=\"line\">    class core animation</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置用户为 system</span><br><span class=\"line\">    user system</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置用户组为 system 和 readproc</span><br><span class=\"line\">    group system readproc</span><br><span class=\"line\"></span><br><span class=\"line\">    # 将其标记为设备的关键服务</span><br><span class=\"line\">    # 如果此服务在规定时间内不断重启, 则设备会重启并进入 bootloader</span><br><span class=\"line\">    critical</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置服务重启后执行的操作</span><br><span class=\"line\">    # 每一个操作都是一个 Commands</span><br><span class=\"line\">    onrestart restart healthd</span><br><span class=\"line\">    onrestart restart zygote</span><br><span class=\"line\">    onrestart restart audioserver</span><br><span class=\"line\">    onrestart restart media</span><br><span class=\"line\">    onrestart restart surfaceflinger</span><br><span class=\"line\">    onrestart restart inputflinger</span><br><span class=\"line\">    onrestart restart drm</span><br><span class=\"line\">    onrestart restart cameraserver</span><br><span class=\"line\">    onrestart restart keystore</span><br><span class=\"line\">    onrestart restart gatekeeperd</span><br><span class=\"line\">    onrestart restart thermalservice</span><br><span class=\"line\"></span><br><span class=\"line\">    # 在进程执行 fork 操作之后，将子进程的 pid 写入文件 &#x2F;dev&#x2F;cpuset&#x2F;system-background&#x2F;tasks</span><br><span class=\"line\">    writepid &#x2F;dev&#x2F;cpuset&#x2F;system-background&#x2F;tasks</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置服务的关闭行为</span><br><span class=\"line\">    # shutdown critical 表示此服务在关闭期间不会被杀死, 当关闭超时后才会被杀死</span><br><span class=\"line\">    shutdown critical</span><br></pre></td></tr></table></figure>\n<p>启动 servicemanager 之后，便会进入 <code>frameworks/native/cmds/servicemanager/service_manager.c</code> 的 main 函数。</p>\n<h6 id=\"2-4-4-1-2-4-启动-zygote\"><a href=\"#2-4-4-1-2-4-启动-zygote\" class=\"headerlink\" title=\"2.4.4.1.2.4 启动 zygote\"></a>2.4.4.1.2.4 启动 zygote</h6><p>在 init.rc 脚本中，事件 <code>zygote-start</code> 有 3 个对应的 <code>Actions</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br><span class=\"line\"></span><br><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unsupported</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br><span class=\"line\"></span><br><span class=\"line\">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;encrypted &amp;&amp; property:ro.crypto.type&#x3D;file</span><br><span class=\"line\">    exec_start update_verifier_nonencrypted</span><br><span class=\"line\">    start netd</span><br><span class=\"line\">    start zygote</span><br><span class=\"line\">    start zygote_secondary</span><br></pre></td></tr></table></figure>\n<p>其中，zygote 通过以下语句导入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#x2F;init.$&#123;ro.zygote&#125;.rc</span><br></pre></td></tr></table></figure>\n<p>此语句会根据属性 <code>ro.zygote</code>，导入相应的文件，其中包括：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote32.rc</span><br><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote32_64.rc</span><br><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote64.rc</span><br><span class=\"line\">system&#x2F;core&#x2F;rootdir&#x2F;init.zygote64_32.rc</span><br></pre></td></tr></table></figure>\n<p>zygote 的启动除了依赖事件 <code>zygote-start</code> 以外，还需要某些属性满足特定的值。当上面列出的三个 <code>Actions</code> 中的其中一个满足条件后，便会启动 zygote。</p>\n<p>这里分析启动 Zygote 64 位进程的脚本，脚本文件的路径为 <code>system/core/rootdir/init.zygote64.rc</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># zygote 是 Services 的名称</span><br><span class=\"line\"># &#x2F;system&#x2F;bin&#x2F;app_process64 是可执行文件的路径</span><br><span class=\"line\"># -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server 是启动参数</span><br><span class=\"line\">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class=\"line\">    # 指定类名为 main</span><br><span class=\"line\">    # 当 main 开启 (关闭) 时, zygote 也将开启 (关闭)</span><br><span class=\"line\">    class main</span><br><span class=\"line\"></span><br><span class=\"line\">    # 进程优先级为 -20</span><br><span class=\"line\">    # 由于优先级的取值范围是 -20 ~ 19, 数值越小, 优先级越高, 因此 zygote 进程拥有最高的优先级</span><br><span class=\"line\">    priority -20</span><br><span class=\"line\"></span><br><span class=\"line\">    # 用户和用户组都是 root</span><br><span class=\"line\">    user root</span><br><span class=\"line\">    group root readproc reserved_disk</span><br><span class=\"line\"></span><br><span class=\"line\">    # 创建 socket</span><br><span class=\"line\">    socket zygote stream 660 root system</span><br><span class=\"line\">    socket usap_pool_primary stream 660 root system</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置服务重启后执行的操作</span><br><span class=\"line\">    # 每一个操作都是一个 Commands</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class=\"line\">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class=\"line\">    onrestart restart audioserver</span><br><span class=\"line\">    onrestart restart cameraserver</span><br><span class=\"line\">    onrestart restart media</span><br><span class=\"line\">    onrestart restart netd</span><br><span class=\"line\">    onrestart restart wificond</span><br><span class=\"line\"></span><br><span class=\"line\">    # 在 zygote 进程执行 fork 操作之后，将子进程的 pid 写入文件 &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br><span class=\"line\">    writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br></pre></td></tr></table></figure>\n<p>启动 zygote 之后，便会进入 <code>frameworks/base/cmds/app_process/app_main.cpp</code> 的 main 函数。</p>\n<h3 id=\"2-4-5-进入无限循环状态\"><a href=\"#2-4-5-进入无限循环状态\" class=\"headerlink\" title=\"2.4.5 进入无限循环状态\"></a>2.4.5 进入无限循环状态</h3><p>init 进程启动完成之后，进程就会一直存活，而保持存活的方法就是进入无限循环状态。接下来分析这个过程，源代码的路径为 <code>system/core/init/init.cpp</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置等待 epoll 事件的超时时长</span></span><br><span class=\"line\">        <span class=\"comment\">// 默认情况下会一直处于阻塞状态, 直到有事件发生, 此时 epoll_timeout 取值为 -1</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> epoll_timeout = <span class=\"built_in\">std</span>::optional&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// am 是一个引用, 指向 ActionManager 实例</span></span><br><span class=\"line\">            <span class=\"comment\">// 按顺序执行 ActionManager 中的一个命令 [2.4.5.1]</span></span><br><span class=\"line\">            am.ExecuteOneCommand();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!shutting_down) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取下一次 HandleProcessActions 的时间点 [2.4.5.2]</span></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> next_process_action_time = HandleProcessActions();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next_process_action_time) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 计算出 next_process_action_time 与当前时间的差值</span></span><br><span class=\"line\">                    epoll_timeout = <span class=\"built_in\">std</span>::chrono::<span class=\"built_in\">ceil</span>&lt;<span class=\"built_in\">std</span>::chrono::milliseconds&gt;(</span><br><span class=\"line\">                            *next_process_action_time - boot_clock::now());</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 如果差值小于 0, 说明需要立即进行下一次的循环</span></span><br><span class=\"line\">                    <span class=\"comment\">// 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (*epoll_timeout &lt; <span class=\"number\">0</span>ms) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果 ActionManager 中仍有待执行的命令, 那么 init 进程不会进入阻塞状态, 并立即再次唤起</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置等待 epoll 事件的超时时长为 0, 会使得接下来的 Wait 调用会立即返回, 不阻塞进程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (am.HasMoreCommands()) epoll_timeout = <span class=\"number\">0</span>ms;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 Wait 函数, 等待事件触发 [2.4.1.3]</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.Wait(epoll_timeout); !result) &#123;</span><br><span class=\"line\">            LOG(ERROR) &lt;&lt; result.error();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经分析可知，init 进程进入循环状态后主要的工作有 3 个：</p>\n<ul>\n<li>执行 ActionManager 中的命令。</li>\n<li>重启服务。</li>\n<li>等待 epoll 事件，当事件触发后，调用相应的函数进行处理。结合前面的分析，可知等待的事件有：一个进程通过请求 init 进程向属性服务写入属性，以及 init 进程接收到 <code>SIGCHLD</code> 信号。</li>\n</ul>\n<h4 id=\"2-4-5-1-ActionManager\"><a href=\"#2-4-5-1-ActionManager\" class=\"headerlink\" title=\"2.4.5.1 ActionManager\"></a>2.4.5.1 ActionManager</h4><!-- TODO: 什么是 Action? -->\n\n<!-- TODO: Action 和脚本中的 Actions 有没有关系 -->\n\n<!-- TODO: 添加和执行过程 -->\n\n<p>ActionManager 是 Action 的管理器，它提供了对 Action 的添加、执行、清空等操作。</p>\n<h5 id=\"2-4-5-1-1-添加-Action\"><a href=\"#2-4-5-1-1-添加-Action\" class=\"headerlink\" title=\"2.4.5.1.1 添加 Action\"></a>2.4.5.1.1 添加 Action</h5><!-- TODO: 详细分析 Action 的作用 -->\n\n<p>在 init 进程启动的第二阶段中添加了一些 Action，简单看下其中部分 Action 的作用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// am 是一个引用, 指向 ActionManager 实例</span></span><br><span class=\"line\">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueBuiltinAction(SetupCgroupsAction, <span class=\"string\">&quot;SetupCgroups&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 触发事件 early-init [2.4.4.1.2.1]</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;early-init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 等待 coldboot 完成</span></span><br><span class=\"line\">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class=\"string\">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class=\"string\">&quot;MixHwrngIntoLinuxRng&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(SetMmapRndBitsAction, <span class=\"string\">&quot;SetMmapRndBits&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(SetKptrRestrictAction, <span class=\"string\">&quot;SetKptrRestrict&quot;</span>);</span><br><span class=\"line\">    Keychords keychords;</span><br><span class=\"line\">    am.QueueBuiltinAction(</span><br><span class=\"line\">        [&amp;epoll, &amp;keychords](<span class=\"keyword\">const</span> BuiltinArguments&amp; args) -&gt; Result&lt;Success&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; svc : ServiceList::GetInstance()) &#123;</span><br><span class=\"line\">                keychords.Register(svc-&gt;keycodes());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            keychords.Start(&amp;epoll, HandleKeychord);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Success();</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;KeychordInit&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(console_init_action, <span class=\"string\">&quot;console_init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 触发事件 init [2.4.4.1.2.1]</span></span><br><span class=\"line\">    am.QueueEventTrigger(<span class=\"string\">&quot;init&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    am.QueueBuiltinAction(StartBoringSslSelfTest, <span class=\"string\">&quot;StartBoringSslSelfTest&quot;</span>);</span><br><span class=\"line\">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class=\"string\">&quot;MixHwrngIntoLinuxRng&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 为 init 进程初始化 binder</span></span><br><span class=\"line\">    am.QueueBuiltinAction(InitBinder, <span class=\"string\">&quot;InitBinder&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootmode = GetProperty(<span class=\"string\">&quot;ro.bootmode&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootmode == <span class=\"string\">&quot;charger&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在充电模式下, 添加 Action: 触发事件 charger [2.4.4.1.2.1]</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;charger&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 否则, 添加 Action: 触发事件 late-init [2.4.4.1.2.1]</span></span><br><span class=\"line\">        am.QueueEventTrigger(<span class=\"string\">&quot;late-init&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加 Action: 触发当前所有的属性触发器</span></span><br><span class=\"line\">    am.QueueBuiltinAction(queue_property_triggers_action, <span class=\"string\">&quot;queue_property_triggers&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，在解析脚本或者属性值改变的时候，也会使用 ActionManager 添加 Action。</p>\n<h4 id=\"2-4-5-2-HandleProcessActions\"><a href=\"#2-4-5-2-HandleProcessActions\" class=\"headerlink\" title=\"2.4.5.2 HandleProcessActions\"></a>2.4.5.2 HandleProcessActions</h4><!-- ((s->flags() & SVC_RUNNING) && s->timeout_period()) -->\n\n<!-- 详细分析 service 的重启过程 -->\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"built_in\">std</span>::optional&lt;boot_clock::time_point&gt; <span class=\"title\">HandleProcessActions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::optional&lt;boot_clock::time_point&gt; next_process_action_time;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历 ServiceList</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; s : ServiceList::GetInstance()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断服务是否处于运行中状态, 以及是否有超时时长</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((s-&gt;flags() &amp; SVC_RUNNING) &amp;&amp; s-&gt;timeout_period()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算出服务启动的超时时间</span></span><br><span class=\"line\">            <span class=\"keyword\">auto</span> timeout_time = s-&gt;time_started() + *s-&gt;timeout_period();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (boot_clock::now() &gt; timeout_time) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果当前时间已大于服务启动的超时时间, 说明服务启动已超时</span></span><br><span class=\"line\">                s-&gt;Timeout();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 更新 next_process_action_time</span></span><br><span class=\"line\">                <span class=\"comment\">// 此时, next_process_action_time 表示最近的, 需要检查服务是否启动成功的时间点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!next_process_action_time || timeout_time &lt; *next_process_action_time) &#123;</span><br><span class=\"line\">                    next_process_action_time = timeout_time;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果服务不带有标志位 SVC_RESTARTING, 则不需要重启, 继续 for 循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(s-&gt;flags() &amp; SVC_RESTARTING)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算出服务启动的超时时间</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> restart_time = s-&gt;time_started() + s-&gt;restart_period();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 现在服务需要重启, 接下来重启已满足重启条件的服务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (boot_clock::now() &gt; restart_time) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前时间已大于服务的重启时间, 那么立即启动服务</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = s-&gt;Start(); !result) &#123;</span><br><span class=\"line\">                LOG(ERROR) &lt;&lt; <span class=\"string\">&quot;Could not restart process &#x27;&quot;</span> &lt;&lt; s-&gt;name() &lt;&lt; <span class=\"string\">&quot;&#x27;: &quot;</span> &lt;&lt; result.error();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 更新 next_process_action_time</span></span><br><span class=\"line\">            <span class=\"comment\">// 此时, next_process_action_time 表示最近的, 需要对服务进行重启操作的时间点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!next_process_action_time || restart_time &lt; *next_process_action_time) &#123;</span><br><span class=\"line\">                next_process_action_time = restart_time;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next_process_action_time;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数的工作有：</p>\n<ol>\n<li>检查带有标志位 <code>SVC_RUNNING</code> 的服务是否超时，如果服务启动超时，则调用 <code>Timeout</code> 函数，否则更新下次检查的时间点。</li>\n<li>当服务带有标志位 <code>SVC_RESTARTING</code> 时，说明服务需要重启。如果当前时间已大于服务的重启时间，则立即重启服务；否则，更新下次重启的时间点。 </li>\n</ol>\n<p>经分析可知，<code>next_process_action_time</code> 可能表示下一次的检查服务是否启动超时的时间点，也可能表示下一次为某个服务重启的时间点。</p>\n<p>注意到，在之前的分析信号 [2.4.3.1.4.3] 提到过，当 init 收到子进程终结的信号之后，会为有重启需要的服务添加标志位 <code>SVC_RESTARTING</code>。那么现在可以知道，在 init 进程进入无限循环状态后，就会处理这些带有标志位 <code>SVC_RESTARTING</code> 的服务，重启满足条件的服务。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://gityuan.com/2016/02/01/android-booting/\">Android系统启动-综述</a></p>\n<p><a href=\"http://gityuan.com/2016/02/05/android-init/\">Android系统启动-Init篇</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man7/epoll.7.html\">epoll(7)</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Signal_(IPC)\">Signal</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man7/signal.7.html\">signal(7)</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man2/wait.2.html\">wait(2)</a></p>\n<p><a href=\"https://man7.org/linux/man-pages/man2/signalfd.2.html\">signalfd(2)</a></p>"}],"PostAsset":[{"_id":"source/_posts/2021-03-10-elementary-function/constant-function-example-1.png","slug":"constant-function-example-1.png","post":"ckmsyc4rc00075npr842r5mu3","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-10-elementary-function/exponential-function-example-1.png","slug":"exponential-function-example-1.png","post":"ckmsyc4rc00075npr842r5mu3","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-10-elementary-function/exponential-function-example-2.png","slug":"exponential-function-example-2.png","post":"ckmsyc4rc00075npr842r5mu3","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-10-elementary-function/logarithmic-function-example-1.png","slug":"logarithmic-function-example-1.png","post":"ckmsyc4rc00075npr842r5mu3","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-10-elementary-function/logarithmic-function-example-2.png","slug":"logarithmic-function-example-2.png","post":"ckmsyc4rc00075npr842r5mu3","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-10-elementary-function/logarithmic-function-example-3.png","slug":"logarithmic-function-example-3.png","post":"ckmsyc4rc00075npr842r5mu3","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-10-elementary-function/power-function-example-1.png","slug":"power-function-example-1.png","post":"ckmsyc4rc00075npr842r5mu3","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-10-elementary-function/power-function-example-2.png","slug":"power-function-example-2.png","post":"ckmsyc4rc00075npr842r5mu3","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-10-elementary-function/power-function-example-3.png","slug":"power-function-example-3.png","post":"ckmsyc4rc00075npr842r5mu3","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-10-elementary-function/power-function-example-4.png","slug":"power-function-example-4.png","post":"ckmsyc4rc00075npr842r5mu3","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-10-elementary-function/power-function-example-5.png","slug":"power-function-example-5.png","post":"ckmsyc4rc00075npr842r5mu3","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-10-elementary-function/power-function-example-6.png","slug":"power-function-example-6.png","post":"ckmsyc4rc00075npr842r5mu3","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-10-elementary-function/power-function-example-7.png","slug":"power-function-example-7.png","post":"ckmsyc4rc00075npr842r5mu3","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckmsyc4rc00075npr842r5mu3","category_id":"ckmsyc4re00095npr7a605gff","_id":"ckmsyc4ri000h5nprehnabbfb"},{"post_id":"ckmsyc4r400015nprahox2qqz","category_id":"ckmsyc4ra00055nprdp3d27gx","_id":"ckmsyc4rj000k5npr320783gc"},{"post_id":"ckmsyc4r400015nprahox2qqz","category_id":"ckmsyc4rh000f5npr8h940wmh","_id":"ckmsyc4rk000l5nprezqbgn2y"},{"post_id":"ckmsyc4rg000d5nprei90h7bk","category_id":"ckmsyc4ri000i5nprffv13va1","_id":"ckmsyc4rm000t5npr7w6738m6"},{"post_id":"ckmsyc4rg000d5nprei90h7bk","category_id":"ckmsyc4rk000m5npr6wjm0y3r","_id":"ckmsyc4rm000u5npr8r2oe4me"},{"post_id":"ckmsyc4rg000d5nprei90h7bk","category_id":"ckmsyc4rl000p5npr5xe96pw7","_id":"ckmsyc4rm000v5npr8nbdbd84"},{"post_id":"cksh4umd7000cqkprfer8avcg","category_id":"cksftg56z0001hlpr9ry98ndj","_id":"cksh4umd9000dqkpr88dfebo7"},{"post_id":"cksh4vd82000eqkpr503zbpok","category_id":"ckmsyc4ri000i5nprffv13va1","_id":"cksh4vd83000gqkpr7ibr1zwe"},{"post_id":"cksh4vtpi000hqkprcbem8gz5","category_id":"ckmsyc4ri000i5nprffv13va1","_id":"cksh4vtpk000iqkpr6e5khz3u"},{"post_id":"cksh4vtpi000hqkprcbem8gz5","category_id":"ckmsyc4rk000m5npr6wjm0y3r","_id":"cksh4vtpk000jqkpreg0bgv4h"},{"post_id":"cksh4vtpi000hqkprcbem8gz5","category_id":"ckrzsw20000076spr2i0g1ol0","_id":"cksh4vtpk000kqkpr65034ih4"},{"post_id":"cksh4x6tu000lqkprd6fo4ta8","category_id":"ckmsyc4ri000i5nprffv13va1","_id":"cksh4x6tw000nqkprclpo6mli"},{"post_id":"cksol4flf00000cprd5ks579o","category_id":"ckmsyc4ri000i5nprffv13va1","_id":"cksol4fli00010cpr5tmrc70r"},{"post_id":"ckvt7aq4g0000elpre24685ab","category_id":"ckmsyc4ri000i5nprffv13va1","_id":"ckvt7aq4o0006elpr646t3y4w"},{"post_id":"ckvt7aq4g0000elpre24685ab","category_id":"ckmsyc4rk000m5npr6wjm0y3r","_id":"ckvt7aq4p0008elpr7y0ralia"},{"post_id":"ckvt7aq4g0000elpre24685ab","category_id":"ckmsyc4rl000o5npr0v7gbch2","_id":"ckvt7aq4p000aelprdp0f43dy"},{"post_id":"ckvt7aq4k0001elprgcal1w0y","category_id":"ckoifpt4j0006m1pr7zm18tlb","_id":"ckvt7aq4p000belpr8c5ohhed"},{"post_id":"ckvt7aq4m0003elpr3t86bkmy","category_id":"ckoifpt4j0006m1pr7zm18tlb","_id":"ckvt7aq4p000celpr0ica8k3i"},{"post_id":"ckvt7ngc6000felprc7r9ejwx","category_id":"ckmsyc4ri000i5nprffv13va1","_id":"ckvt7ngc7000gelprhm6gfx5v"}],"PostTag":[{"post_id":"ckmsyc4rd00085npr5cpiccvy","tag_id":"ckmsyc4rc00065nprab0eb47i","_id":"ckmsyc4rg000c5npr9dhff62k"},{"post_id":"ckmsyc4r700035npr5dbfdrkh","tag_id":"ckmsyc4rc00065nprab0eb47i","_id":"ckmsyc4rh000e5npr4ww55qqb"},{"post_id":"ckmsyc4r900045nprbgj32va1","tag_id":"ckmsyc4rf000b5npr0usmgdhg","_id":"ckmsyc4rh000g5npr28u2f6vd"},{"post_id":"cksh4vd82000eqkpr503zbpok","tag_id":"ckrzsw1zu00016spr8o8bfriv","_id":"cksh4vd83000fqkpr9fr9h451"},{"post_id":"cksh4x6tu000lqkprd6fo4ta8","tag_id":"ckrzsw1zu00016spr8o8bfriv","_id":"cksh4x6tw000mqkprfbq3cfzj"},{"post_id":"ckvt7aq4g0000elpre24685ab","tag_id":"ckmue52pw00015hpr5k9idsoy","_id":"ckvt7aq4m0002elprcutjfte4"},{"post_id":"ckvt7aq4k0001elprgcal1w0y","tag_id":"ckmue52pz00025hprh9my49dd","_id":"ckvt7aq4n0004elpr4byq0zw9"},{"post_id":"ckvt7aq4k0001elprgcal1w0y","tag_id":"ckmue52pw00015hpr5k9idsoy","_id":"ckvt7aq4o0005elpr7gurg1dd"},{"post_id":"ckvt7aq4m0003elpr3t86bkmy","tag_id":"ckmue52pz00025hprh9my49dd","_id":"ckvt7aq4p0007elpr0iwmah7s"},{"post_id":"ckvt7aq4m0003elpr3t86bkmy","tag_id":"ckmue52pw00015hpr5k9idsoy","_id":"ckvt7aq4p0009elpr5jupdxw0"}],"Tag":[{"name":"Test","_id":"ckmsyc4rc00065nprab0eb47i"},{"name":"ComputerScience","_id":"ckmsyc4rf000b5npr0usmgdhg"},{"name":"Graphics","_id":"ckmue52pw00015hpr5k9idsoy"},{"name":"Basis","_id":"ckmue52pz00025hprh9my49dd"},{"name":"Zygote","_id":"ckrzsw1zu00016spr8o8bfriv"}]}}